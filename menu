#!/bin/bash

### --- ZONA DE VARIABLES (INICIO) --- ###
# Directorios y Archivos de Base de Datos
DB_ROOT="/etc/reagens"
mkdir -p "$DB_ROOT"
DB_TRAFFIC="$DB_ROOT/traffic.db"

# --- BLINDAJE DE SEGURIDAD REAGENS ---
fun_fix_permissions() {
    # Solo aplica si los directorios existen
    [[ -d "/etc/adm-lite" ]] && chmod 700 /etc/adm-lite
    [[ -d "/etc/reagens" ]] && chmod 700 /etc/reagens
    
    # Archivos sensibles (Solo root lee/escribe)
    chmod 600 /etc/adm-lite/*.db 2>/dev/null
    chmod 600 /etc/reagens/traffic.db 2>/dev/null
    chmod 600 /etc/reagens_base_pass 2>/dev/null
    chmod 600 /etc/reagens/default_pass 2>/dev/null
}

# Ejecutar al iniciar el script
fun_fix_permissions
# --- CREAR ACCESO DIRECTO 'menu' ---
if [[ ! -f "/usr/bin/menu" ]]; then
    ln -s "$(readlink -f "$0")" /usr/bin/menu
    chmod +x /usr/bin/menu
    # Opcional: Hacer que el men� abra solo al loguear
    echo "menu" >> /root/.bashrc
fi

# Base de datos SSH y Tokens
mkdir -p /etc/adm-lite
DB_SSH="/etc/adm-lite/usuarios_ssh.db"
DB_TOKENS="/etc/adm-lite/usuarios_token.db"

# --- FIX ALMALINUX / RHEL ---
# Creamos los archivos vacios AHORA para que no den error al leerlos luego
if [[ ! -f "$DB_SSH" ]]; then touch "$DB_SSH"; fi
if [[ ! -f "$DB_TOKENS" ]]; then touch "$DB_TOKENS"; fi
if [[ ! -f "$DB_TRAFFIC" ]]; then touch "$DB_TRAFFIC"; fi
### ---------------------------------- ###

# ==================================================
# HIRVIP VPN PRO MANAGER FOR VPS - FINAL TRAFFIC EDITION
# INCLUYE: SSH, TOKEN, XRAY, HYSTERIA, SLOWDNS, UDP
# SISTEMA DE CUOTAS (MB) REAL + PERSISTENCIA
# ==================================================

# --- COLORES Y ESTILOS ---
C_BARRA='\033[1;34m'      # Azul Fuerte
C_TITULO='\033[1;44;37m'  # Fondo Azul, Letra Blanca
C_TEXTO='\033[1;37m'      # Blanco
C_DATO='\033[1;33m'       # Amarillo
C_ROJO='\033[1;31m'       # Rojo
C_VERDE='\033[1;32m'      # Verde
C_RESET='\033[0m'         # Reset

# --- BASE DE DATOS DE TRAFICO (NUEVO SISTEMA) ---
DB_ROOT="/etc/reagens"
DB_TRAFFIC="$DB_ROOT/traffic.db"
mkdir -p "$DB_ROOT"
touch "$DB_TRAFFIC"

# --- DIRECTORIOS Y ARCHIVOS ---
if [[ -f "/usr/local/etc/xray/config.json" ]]; then
    V2RAY_CONF="/usr/local/etc/xray/config.json"
    SERVICE_NAME="xray"
elif [[ -f "/usr/local/etc/v2ray/config.json" ]]; then
    V2RAY_CONF="/usr/local/etc/v2ray/config.json"
    SERVICE_NAME="v2ray"
else
    V2RAY_CONF="/usr/local/etc/xray/config.json"
    SERVICE_NAME="xray"
fi

# DIRECTORIOS HYSTERIA
HY_CONF="/etc/hysteria/config.yaml"
HY_DIR="/etc/hysteria"
HY_USERS_DB="/etc/reagens/users/hysteria"

# DIRECTORIOS NUEVOS (SLOWDNS)
SLOWDNS_DIR="/etc/slowdns"

DB_USERS="/etc/reagens/users"
mkdir -p "$DB_USERS"
mkdir -p "$DB_USERS/v2ray"
mkdir -p "$HY_USERS_DB"
mkdir -p "/etc/reagens/bot"
FILE_PASS="/etc/reagens/default_pass"
TOKEN_PASS_FILE="/etc/reagens_base_pass"

GUARD_BIN="/usr/local/bin/reagens-guard"
MONITOR_BIN="/usr/local/bin/reagens-monitor" 
CHECKUSER_BIN="/etc/reagens/bin/checkuser.py"
CHECKUSER_SERVICE="/etc/systemd/system/checkuser-reagens.service"
BOT_SCRIPT="/etc/reagens/bot/reagens_bot.py"
BOT_SERVICE="/etc/systemd/system/reagens-bot.service"

# --- DEPENDENCIAS UNIVERSALES (OPTIMIZADO - NO LAG AL INICIO) ---
# Solo verifica paquetes si NO existe el archivo de control.
if [[ ! -f "/etc/reagens/.install_check" ]]; then
    echo "Verificando dependencias por primera vez..."
    if [[ -f /etc/redhat-release ]]; then
    PM="yum"
    # Paquetes especificos para la familia RedHat (Rocky/Alma/CentOS)
    PKG_LIST="jq psmisc bc nano git curl socat net-tools python3-pip iptables iptables-services lsof wget cmake make gcc unzip openssl bind-utils"
else
    PM="apt-get"
    # Paquetes especificos para la familia Debian (Ubuntu/Debian)
    PKG_LIST="jq psmisc bc nano git curl socat net-tools python3-pip iptables iptables-persistent lsof wget cmake make gcc build-essential unzip uuid-runtime openssl dnsutils"
fi

    for p in $PKG_LIST; do
        if ! command -v $p &> /dev/null; then 
            $PM install -y $p > /dev/null 2>&1
        fi
    done
    # Crear archivo bandera para no volver a chequear
    touch "/etc/reagens/.install_check"
fi

# --- FUNCION PARA CENTRAR TITULOS (MEJORADA) ---
msg_center() {
  local text="$1"
  local clean_text=$(echo -e "$text" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g")
  local len=${#clean_text}
  local cols=53 # Ancho fijo para tu men�
  local space=$(( ($cols - $len) / 2 ))
  [[ $space -lt 0 ]] && space=0
  printf "%${space}s" " "
  echo -e "$text"
}

# --- VERIFICADOR DE CONFLICTOS DE PUERTOS ---
fun_check_port() {
    local port=$1
    local service_name=$2
    
    # Verifica si el puerto est� siendo escuchado
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null ; then
        local process=$(lsof -i :$port | awk 'NR==2 {print $1}')
        echo -e "${C_ROJO}[X] ERROR: El puerto $port ya est� ocupado por: $process.${C_RESET}"
        echo -e "${C_DATO}[!] Det�n ese servicio antes de instalar $service_name.${C_RESET}"
        return 1 # Puerto ocupado
    else
        return 0 # Puerto libre
    fi
}

# --- GUARDADO PERSISTENTE DE REGLAS (CORRECCI�N DEFINITIVA) ---
fun_save_iptables() {
    if [[ -f /etc/redhat-release ]]; then
        # Para Rocky, Alma y CentOS
        yum install iptables-services -y &>/dev/null
        systemctl enable iptables &>/dev/null
        service iptables save >/dev/null 2>&1
    else
        # Para Ubuntu y Debian
        if ! dpkg -s iptables-persistent >/dev/null 2>&1; then
            apt-get install iptables-persistent -y &>/dev/null
        fi
        netfilter-persistent save >/dev/null 2>&1
    fi
}

# --- OPTIMIZADOR GAMING & EXTREME PERFORMANCE (EXTREMIN) ---
fun_gaming_pro() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} GAMING OPTIMIZER & EXTREMIN PRO ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Este sistema modifica el Kernel para reducir el Ping"
    echo -e " y prioriza el tr�fico de juegos en los t�neles VPN."
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_TEXTO}[1] > ACTIVAR MODO GAMING (Latencia Cero)${C_RESET}"
    echo -e " ${C_TEXTO}[2] > DESACTIVAR Y VOLVER A CONFIG. ORIGINAL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
    echo -n " Opcion: "
    read opt_g

    case $opt_g in
        1)
            echo -e "\n ${C_DATO}[+] Aplicando ajustes sysctl de alto rendimiento...${C_RESET}"
            # Backup de seguridad
            [[ ! -f /etc/sysctl.conf.bak ]] && cp /etc/sysctl.conf /etc/sysctl.conf.bak
            
            # Limpieza de etiquetas anteriores
            sed -i '/reagens_gaming/d' /etc/sysctl.conf
            
            # Inyecci�n de par�metros de red para Gaming
            cat <<EOF >> /etc/sysctl.conf
# reagens_gaming_start
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_autocorking = 0
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1
net.core.netdev_max_backlog = 5000
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
# reagens_gaming_end
EOF
            sysctl -p >/dev/null 2>&1

            echo -e " ${C_DATO}[+] Activando sistema EXTREMIN (Prioridad CPU)...${C_RESET}"
            # Elevamos la prioridad de los procesos de t�nel a nivel -15 (Casi tiempo real)
            for srv in sshd dropbear xray hysteria-server reagens-udp; do
                PIDS=$(pgrep -x $srv)
                for pid in $PIDS; do
                    renice -n -15 -p $pid >/dev/null 2>&1
                done
            done
            
            echo -e "${C_VERDE} �VPS OPTIMIZADA PARA GAMING EXITOSAMENTE!${C_RESET}"
            sleep 3 ;;
            
        2)
            echo -e "\n ${C_ROJO}[!] Revirtiendo ajustes a estado original...${C_RESET}"
            if [[ -f /etc/sysctl.conf.bak ]]; then
                cp /etc/sysctl.conf.bak /etc/sysctl.conf
                sysctl -p >/dev/null 2>&1
                echo -e "${C_VERDE} Configuraci�n original restaurada.${C_RESET}"
            else
                echo -e "${C_ROJO} No se encontr� backup de configuraci�n.${C_RESET}"
            fi
            sleep 2 ;;
        *) return ;;
    esac
}

fun_salir_script() {
    clear
    echo ""
    msg_center "${C_BARRA} ______  _____   ___   _____   _____  _   _  _____${NC}"
    msg_center "${C_BARRA}| ___ \ |  ___| / _ \ |  __ \ |  ___|| \ | |/  ___|${NC}"
    msg_center "${C_BARRA}| |_/ / | |__  / /_\ \| |  \/ | |__  |  \| |\ \`--. ${NC}"
    msg_center "${C_BARRA}|    /  |  __| |  _  || | __  |  __| | . \` | \`--. \\\\${NC}"
    msg_center "${C_BARRA}| |\ \  | |___ | | | || |_\ \ | |___ | |\  |/\__/ /${NC}"
    msg_center "${C_BARRA}\_| \_| \____/ \_| |_/ \____/ \____/ \_| \_/\____/ ${NC}"
    echo ""
    msg_center "${YELLOW}CREATOR : ALEXVIP${NC}"
    echo ""
    msg_center "${CYAN}Para iniciar HIRVIP VPN PRO MANAGER escriba: menu${NC}"
    echo ""
    exit 0
}

# ==================================================
# MOTOR DE TRAFICO NUCLEAR (RAM IO - INFALIBLE)
# ==================================================
install_traffic_service() {
    systemctl stop reagens-monitor 2>/dev/null
    
    cat << 'EOF' > /usr/local/bin/reagens-monitor
#!/bin/bash
DB="/etc/reagens/traffic.db"

while true; do
    if [[ -f "$DB" ]]; then
        TEMP_DB=$(mktemp)
        while IFS='|' read -r user limit used state; do
            # 1. Obtener bytes directamente del Kernel via IPTables
            # Buscamos la regla del usuario y extraemos la columna de bytes exactos
            current_bytes=$(iptables -L OUTPUT -v -n -x | grep -w "owner UID match $user" | awk '{print $2}')
            [[ -z "$current_bytes" ]] && current_bytes=0
            
            # 2. Sumar al acumulado de la base de datos
            new_total_used=$(echo "$used + $current_bytes" | bc)
            
            # 3. Poner el contador de IPTables a cero para no sumar doble en el proximo ciclo
            iptables -Z OUTPUT $(iptables -L OUTPUT --line-numbers | grep -w "owner UID match $user" | awk '{print $1}' | head -n1) 2>/dev/null

            # 4. Verificaci�n de L�mite (Corte de cuenta)
            new_state="$state"
            if [[ "$limit" -gt 0 ]] && [[ "$new_total_used" -ge "$limit" ]]; then
                 if [[ "$state" == "1" ]]; then
                    passwd -l "$user" >/dev/null 2>&1
                    pkill -u "$user" >/dev/null 2>&1
                    new_state="0"
                 fi
            fi
            echo "$user|$limit|$new_total_used|$new_state" >> "$TEMP_DB"
        done < "$DB"
        mv "$TEMP_DB" "$DB" && chmod 600 "$DB"
    fi
    sleep 10
done
EOF
    chmod +x /usr/local/bin/reagens-monitor
    systemctl restart reagens-monitor
}

# 2. Restaurar reglas de iptables (Persistencia tras reinicio)
restore_traffic_rules() {
    if [[ -f "$DB_TRAFFIC" ]]; then
        while IFS='|' read -r user limit used state; do
            if id "$user" &>/dev/null; then
                if ! iptables -C OUTPUT -m owner --uid-owner "$user" -j ACCEPT 2>/dev/null; then
                    iptables -I OUTPUT -m owner --uid-owner "$user" -j ACCEPT
                fi
            fi
        done < "$DB_TRAFFIC"
    fi
}

# 3. Funci�n auxiliar para agregar usuarios al monitor (Persistencia a�adida)
# --- FUNCI�N REPARADA: PREVIENE DUPLICADOS EN TRAFFIC.DB ---
add_traffic_user() {
    local u=$1
    local mb=$2
    local bytes_limit=0
    [[ "$mb" -gt 0 ]] && bytes_limit=$(echo "$mb * 1048576" | bc)
    
    # Limpiar rastro previo para evitar duplicados
    sed -i "/^$u|/d" "$DB_TRAFFIC"
    
    # Registro inicial en la DB
    echo "$u|$bytes_limit|0|1" >> "$DB_TRAFFIC"
    
    # Crear regla de conteo en el Kernel (owner module)
    # Esto le dice a Linux: "Cuenta cada byte que saque este usuario"
    iptables -I OUTPUT -m owner --uid-owner "$u" -j ACCEPT 2>/dev/null
    fun_save_iptables
}

# --- DATOS DEL SISTEMA (VERSION FINAL: UNIVERSAL + RAPIDA) ---
obtener_datos() {
    # Definir rutas
    CACHE_STATS="/tmp/reagens_stats_cache"
    DB_SSH="/etc/adm-lite/usuarios_ssh.db"
    DB_TOKENS="/etc/adm-lite/usuarios_token.db"
    DB_TRAFFIC="/etc/reagens/traffic.db"

    # 1. CARGA DE CACH� (Lo que ve el usuario al instante)
    if [[ -f "$CACHE_STATS" ]]; then
        source "$CACHE_STATS"
    else
        ONLI_USR="."; EXP_USR="."; LOK_USR="."; TOTAL_USR="."
        IP_DISP="Cargando..."
    fi

    # 2. DATOS DE HARDWARE (Se calculan al momento)
    if [ -f /etc/os-release ]; then 
        OS_NAME=$(grep -w "PRETTY_NAME" /etc/os-release | cut -d= -f2 | tr -d '"')
    else 
        OS_NAME="Linux"
    fi
    OS_NAME=${OS_NAME:0:13}
    FECHA_ACT=$(date +%d/%m/%y)
    HORA_ACT=$(date +%H:%M:%S)
    
    # --- RAM UNIVERSAL ---
# Obtenemos valores en MB netos para evitar errores de lectura de letras (G, M, K)
local ram_out=$(free -m | grep Mem:)
local ram_t=$(echo "$ram_out" | awk '{print $2}')
local ram_u=$(echo "$ram_out" | awk '{print $3}')
local ram_f=$(echo "$ram_out" | awk '{print $7}') # Available es la columna 7 en Linux modernos

# Si la columna 7 est� vac�a, usamos la 4 (Free)
[[ -z "$ram_f" ]] && ram_f=$(echo "$ram_out" | awk '{print $4}')

RAM_TOTAL="${ram_t}Mi"
RAM_USED="${ram_u}Mi"
RAM_FREE="${ram_f}Mi"
RAM_PERC=$(( (ram_u * 100) / ram_t ))"%"
    
    # CPU (FIX UNIVERSAL ALMALINUX / UBUNTU)
    # Usamos /proc/stat que funciona en todos los Linux igual
    CPU_CORES=$(nproc)
    CPU_USAGE=$(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage}' | awk -F. '{print $1}')"%"
    
    # Frecuencia CPU
    local freq=$(grep -m1 "cpu MHz" /proc/cpuinfo | awk '{print $4}' | cut -d. -f1)
    if [[ -n "$freq" ]]; then freq=$(awk "BEGIN {printf \"%.1fGHz\", $freq/1000}"); else freq="Virtual"; fi
    CPU_INFO="$CPU_CORES @ $freq"

    # 3. ACTUALIZADOR SILENCIOSO (Calcula usuarios en 2do plano)
    (
        # IP
        if [[ ! -f "/tmp/ip_cache" ]] || [[ $(find /tmp/ip_cache -mmin +60) ]]; then
            curl -s -m 2 ipv4.icanhazip.com > /tmp/ip_cache
        fi
        NEW_IP=$(cat /tmp/ip_cache 2>/dev/null); NEW_IP=${NEW_IP:0:15}

        # ONLINE (Procesos sshd/dropbear reales)
        # COPIA ESTA VERSI�N PARA MAYOR PRECISI�N EN ROCKY:
# --- ONLINE (FIX PARA ELIMINAR CONEXIONES FANTASMA) ---
        NEW_ONLI=0
        if [[ -f "$DB_SSH" || -f "$DB_TOKENS" ]]; then
            # Creamos una lista de todos tus usuarios reales de las DBs
            USR_DATABASE=$(awk -F'|' '{print $1}' "$DB_SSH" "$DB_TOKENS" 2>/dev/null | sort -u)
            
            for u_db in $USR_DATABASE; do
                # pgrep -u filtra estrictamente por el nombre del usuario
                # Esto ignora procesos de root, de sistema y falsos positivos
                conx_real=$(pgrep -u "$u_db" -f "sshd|dropbear" | wc -l)
                NEW_ONLI=$((NEW_ONLI + conx_real))
            done
        fi

for user in $USR_LIST; do
    # Verificamos si el usuario tiene procesos ssh o dropbear activos
    if pgrep -u "$user" -f "sshd|dropbear" >/dev/null 2>&1; then
        # Contamos cu�ntas conexiones tiene ese usuario
        count=$(ps -u "$user" -f | grep -E "sshd|dropbear" | grep -v "grep" | wc -l)
        NEW_ONLI=$((NEW_ONLI + count))
    fi
done

        # TOTAL
        T1=$(wc -l < "$DB_SSH" 2>/dev/null || echo 0)
        T2=$(wc -l < "$DB_TOKENS" 2>/dev/null || echo 0)
        NEW_TOTAL=$((T1 + T2))

        # BLOQUEADOS (Lee DB Monitor)
        NEW_LOK=0
        if [[ -f "$DB_TRAFFIC" ]]; then
            NEW_LOK=$(awk -F'|' '$4 == "0" {count++} END {print count+0}' "$DB_TRAFFIC")
        fi
        
        # EXPIRADOS (Calculo fecha)
        TODAY=$(date +%Y-%m-%d)
        EXP1=0; EXP2=0
        if [[ -f "$DB_SSH" ]]; then
            EXP1=$(awk -F'|' -v today="$TODAY" '$3 < today && $3 != "" {count++} END {print count+0}' "$DB_SSH")
        fi
        if [[ -f "$DB_TOKENS" ]]; then
            EXP2=$(awk -F'|' -v today="$TODAY" '$3 < today && $3 != "" {count++} END {print count+0}' "$DB_TOKENS")
        fi
        NEW_EXP=$((EXP1 + EXP2))

        # Guardar Cache
        cat <<EOF_CACHE > "$CACHE_STATS"
IP_DISP="$NEW_IP"
ONLI_USR="$NEW_ONLI"
TOTAL_USR="$NEW_TOTAL"
LOK_USR="$NEW_LOK"
EXP_USR="$NEW_EXP"
EOF_CACHE
    ) & >/dev/null 2>&1
}

get_v2_days() {
    local user=$1
    local meta="$DB_USERS/v2ray/$user"
    if [[ -f "$meta" ]]; then
        source "$meta"
        if [[ -z "$EXP" ]]; then 
            echo "0"
            return
        fi
        local exp_sec=$(date -d "$EXP" +%s)
        local today_sec=$(date +%s)
        echo $(( (exp_sec - today_sec) / 86400 ))
    else 
        echo "0"
    fi
}

obtener_clave_default() { 
    if [[ -f "$FILE_PASS" ]]; then 
        cat "$FILE_PASS"
    else 
        echo ""
    fi 
}

listar_usuarios_vpn_all() { 
    awk -F: '$3>=1000 {print $1}' /etc/passwd | grep -vE "^(ubuntu|debian|centos|fedora|opc|admin|ec2-user|nobody|root|syslog)$" 
}

# --- FUNCION SPEEDTEST OOKLA REPARADA (MULTIVERSAL) ---
fun_speedtest() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SPEEDTEST OOKLA (SISTEMA DE EMERGENCIA) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if ! command -v speedtest &> /dev/null; then
        echo -e " ${C_DATO}[+] Limpiando instalaciones fallidas...${C_RESET}"
        # Borrar rastros de repositorios que fallaron
        sudo rm -f /etc/apt/sources.list.d/ookla_speedtest-cli.list
        
        echo -e " ${C_DATO}[+] Descargando Binario Oficial de Ookla...${C_RESET}"
        ARCH=$(uname -m)
        
        # Detectar arquitectura y descargar el archivo correcto
        if [[ "$ARCH" == "x86_64" ]]; then
            URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz"
        elif [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]]; then
            URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-aarch64.tgz"
        else
            URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz"
        fi

        # Descarga e instalaci�n manual (bypass de apt)
        wget -qO speedtest.tgz "$URL"
        tar -xzf speedtest.tgz speedtest
        sudo mv speedtest /usr/bin/
        sudo chmod +x /usr/bin/speedtest
        rm -f speedtest.tgz speedtest.8 speedtest.md
    fi
    
    if command -v speedtest &> /dev/null; then
        echo -e " ${C_VERDE}Ejecutando prueba de velocidad...${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        speedtest --accept-license --accept-gdpr
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    else
        echo -e "${C_ROJO} [X] Error: No se pudo instalar el binario.${C_RESET}"
    fi
    
    echo -e " ${C_DATO}Prueba Finalizada.${C_RESET}"
    read -p " Presione Enter para continuar..."
}

# --- SELECCIONAR SOLO USUARIOS SSH (FILTRADO) ---
seleccionar_usuario_ssh() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SELECCIONAR USUARIO SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if [[ ! -f "$DB_SSH" ]]; then echo -e " ${C_ROJO}No hay base de datos.${C_RESET}"; return 1; fi
    
    i=1
    declare -a users_array
    # Leemos solo de la DB exclusiva de SSH
    while IFS='|' read -r u p e l m; do
        if [[ ! -z "$u" ]]; then
            echo -e " [${C_DATO}$i${C_RESET}] $u"
            users_array[$i]=$u
            let i++
        fi
    done < "$DB_SSH"

    if [[ $i -eq 1 ]]; then 
        echo -e " ${C_ROJO}No hay usuarios SSH registrados.${C_RESET}"
        sleep 2; return 1
    fi

    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Seleccione numero: "
    read opt_user
    USER_SEL=${users_array[$opt_user]}
    if [[ -z "$USER_SEL" ]]; then 
        echo -e " ${C_ROJO}Seleccion invalida.${C_RESET}"; sleep 1; return 1
    fi
    return 0
}

# --- CREAR USUARIO SSH (SIN MB) ---
fun_crear_usuario() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CREAR USUARIO SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Nombre de Usuario: "; read u
    [[ -z "$u" ]] && return
    if id "$u" >/dev/null 2>&1; then echo -e "${C_ROJO}Existe.${C_RESET}"; sleep 2; return; fi
    
    def_pass=$(obtener_clave_default)
    if [[ ! -z "$def_pass" ]]; then
        echo -e " Clave Default: ${C_DATO}$def_pass${C_RESET}"
        echo -n " Clave (Enter para Default): "; read p
        [[ -z "$p" ]] && p="$def_pass"
    else
        echo -n " Clave: "; read p
    fi
    [[ -z "$p" ]] && { echo "Error: Clave vacia"; sleep 2; return; }
    
    echo -n " Dias de duracion: "; read d
    echo -n " Limite Conexiones (0=Inf): "; read lc
    [[ -z "$lc" ]] && lc=0
    
    fd=$(date -d "+$d days" +%Y-%m-%d)
    useradd -M -s /usr/local/bin/reagens-shell "$u"
    echo "$u:$p" | chpasswd
    chage -E "$fd" "$u"
    
    add_traffic_user "$u" "0"
    echo "$u|$p|$fd|$lc|0" >> "$DB_SSH"
    
    echo -e "\n ${C_VERDE}Usuario $u creado por $d dias.${C_RESET}"
    sleep 2
}

# --- LISTA SSH LIMPIA (CORREGIDA CONTRA ERRORES MATEM�TICOS) ---
fun_detalles_usuarios() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LISTA DE USUARIOS SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    printf "${C_TEXTO}%-15s %-15s %-10s %-10s${C_RESET}\n" "USUARIO" "CLAVE" "DIAS" "LIMIT IP"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    while IFS='|' read -r user pass exp limit_conn rest; do
        if id "$user" >/dev/null 2>&1; then
            exp_sec=$(date -d "$exp" +%s 2>/dev/null); now_sec=$(date +%s)
            dias=$(( (exp_sec - now_sec) / 86400 ))
            [[ $dias -lt 0 ]] && dias="EXP"
            printf "%-15s %-15s %-10s %-10s\n" "$user" "$pass" "$dias" "$limit_conn"
        fi
    done < "$DB_SSH"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Enter para salir..."
}

# --- VER DATOS INDIVIDUALES (SOLO SSH) ---
fun_ver_usuario_individual() {
    clear
    # Esto asegura que solo se listan usuarios de la base de datos SSH
    i=1
    declare -a ssh_list
    echo -e "${C_BARRA} SELECCIONE USUARIO SSH ${C_BARRA}"
    while IFS='|' read -r u p e l m; do
        echo -e " [$i] $u"
        ssh_list[$i]=$u
        let i++
    done < "$DB_SSH"
    
    echo -n " Numero: "; read opt
    USER_SEL=${ssh_list[$opt]}
    [[ -z "$USER_SEL" ]] && return

    datos=$(grep -w "^$USER_SEL" "$DB_SSH")
    IFS='|' read -r u p e l m <<< "$datos"
    clear
    echo -e " USUARIO: $u"
    echo -e " CLAVE:   $p"
    echo -e " VENCE:   $e"
    echo -e " LIMIT:   $l Conexiones"
    read -p " Enter..."
}

# --- MONITOR SSH (SIN COLUMNA MB) ---
fun_monitor_online() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MONITOR SSH ONLINE ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        printf "${C_TEXTO}%-20s %-20s${C_RESET}\n" "USUARIO" "CONEXIONES"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        if [[ -f "$DB_SSH" ]]; then
            while IFS='|' read -r user _ _ _ _; do
                if id "$user" >/dev/null 2>&1; then
                    conx=$(pgrep -u "$user" -f "sshd|dropbear" | wc -l)
                    if [[ "$conx" -gt 0 ]]; then
                        printf "%-20s ${C_VERDE}%-20s${C_RESET}\n" "$user" "ONLINE ($conx)"
                    else
                        printf "%-20s ${C_ROJO}%-20s${C_RESET}\n" "$user" "OFFLINE"
                    fi
                fi
            done < "$DB_SSH"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " [0] VOLVER"
        read -t 5 -n 1 key; [[ "$key" == "0" ]] && break
    done
}

# --- ELIMINAR SOLO SSH VENCIDOS ---
fun_eliminar_vencidos_ssh() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center " LIMPIANDO SSH VENCIDOS "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo " Analizando fechas..."
    
    # Crear archivo temporal
    touch "$DB_SSH.tmp"
    count=0
    
    if [[ -f "$DB_SSH" ]]; then
        while IFS='|' read -r user pass exp limit_conn limit_mb; do
            # Validar fecha
            if [[ ! -z "$exp" ]]; then
                today_sec=$(date +%s)
                exp_sec=$(date -d "$exp" +%s 2>/dev/null)
                
                # Si la fecha es valida y ya paso
                if [[ ! -z "$exp_sec" && $today_sec -ge $exp_sec ]]; then
                    echo -e "${C_ROJO} Eliminando: $user (Venci�: $exp)${C_RESET}"
                    userdel --force "$user" 2>/dev/null
                    rm -f "/etc/reagens/users/$user"
                    sed -i "/^$user|/d" "$DB_TRAFFIC"
                    ((count++))
                else
                    # Si no esta vencido, lo guardamos en el temporal
                    echo "$user|$pass|$exp|$limit_conn|$limit_mb" >> "$DB_SSH.tmp"
                fi
            fi
        done < "$DB_SSH"
    fi
    
    # Reemplazar DB original con la limpia
    mv "$DB_SSH.tmp" "$DB_SSH"
    
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_VERDE}Total eliminados: $count${C_RESET}"
    read -p " Enter para continuar..."
}

# --- BORRADO MASIVO SSH ---
fun_eliminar_todos_ssh() {
    clear
    echo -e "${C_ROJO}[!] ESTO BORRARA TODOS LOS USUARIOS SSH (NO TOKENS)${C_RESET}"
    read -p " Escribe 'SSH' para confirmar: " conf
    if [[ "$conf" == "SSH" ]]; then
        while IFS='|' read -r user _ ; do
            userdel --force "$user" 2>/dev/null
            rm -f "$DB_USERS/$user"
            sed -i "/^$user|/d" "$DB_TRAFFIC"
        done < "$DB_SSH"
        > "$DB_SSH"
        echo -e "${C_VERDE}Usuarios SSH eliminados.${C_RESET}"; sleep 2
    fi
}

# --- FIJAR CLAVE DEFAULT SSH ---
fun_clave_default() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center " FIJAR CLAVE DEFAULT SSH "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Nueva Clave: "
    read p
    if [[ ! -z "$p" ]]; then
        echo "$p" > "$FILE_PASS"
        echo -e "${C_VERDE} Clave guardada: $p${C_RESET}"
    fi
    sleep 2
}

# --- EDITAR USUARIO SSH ---
fun_editar_usuario() {
    clear
    seleccionar_usuario_ssh || return
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " EDITAR USUARIO: ${C_VERDE}$USER_SEL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] Cambiar Clave"
    echo -e " [2] Cambiar Limite de Conexiones"
    echo -e " [3] Cambiar/Sumar Dias de Duraci�n"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Opcion: "
    read op_edit
    
    datos=$(grep -w "^$USER_SEL" "$DB_SSH")
    IFS='|' read -r u p e l m <<< "$datos"

    case $op_edit in
        1)
            echo -n " Nueva Clave: "
            read p; echo "$USER_SEL:$p" | chpasswd
            ;;
        2)
            echo -n " Nuevo Limite Conexiones (0=Inf): "
            read l
            ;;
        3)
            echo -n " Dias a sumar (Ej: 30): "
            read d_sum
            e=$(date -d "$e + $d_sum days" +%Y-%m-%d)
            chage -E "$e" "$USER_SEL"
            ;;
        *) return ;;
    esac

    sed -i "/^$USER_SEL|/d" "$DB_SSH"
    echo "$u|$p|$e|$l|$m" >> "$DB_SSH"
    echo -e "${C_VERDE} Actualizado.${C_RESET}"; sleep 2
}

# [4] RENOVAR USUARIO
fun_renovar_usuario() {
    clear
    seleccionar_usuario_ssh || return
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " RECARGA ACUMULATIVA: ${C_VERDE}$USER_SEL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    # 1. Obtener datos actuales de la DB SSH
    datos=$(grep -w "^$USER_SEL" "$DB_SSH")
    IFS='|' read -r u p e l m_limit <<< "$datos"
    
    # 2. Obtener consumo actual de traffic.db
    consumo_bytes=$(grep -w "^$USER_SEL" "$DB_TRAFFIC" | cut -d'|' -f3)
    [[ -z "$consumo_bytes" ]] && consumo_bytes=0
    consumo_mb=$(echo "$consumo_bytes / 1048576" | bc)

    # 3. Calcular MB sobrantes (Suma al limite)
    sobrante_mb=$(echo "$m_limit - $consumo_mb" | bc)
    if (( $(echo "$sobrante_mb < 0" | bc -l) )); then sobrante_mb=0; fi
    
    # El paquete base de recarga es el mismo que tenia originalmente (m_limit)
    # Si quieres un paquete fijo de 50GB por ejemplo, cambia 'm_limit' por 51200
    paquete_base=$m_limit
    nuevo_limite_mb=$(echo "$paquete_base + $sobrante_mb" | bc)
    nuevo_limite_bytes=$(echo "$nuevo_limite_mb * 1048576" | bc)

    # 4. Calcular Dias sobrantes
    echo -n " Dias a sumar (Base 30): "
    read dias_sumar
    [[ -z "$dias_sumar" ]] && dias_sumar=30

    now_sec=$(date +%s)
    exp_sec=$(date -d "$e" +%s 2>/dev/null)
    
    if [[ -z "$exp_sec" || $now_sec -ge $exp_sec ]]; then
        # Vencido: Solo sumamos desde hoy
        nueva_fecha=$(date -d "+$dias_sumar days" +%Y-%m-%d)
    else
        # Vigente: Sumamos a lo que le quedaba
        nueva_fecha=$(date -d "$e + $dias_sumar days" +%Y-%m-%d)
    fi

    # 5. Aplicar cambios en Sistema y DBs
    chage -E "$nueva_fecha" "$USER_SEL"
    passwd -u "$USER_SEL" >/dev/null 2>&1
    pkill -u "$USER_SEL"
    iptables -Z FORWARD

    # Actualizar traffic.db (Reset a 0 usado)
    sed -i "/^$USER_SEL|/d" "$DB_TRAFFIC"
    echo "$USER_SEL|$nuevo_limite_bytes|0|1" >> "$DB_TRAFFIC"

    # Actualizar usuarios_ssh.db
    sed -i "/^$USER_SEL|/d" "$DB_SSH"
    echo "$u|$p|$nueva_fecha|$l|$nuevo_limite_mb" >> "$DB_SSH"

    echo -e "${C_VERDE} RECARGA EXITOSA!${C_RESET}"
    echo -e " Nuevo Limite: ${C_DATO}$nuevo_limite_mb MB${C_RESET} (Acumulado)"
    echo -e " Nueva Fecha : ${C_DATO}$nueva_fecha${C_RESET}"
    sleep 3
}

# [5] BLOQUEAR / DESBLOQUEAR
fun_bloqueo_usuario() {
    clear
    seleccionar_usuario_ssh || return
    # Verificar estado actual
    status=$(passwd -S "$USER_SEL" | awk '{print $2}')
    
    if [[ "$status" == "L" ]]; then
        echo -e " El usuario esta ${C_ROJO}BLOQUEADO${C_RESET}"
        echo -n " �Desbloquear? (s/n): "
        read op
        if [[ "$op" == "s" ]]; then
            passwd -u "$USER_SEL"
            echo -e "${C_VERDE} Usuario DESBLOQUEADO.${C_RESET}"
        fi
    else
        echo -e " El usuario esta ${C_VERDE}ACTIVO${C_RESET}"
        echo -n " �Bloquear? (s/n): "
        read op
        if [[ "$op" == "s" ]]; then
            passwd -l "$USER_SEL"
            pkill -u "$USER_SEL"
            echo -e "${C_ROJO} Usuario BLOQUEADO.${C_RESET}"
        fi
    fi
    sleep 2
}

# [11] CONFIGURAR BANNER
fun_banner() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CONFIGURAR BANNER SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Se abrir� el editor de texto."
    echo -e " Escribe tu mensaje HTML/Texto y guarda con: Ctrl+O, Enter, Ctrl+X"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    read -p " Presiona Enter para editar..."
    nano /etc/issue.net
    
    echo -e " Aplicando cambios..."
    service ssh restart >/dev/null 2>&1
    service dropbear restart >/dev/null 2>&1
    echo -e "${C_VERDE} Banner actualizado.${C_RESET}"
    sleep 2
}

# -------------------------------------

# --- MENU SSH ACTUALIZADO ---
menu_ssh() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION DE CUENTAS SSH / DROPBEAR ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]  > CREAR NUEVO USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[2]  > ELIMINAR USUARIO${C_RESET}"  
        echo -e " ${C_TEXTO}[3]  > EDITAR USUARIO (Sumar Dias)${C_RESET}" # <-- Llama a fun_editar_usuario
        echo -e " ${C_TEXTO}[4]  > RENOVAR USUARIO (Acumulativo)${C_RESET}"  # <-- Llama a fun_renovar_usuario
        echo -e " ${C_TEXTO}[5]  > BLOQUEAR / DESBLOQUEAR (Lista)${C_RESET}" # <-- Llama a fun_bloqueo_usuario
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[6]  > LISTA GENERAL SSH (SOLO SSH)${C_RESET}"
        echo -e " ${C_DATO}[7]  > VER DATOS DE 1 USUARIO (Detalle)${C_RESET}"
        echo -e " ${C_TEXTO}[8]  > MONITOR ONLINE (Salir con 0)${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[9]  > ELIMINAR SSH VENCIDOS${C_RESET}"
        echo -e " ${C_ROJO}[10] > ELIMINAR TODOS LOS SSH${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[11] > CONFIGURAR BANNER SSH${C_RESET}"
        echo -e " ${C_DATO}[12] > FIJAR CLAVE DEFAULT SSH${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0)    VOLVER AL MENU ANTERIOR${C_RESET}"
        echo -n " Opcion: "
        read op_ssh
        case $op_ssh in 
            1) fun_crear_usuario ;; 
            2) fun_eliminar_usuario ;;       # Verifica que tengas esta funcion
            3) fun_editar_usuario ;;         # Esta es la NUEVA que te di (Suma MB/Dias)
            4) fun_renovar_usuario ;;        # Esta es la NUEVA (Acumulativa)
            5) fun_bloqueo_usuario ;;        # Esta es la NUEVA (Con lista)
            6) fun_detalles_usuarios ;; 
            7) fun_ver_usuario_individual ;; 
            8) fun_monitor_online ;; 
            9) fun_eliminar_vencidos_ssh ;;  # Asegurate de haber pegado esta del paso anterior
            10) fun_eliminar_todos_ssh ;;    # Asegurate de haber pegado esta del paso anterior
            11) fun_banner ;; 
            12) fun_clave_default ;; 
            0) break ;; 
        esac
    done
}

# ==================================================
# BLOQUE GESTION TOKENS (DISE�O CLASICO + LOGICA FIX)
# ==================================================

# Aseguramos variables clave
DB_TOKENS="/etc/adm-lite/usuarios_token.db"
TOKEN_PASS_FILE="/etc/reagens_base_pass"

# 1. FUNCION DE CONTRASE�A (CRITICA)
check_base_pass() {
    if [ ! -f "$TOKEN_PASS_FILE" ]; then
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e "${C_DATO} �CONFIGURACION INICIAL TOKEN ID!${C_RESET}"
        echo -e " Esta App usa una clave fija interna para todos."
        echo -e " Necesito saber cu�l es esa clave."
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        read -p " Introduce la CLAVE BASE de la APK: " BASE_PASS
        if [[ -z "$BASE_PASS" ]]; then echo "Error: vacio"; return; fi
        echo "$BASE_PASS" > "$TOKEN_PASS_FILE"
        echo -e "${C_VERDE}Clave guardada.${C_RESET}"; sleep 2
    fi
}

change_base_pass() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e "${C_ROJO} CUIDADO: Esto afectar� a los nuevos usuarios.${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Nueva clave base de la APK: " NUEVA_PASS
    if [[ -z "$NUEVA_PASS" ]]; then echo "Cancelado"; sleep 1; return; fi
    echo "$NUEVA_PASS" > "$TOKEN_PASS_FILE"
    echo -e "${C_VERDE}clave actualizada.${C_RESET}"; sleep 2
}

# 2. SELECTOR DE USUARIO (SOLUCION DEL PROBLEMA)
# Esta funcion lee tu base de datos y permite elegir sin fallar
seleccionar_usuario_token() {
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SELECCIONAR TOKEN (APP) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    i=1
    declare -a users_array
    
    # Leemos la DB linea por linea para no perder ninguno
    if [[ -f "$DB_TOKENS" ]]; then
        while IFS='|' read -r user cliente rest; do
            if id "$user" >/dev/null 2>&1; then
                echo -e " [${C_DATO}$i${C_RESET}] $user | ${C_TEXTO}$cliente${C_RESET}"
                users_array[$i]=$user
                let i++
            fi
        done < "$DB_TOKENS"
    fi

    if [[ $i -eq 1 ]]; then 
        echo -e " ${C_ROJO}No hay tokens creados.${C_RESET}"
        return 1
    fi
    
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Seleccione numero: "
    read opt_user
    USER_SEL=${users_array[$opt_user]}
    
    if [[ -z "$USER_SEL" ]]; then 
        echo -e " ${C_ROJO}Opcion invalida.${C_RESET}"
        return 1
    fi
    return 0
}

# --- CREAR TOKEN (SIN MB) ---
crear_token() {
    clear
    check_base_pass
    BASE_PASS=$(cat "$TOKEN_PASS_FILE")
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center " CREAR TOKEN ID (APP) "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Nombre Cliente: "; read c
    echo -n " Token ID: "; read u
    [[ -z "$u" ]] && return
    if id "$u" >/dev/null 2>&1; then echo -e "${C_ROJO}Existe.${C_RESET}"; sleep 2; return; fi
    
    echo -n " Dias de duracion: "; read d
    fd=$(date -d "+$d days" +%Y-%m-%d)
    useradd -M -s /usr/local/bin/reagens-shell "$u"
    echo "$u:$BASE_PASS" | chpasswd
    chage -E "$fd" "$u"
    
    add_traffic_user "$u" "0"
    echo "$u|$c|$fd|0" >> "$DB_TOKENS"
    echo -e "\n ${C_VERDE}Token $u creado por $d dias.${C_RESET}"
    sleep 2
}

# --- ELIMINAR SSH (REPARADO) ---
fun_eliminar_usuario() { 
    clear
    seleccionar_usuario_ssh || return
    iptables -D OUTPUT -m owner --uid-owner "$USER_SEL" -j ACCEPT > /dev/null 2>&1
    fun_save_iptables
    userdel --force "$USER_SEL"
    rm -f "$DB_USERS/$USER_SEL"
    sed -i "/^$USER_SEL|/d" "$DB_TRAFFIC"
    sed -i "/^$USER_SEL|/d" "$DB_SSH"
    echo -e "${C_VERDE} Eliminado.${C_RESET}"
    sleep 2
}

# --- ELIMINAR TOKEN (REPARADO) ---
eliminar_token_func() {
    clear
    seleccionar_usuario_token || return
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ELIMINAR TOKEN: ${C_ROJO}$USER_SEL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Confirmar borrado (s/n): "
    read op
    if [[ "$op" == "s" ]]; then
        iptables -D OUTPUT -m owner --uid-owner "$USER_SEL" -j ACCEPT > /dev/null 2>&1
        fun_save_iptables
        userdel --force "$USER_SEL"
        rm -f "$DB_USERS/$USER_SEL"
        sed -i "/^$USER_SEL|/d" "$DB_TRAFFIC"
        sed -i "/^$USER_SEL|/d" "$DB_TOKENS"
        echo -e "${C_VERDE} Eliminado correctamente.${C_RESET}"
        sleep 2
    fi
}

# --- EDITAR TOKEN ---
editar_token_func() {
    clear
    seleccionar_usuario_token || return
    datos=$(grep -w "^$USER_SEL" "$DB_TOKENS")
    IFS='|' read -r u cliente exp limit_mb <<< "$datos"
    
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " EDITAR: ${C_VERDE}$USER_SEL${C_RESET} ($cliente)"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] Renovar/Sumar Dias"
    echo -e " [2] Cambiar Nombre Cliente"
    echo -e " [3] Cambiar Limite de Conexiones"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Opcion: "
    read op_edit

    case $op_edit in
        1)
            echo -n " Dias a sumar: "; read dias
            exp=$(date -d "$exp + $dias days" +%Y-%m-%d)
            chage -E "$exp" "$USER_SEL"
            ;;
        2)
            echo -n " Nuevo Nombre: "; read cliente
            usermod -c "$cliente" "$USER_SEL"
            ;;
        3)
            echo -e "${C_DATO}Nota: Los Tokens suelen ser de 1 conexi�n.${C_RESET}"
            # Aqu� podr�as agregar l�gica si usas un monitor para tokens
            ;;
    esac
    
    sed -i "/^$USER_SEL|/d" "$DB_TOKENS"
    echo "$u|$cliente|$exp|$limit_mb" >> "$DB_TOKENS"
    echo -e "${C_VERDE} Token Actualizado.${C_RESET}"; sleep 2
}

# 6. BLOQUEAR TOKEN (LOGICA REPARADA)
bloqueo_token_func() {
    clear
    seleccionar_usuario_token || return
    status=$(passwd -S "$USER_SEL" | awk '{print $2}')
    
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    if [[ "$status" == "L" ]]; then
        echo -e " Estado: ${C_ROJO}BLOQUEADO${C_RESET}"
        echo -n " �Desbloquear? (s/n): "; read op
        if [[ "$op" == "s" ]]; then
            passwd -u "$USER_SEL"
            echo -e "${C_VERDE} Token Activado.${C_RESET}"
        fi
    else
        echo -e " Estado: ${C_VERDE}ACTIVO${C_RESET}"
        echo -n " �Bloquear? (s/n): "; read op
        if [[ "$op" == "s" ]]; then
            passwd -l "$USER_SEL"
            pkill -u "$USER_SEL"
            echo -e "${C_ROJO} Token Bloqueado.${C_RESET}"
        fi
    fi
    sleep 2
}

# --- LISTA DE TOKENS (LIMPIA) ---
listar_tokens() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LISTA DE TOKENS APP ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    printf "${C_TEXTO}%-15s %-20s %-10s${C_RESET}\n" "TOKEN ID" "CLIENTE" "DIAS"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    
    if [[ -f "$DB_TOKENS" ]]; then
        while IFS='|' read -r user cliente exp rest; do
            if id "$user" >/dev/null 2>&1; then
                exp_sec=$(date -d "$exp" +%s); now_sec=$(date +%s)
                dias=$(( (exp_sec - now_sec) / 86400 ))
                [[ $dias -lt 0 ]] && dias="EXP"
                printf "%-15s %-20s %-10s\n" "${user:0:14}" "${cliente:0:19}" "$dias"
            fi
        done < "$DB_TOKENS"
    else
        echo " No hay tokens."
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Enter para volver..."
}

fun_monitor_tokens() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MONITOR TOKENS: ESTADO Y VENCIMIENTO ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        printf "${C_TEXTO}%-18s %-15s %-10s${C_RESET}\n" "TOKEN ID" "ESTADO" "DIAS"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        
        if [[ -f "$DB_TOKENS" ]]; then
            while IFS='|' read -r user cliente exp rest; do
                if id "$user" >/dev/null 2>&1; then
                    # Verificar si est� online
                    conx=$(pgrep -u "$user" -f "sshd|dropbear" | wc -l)
                    # Calcular dias
                    exp_sec=$(date -d "$exp" +%s 2>/dev/null); now_sec=$(date +%s)
                    dias=$(( (exp_sec - now_sec) / 86400 ))
                    [[ $dias -lt 0 ]] && dias="EXP"

                    if [[ "$conx" -gt 0 ]]; then
                        printf "%-18s ${C_VERDE}%-15s${C_RESET} ${C_DATO}%-10s${C_RESET}\n" "$user" "ONLINE ($conx)" "$dias"
                    else
                        printf "%-18s ${C_ROJO}%-15s${C_RESET} ${C_DATO}%-10s${C_RESET}\n" "$user" "OFFLINE" "$dias"
                    fi
                fi
            done < "$DB_TOKENS"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " [0] VOLVER"
        read -t 5 -n 1 key; [[ "$key" == "0" ]] && break
    done
}

# --- BORRADO MASIVO TOKENS ---
fun_eliminar_todos_token() {
    clear
    echo -e "${C_ROJO}[!] ESTO BORRARA TODOS LOS TOKENS APP (NO SSH)${C_RESET}"
    read -p " Escribe 'TOKEN' para confirmar: " conf
    if [[ "$conf" == "TOKEN" ]]; then
        while IFS='|' read -r user _ ; do
            userdel --force "$user" 2>/dev/null
            rm -f "$DB_USERS/$user"
            sed -i "/^$user|/d" "$DB_TRAFFIC"
        done < "$DB_TOKENS"
        > "$DB_TOKENS"
        echo -e "${C_VERDE}Tokens eliminados.${C_RESET}"; sleep 2
    fi
}

# 8. MENU PRINCIPAL TOKENS (DISE�O RESTAURADO)
menu_tokens() {
    while true; do
        clear
        check_base_pass
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION TOKENS (APP ID) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]   > CREAR TOKEN ${C_RESET}"
        echo -e " ${C_TEXTO}[2]   > ELIMINAR TOKEN${C_RESET}"
        echo -e " ${C_TEXTO}[3]   > EDITAR TOKEN ${C_RESET}"
        echo -e " ${C_TEXTO}[4]   > BLOQUEAR / DESBLOQUEAR${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[5]   > VER LISTA ${C_RESET}"
        echo -e " ${C_TEXTO}[6]   > MONITOR ONLINE${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[7]   > ELIMINAR TOKENS VENCIDOS${C_RESET}"
        echo -e " ${C_ROJO}[8]   > ELIMINAR TODOS LOS TOKENS${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[9]   > CAMBIAR CLAVE BASE (APP)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "; read op
        case $op in
            1) crear_token ;;
            2) eliminar_token_func ;; 
            3) editar_token_func ;; 
            4) bloqueo_token_func ;;
            5) listar_tokens ;;
            6) fun_monitor_tokens ;;
            7) fun_eliminar_vencidos_token ;;
            8) fun_eliminar_todos_token ;;
            9) change_base_pass ;; 
            0) break ;;
        esac
    done
}

# ==================================================
# BLOQUE GESTION XRAY/V2RAY (INTEGRADO XRAY CORE)
# ==================================================
get_v2_data() {
    if [[ ! -f "$V2RAY_CONF" ]]; then V2_PORT="Error"; return; fi
    # Detectar configuracion
    V2_PORT=$(jq -r '.inbounds[0].port' "$V2RAY_CONF" 2>/dev/null)
    V2_PROTO=$(jq -r '.inbounds[0].protocol' "$V2RAY_CONF" 2>/dev/null)
    if [[ -z "$V2_PORT" || "$V2_PORT" == "null" ]]; then V2_PORT="Error"; fi
}

seleccionar_usuario_v2() {
    echo -e "${C_BARRA} SELECCIONAR USUARIO XRAY ${C_BARRA}"
    if [[ ! -f "$V2RAY_CONF" ]]; then 
        echo -e " ${C_ROJO}No instalado${C_RESET}"
        return 1
    fi
    i=1
    declare -a v2_users
    # Xray users are in .clients[] with 'email' or 'id'
    clients=$(jq -r '.inbounds[0].settings.clients[] | .email // .id' "$V2RAY_CONF")
    if [[ -z "$clients" ]]; then 
        echo -e " ${C_ROJO}Vacio${C_RESET}"
        return 1
    fi
    for c in $clients; do 
        echo -e " [${C_DATO}$i${C_RESET}] $c"
        v2_users[$i]=$c
        let i++
    done
    echo -n " Numero: "
    read opt_v
    USER_V2=${v2_users[$opt_v]}
    if [[ -z "$USER_V2" ]]; then 
        echo "Error"
        return 1
    fi
    return 0
}

# --- FUNCION DE LECTURA INTELIGENTE XRAY ---
cargar_datos_xray() {
    CONF="/usr/local/etc/xray/config.json"
    if [[ ! -f "$CONF" ]]; then echo "Error: No config.json"; return 1; fi

    # 1. Extraer Protocolo y Puerto
    X_PORT=$(jq -r '.inbounds[0].port' "$CONF")
    X_PROTO=$(jq -r '.inbounds[0].protocol' "$CONF")
    
    # 2. Extraer Transporte (ws, tcp, etc)
    X_NET=$(jq -r '.inbounds[0].streamSettings.network // "tcp"' "$CONF")
    
    # 3. Extraer Seguridad (tls, none)
    X_SEC=$(jq -r '.inbounds[0].streamSettings.security // "none"' "$CONF")
    
    # 4. Extraer Path y Host (Solo si es WS)
    X_PATH=$(jq -r '.inbounds[0].streamSettings.wsSettings.path // "/"' "$CONF")
    X_HOST=$(jq -r '.inbounds[0].streamSettings.wsSettings.headers.Host // ""' "$CONF")
    
    # 5. IP Publica
    X_IP=$(curl -s ipv4.icanhazip.com)
}

# FUNCION: CREAR USUARIO V2RAY (AUTO DUAL)
crear_usuario_v2ray() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CREAR USUARIO XRAY / V2RAY ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    # 1. Validaci�n de nombre
    echo -n " Nombre del Usuario (Solo letras/n�meros): "; read user
    [[ -z "$user" ]] && return
    user=$(echo "$user" | sed 's/[^a-zA-Z0-9]//g') # Limpieza de caracteres
    
    if grep -q "\"email\": \"$user\"" "$V2RAY_CONF"; then
        echo -e "${C_ROJO}[!] El usuario ya existe en el sistema.${C_RESET}"; sleep 2; return
    fi

    # 2. Duraci�n
    echo -n " Dias de Duraci�n: "; read dias
    [[ -z "$dias" ]] && dias=30
    
    # 3. Selecci�n de UUID (Clave de acceso)
    echo -e "\n [1] Generar UUID Autom�tico"
    echo -e " [2] Ingresar UUID Manual (Clave personalizada)"
    echo -n " Opcion: "; read op_u
    if [[ "$op_u" == "2" ]]; then
        echo -n " Ingrese Clave/UUID: "; read uuid
    else
        uuid=$(uuidgen)
    fi
    [[ -z "$uuid" ]] && uuid=$(uuidgen)

    # --- INICIO DE INYECCI�N REAL EN CONFIG.JSON ---
    echo -e " ${C_DATO}[+] Registrando en el n�cleo Xray...${C_RESET}"
    
    # Detectamos cu�ntos servicios (inbounds) hay para meter al usuario en todos
    total_inbounds=$(jq '.inbounds | length' "$V2RAY_CONF")
    
    for ((i=0; i<$total_inbounds; i++)); do
        PROTO=$(jq -r ".inbounds[$i].protocol" "$V2RAY_CONF")
        
        # Si es Trojan usa 'password', si es Vmess/Vless usa 'id'
        if [[ "$PROTO" == "trojan" ]]; then
            jq --arg u "$uuid" --arg e "$user" \
            ".inbounds[$i].settings.clients += [{\"password\": \$u, \"email\": \$e}]" \
            "$V2RAY_CONF" > "$V2RAY_CONF.tmp" && mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"
        else
            jq --arg u "$uuid" --arg e "$user" \
            ".inbounds[$i].settings.clients += [{\"id\": \$u, \"email\": \$e}]" \
            "$V2RAY_CONF" > "$V2RAY_CONF.tmp" && mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"
        fi
    done
    # --- FIN DE INYECCI�N ---

    # Guardar Metadata para el Panel y Control
    final_date=$(date -d "+$dias days" +%Y-%m-%d)
    mkdir -p "$DB_USERS/v2ray"
    echo "EXP=$final_date" > "$DB_USERS/v2ray/$user"
    echo "UUID=$uuid" >> "$DB_USERS/v2ray/$user"
    echo "DURATION=$dias" >> "$DB_USERS/v2ray/$user"
    
    systemctl restart xray
    echo -e "${C_VERDE} [OK] Usuario $user Creado con �xito.${C_RESET}"
    echo -e " UUID/Clave: ${C_DATO}$uuid${C_RESET}"
    sleep 3
}

# FUNCION: VER DETALLES Y QR (DUAL)
detalles_usuario_v2ray() {
    clear
    seleccionar_usuario_v2 || return 
    CONF="/usr/local/etc/xray/config.json"
    IP=$(curl -s ipv4.icanhazip.com)
    
    # Extraer UUID del usuario seleccionado
    UUID_FINAL=$(jq -r --arg u "$USER_V2" '.inbounds[0].settings.clients[] | select(.email == $u) | .id // .password' "$CONF")
    days=$(get_v2_days "$USER_V2")
    
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LINKS Y QR DE CONEXION ($USER_V2) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " UUID: ${C_DATO}$UUID_FINAL${C_RESET}"
    echo -e " DIAS: ${C_VERDE}$days${C_RESET}"
    
    # Iterar sobre todos los inbounds (puertos) configurados
    total_inbounds=$(jq '.inbounds | length' "$CONF")
    
    for ((i=0; i<$total_inbounds; i++)); do
        # --- LECTURA DE CONFIGURACION DETALLADA ---
        P_PORT=$(jq -r ".inbounds[$i].port" "$CONF")
        P_PROTO=$(jq -r ".inbounds[$i].protocol" "$CONF")
        S_SET=".inbounds[$i].streamSettings"
        P_NET=$(jq -r "$S_SET.network" "$CONF")
        P_SEC=$(jq -r "$S_SET.security" "$CONF")
        
        # Variables por defecto para evitar residuos de bucles anteriores
        P_PATH=""; P_HOST=""; P_SERV=""; P_TYPE="none"; P_FLOW=""; P_SNI=""; P_FP=""; P_PBK=""; P_SID=""
        
        # DETECCION AVANZADA DE TRANSPORTE (TU LOGICA ORIGINAL)
        case $P_NET in
            "ws")
                P_PATH=$(jq -r "$S_SET.wsSettings.path // \"/\"" "$CONF")
                P_HOST=$(jq -r "$S_SET.wsSettings.headers.Host // \"\"" "$CONF")
                P_SNI=$P_HOST
                ;;
            "grpc")
                P_SERV=$(jq -r "$S_SET.grpcSettings.serviceName // \"\"" "$CONF")
                P_TYPE="grpc"
                P_SNI=$(jq -r "$S_SET.tlsSettings.serverName // \"\"" "$CONF")
                ;;
            "httpupgrade")
                P_PATH=$(jq -r "$S_SET.httpupgradeSettings.path // \"/\"" "$CONF")
                P_TYPE="httpupgrade"
                ;;
            "kcp")
                P_TYPE=$(jq -r "$S_SET.kcpSettings.header.type // \"none\"" "$CONF")
                P_PATH=$(jq -r "$S_SET.kcpSettings.seed // \"\"" "$CONF")
                ;;
            "tcp")
                P_TYPE="none"
                if [[ "$P_SEC" == "reality" ]]; then
                    P_SNI=$(jq -r "$S_SET.realitySettings.serverNames[0]" "$CONF")
                    P_PBK=$(cat /etc/reagens/reality_pub 2>/dev/null)
                    P_SID=$(jq -r "$S_SET.realitySettings.shortIds[0]" "$CONF")
                    P_FP=$(jq -r "$S_SET.realitySettings.fingerprint // \"chrome\"" "$CONF")
                    P_FLOW="xtls-rprx-vision"
                fi
                ;;
        esac

        # SNI para TLS estandar
        if [[ "$P_SEC" == "tls" && -z "$P_SNI" ]]; then
            P_SNI=$(jq -r "$S_SET.tlsSettings.serverName // \"\"" "$CONF")
        fi

        NAME="$USER_V2-$P_PROTO-$P_NET"
        LINK=""

        # --- GENERACION DE LINKS (VMESS, VLESS, TROJAN) ---
        if [[ "$P_PROTO" == "vmess" ]]; then
            VMESS_JSON="{\"v\":\"2\",\"ps\":\"$NAME\",\"add\":\"$IP\",\"port\":\"$P_PORT\",\"id\":\"$UUID_FINAL\",\"aid\":\"0\",\"scy\":\"auto\",\"net\":\"$P_NET\",\"type\":\"$P_TYPE\",\"tls\":\"$P_SEC\",\"sni\":\"$P_SNI\",\"path\":\"$P_PATH\",\"host\":\"$P_HOST\"}"
            LINK="vmess://$(echo -n "$VMESS_JSON" | base64 -w 0)"

        elif [[ "$P_PROTO" == "vless" ]]; then
            LINK="vless://$UUID_FINAL@$IP:$P_PORT?security=$P_SEC&type=$P_NET"
            [[ "$P_SEC" == "reality" ]] && LINK+="&sni=$P_SNI&pbk=$P_PBK&sid=$P_SID&fp=$P_FP&flow=$P_FLOW"
            [[ "$P_SEC" == "tls" && ! -z "$P_SNI" ]] && LINK+="&sni=$P_SNI"
            [[ "$P_NET" == "ws" ]] && LINK+="&path=$(urlencode $P_PATH)&host=$P_HOST"
            [[ "$P_NET" == "grpc" ]] && LINK+="&serviceName=$P_SERV&mode=multi"
            [[ "$P_NET" == "httpupgrade" ]] && LINK+="&path=$(urlencode $P_PATH)"
            [[ "$P_NET" == "kcp" ]] && LINK+="&headerType=$P_TYPE&seed=$P_PATH"
            LINK+="#$NAME"

        elif [[ "$P_PROTO" == "trojan" ]]; then
            LINK="trojan://$UUID_FINAL@$IP:$P_PORT?security=$P_SEC&type=$P_NET"
            [[ "$P_SEC" == "tls" && ! -z "$P_SNI" ]] && LINK+="&sni=$P_SNI"
            [[ "$P_NET" == "ws" ]] && LINK+="&path=$(urlencode $P_PATH)&host=$P_HOST"
            [[ "$P_NET" == "grpc" ]] && LINK+="&serviceName=$P_SERV&mode=multi"
            LINK+="#$NAME"
        fi

        # --- SALIDA VISUAL (LINK + QR POR CADA PUERTO) ---
        if [[ ! -z "$LINK" ]]; then
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_DATO}OPCI�N #$((i+1)): ${C_VERDE}${P_PROTO^^} + ${P_NET^^} (${P_SEC^^})${C_RESET}"
            echo -e " ${C_TEXTO}$LINK${C_RESET}"
            echo ""
            if command -v qrencode &> /dev/null; then
                qrencode -t ANSIUTF8 "$LINK"
            fi
            echo ""
        fi
    done
    
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Presione Enter para volver..."
}

# AUXILIAR PARA URL ENCODE (Necesario para rutas con /)
urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * )               printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}

eliminar_usuario_v2ray() { 
    clear
    seleccionar_usuario_v2 || return
    jq --arg e "$USER_V2" 'del(.inbounds[0].settings.clients[] | select(.email == $e))' "$V2RAY_CONF" > "$V2RAY_CONF.tmp"
    mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"
    rm -f "$DB_USERS/v2ray/$USER_V2"
    systemctl restart xray
    echo "Borrado."
    sleep 2
}

editar_usuario_v2ray() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} EDITAR USUARIO XRAY / V2RAY ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    # 1. Seleccionar usuario
    seleccionar_usuario_v2 || return
    meta_file="$DB_USERS/v2ray/$USER_V2"
    
    # 2. Cargar datos actuales
    if [[ -f "$meta_file" ]]; then
        source "$meta_file"
    fi

    echo -e " USUARIO: ${C_VERDE}$USER_V2${C_RESET}"
    echo -e " UUID ACTUAL: ${C_DATO}${UUID:-Desconocido}${C_RESET}"
    echo -e " VENCE: ${C_DATO}${EXP:----}${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_TEXTO}[1] > Cambiar UUID / Clave (Manual)${C_RESET}"
    echo -e " ${C_TEXTO}[2] > Cambiar Dias de Duracion (Desde hoy)${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
    echo -n " Opcion: "
    read op_edit_v2

    case $op_edit_v2 in
        1)
            echo -ne "\n Ingrese el NUEVO UUID/Clave: "
            read new_uuid
            [[ -z "$new_uuid" ]] && return

            echo -e " ${C_DATO}[+] Actualizando nucleo Xray...${C_RESET}"
            # Actualizar en config.json (id para vmess/vless, password para trojan)
            total_inb=$(jq '.inbounds | length' "$V2RAY_CONF")
            for ((i=0; i<$total_inb; i++)); do
                proto=$(jq -r ".inbounds[$i].protocol" "$V2RAY_CONF")
                if [[ "$proto" == "trojan" ]]; then
                    jq --arg e "$USER_V2" --arg u "$new_uuid" \
                    '(.inbounds['$i'].settings.clients[] | select(.email == $e) | .password) = $u' \
                    "$V2RAY_CONF" > "$V2RAY_CONF.tmp" && mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"
                else
                    jq --arg e "$USER_V2" --arg u "$new_uuid" \
                    '(.inbounds['$i'].settings.clients[] | select(.email == $e) | .id) = $u' \
                    "$V2RAY_CONF" > "$V2RAY_CONF.tmp" && mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"
                fi
            done

            # Actualizar metadata
            sed -i "/UUID=/d" "$meta_file"
            echo "UUID=$new_uuid" >> "$meta_file"
            echo -e "${C_VERDE} UUID actualizado exitosamente.${C_RESET}"
            ;;
            
        2)
            echo -ne "\n Nuevos dias de duracion (Ej: 30): "
            read d
            if [[ "$d" =~ ^[0-9]+$ ]]; then
               fd=$(date -d "+$d days" +%Y-%m-%d)
               sed -i "/EXP=/d" "$meta_file"
               echo "EXP=$fd" >> "$meta_file"
               sed -i "/DURATION=/d" "$meta_file"
               echo "DURATION=$d" >> "$meta_file"
               echo -e "${C_VERDE} Nueva fecha: $fd (+$d dias desde hoy).${C_RESET}"
            else
               echo -e "${C_ROJO}Cantidad invalida.${C_RESET}"
            fi
            ;;
        *) return ;;
    esac

    # Reiniciar servicio para aplicar cambios
    systemctl restart xray
    sleep 2
}

seleccionar_usuario_v2() {
    # Verificar si el archivo existe antes de intentar leerlo
    if [[ ! -f "$V2RAY_CONF" ]]; then
        echo -e "${C_ROJO}[X] Error: No se encuentra config.json en $V2RAY_CONF${C_RESET}"
        sleep 2
        return 1
    fi

    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SELECCIONAR USUARIO XRAY ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    i=1
    declare -a v2_users
    # Extraer correos de usuarios (email) de todos los inbounds y eliminar duplicados
    clients=$(jq -r '.inbounds[].settings.clients[] | .email' "$V2RAY_CONF" 2>/dev/null | sort -u)
    
    if [[ -z "$clients" ]]; then 
        echo -e " ${C_ROJO}No hay usuarios registrados.${C_RESET}"
        sleep 2
        return 1
    fi

    for c in $clients; do 
        echo -e " [${C_DATO}$i${C_RESET}] $c"
        v2_users[$i]=$c
        let i++
    done
    
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Seleccione un numero: "
    read opt_v
    
    USER_V2=${v2_users[$opt_v]}
    
    if [[ -z "$USER_V2" ]]; then 
        echo -e "${C_ROJO}[!] Seleccion invalida.${C_RESET}"
        sleep 1
        return 1
    fi
    return 0
}

renovar_usuario_v2ray() {
    clear
    seleccionar_usuario_v2 || return
    meta_file="$DB_USERS/v2ray/$USER_V2"
    source "$meta_file"
    if [[ -z "$DURATION" ]]; then
        echo -n " Ingrese dias a renovar (Ej: 30): "
        read DURATION
        echo "DURATION=$DURATION" >> "$meta_file"
    fi
    today_sec=$(date +%s)
    if [[ -z "$EXP" ]]; then 
        base_sec=$today_sec
    else
        exp_sec=$(date -d "$EXP" +%s)
        if [[ $today_sec -gt $exp_sec ]]; then 
            base_sec=$today_sec
        else 
            base_sec=$exp_sec
        fi
    fi
    base_date_str=$(date -d "@$base_sec" +%Y-%m-%d)
    final_date=$(date -d "$base_date_str + $DURATION days" +%Y-%m-%d)
    sed -i "/EXP=/d" "$meta_file"
    echo "EXP=$final_date" >> "$meta_file"
    echo -e "${C_VERDE}Renovado (+$DURATION dias).${C_RESET}"
    echo -e " Nuevo Vencimiento: $final_date"
    sleep 3
}

# --- NUEVA FUNCI�N: CAMBIAR PUERTO XRAY (SOPORTE DUAL) ---
cambiar_puerto_v2ray() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CAMBIAR PUERTO XRAY (MODO DUAL) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if [[ ! -f "$V2RAY_CONF" ]]; then
        echo -e " ${C_ROJO}[X] Error: Configuraci�n no encontrada.${C_RESET}"
        sleep 2; return
    fi

    # 1. Detectar cu�ntos inbounds (servicios) hay
    NUM_INB=$(jq '.inbounds | length' "$V2RAY_CONF")
    INDEX=0

    if [[ "$NUM_INB" -gt 1 ]]; then
        echo -e " Se detectaron ${C_VERDE}$NUM_INB${C_RESET} servicios configurados:"
        for ((i=0; i<NUM_INB; i++)); do
            P=$(jq -r ".inbounds[$i].port" "$V2RAY_CONF")
            PR=$(jq -r ".inbounds[$i].protocol" "$V2RAY_CONF")
            echo -e " [ $((i+1)) ] -> Puerto: ${C_DATO}$P${C_RESET} | Protocolo: ${C_DATO}$PR${C_RESET}"
        done
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -n " �Cu�l puerto desea cambiar? (1 o 2): "
        read OP_SEL
        
        # Validar selecci�n
        if [[ "$OP_SEL" == "1" ]]; then INDEX=0; elif [[ "$OP_SEL" == "2" ]]; then INDEX=1; else
            echo -e "${C_ROJO}[!] Opci�n inv�lida.${C_RESET}"; sleep 2; return
        fi
    fi

    # 2. Obtener datos del puerto seleccionado
    OLD_PORT=$(jq -r ".inbounds[$INDEX].port" "$V2RAY_CONF")
    PROTO_SEL=$(jq -r ".inbounds[$INDEX].protocol" "$V2RAY_CONF")
    
    echo -e "\n Modificando servicio: ${C_VERDE}$PROTO_SEL${C_RESET} (Actual: $OLD_PORT)"
    echo -n " Ingrese el NUEVO Puerto: "
    read NEW_PORT
    
    if [[ -z "$NEW_PORT" || ! "$NEW_PORT" =~ ^[0-9]+$ ]]; then
        echo -e "${C_ROJO}[!] Puerto inv�lido.${C_RESET}"; sleep 2; return
    fi

    # Verificar si el puerto nuevo est� ocupado
    fun_check_port $NEW_PORT "Xray Dual Fix" || return

    # 3. Aplicar cambio con JQ usando el �ndice seleccionado
    echo -e " ${C_DATO}[+] Actualizando JSON en la posici�n $INDEX...${C_RESET}"
    jq --argjson idx "$INDEX" --argjson p "$NEW_PORT" '.inbounds[$idx].port = $p' "$V2RAY_CONF" > "$V2RAY_CONF.tmp" && mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"

    # 4. Actualizar Firewall
    echo -e " ${C_DATO}[+] Ajustando IPTables...${C_RESET}"
    iptables -D INPUT -p tcp --dport $OLD_PORT -j ACCEPT 2>/dev/null
    iptables -I INPUT -p tcp --dport $NEW_PORT -j ACCEPT
    fun_save_iptables >/dev/null 2>&1

    # 5. Reiniciar
    systemctl restart xray
    
    echo -e "${C_VERDE} [OK] Puerto actualizado exitosamente a: $NEW_PORT${C_RESET}"
    sleep 3
}



menu_v2ray() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION DE CUENTAS XRAY / V2RAY ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        get_v2_data
        if [[ "$V2_PORT" == "Error" ]]; then 
            echo -e " ESTADO: ${C_ROJO}NO INSTALADO${C_RESET}"
        else 
            echo -e " ${C_DATO}PROTO: $V2_PROTO | PUERTO: $V2_PORT${C_RESET}"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]  > INSTALAR / RECONFIGURAR (TLS/WS)${C_RESET}"
        echo -e " ${C_TEXTO}[2]  > INSTALAR VLESS REALITY (SIN DOMINIO)${C_RESET}"
        echo -e " ${C_VERDE}[3]  > CAMBIAR PUERTO DEL SERVICIO${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[4]  > CREAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[5]  > ELIMINAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[6]  > EDITAR USUARIO (Dias/UUID)${C_RESET}"
        echo -e " ${C_TEXTO}[7]  > RENOVAR USUARIO${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[8]  > DETALLES QR / LINK DE USUARIO${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0)   VOLVER AL MENU ANTERIOR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Seleccione una opcion: "
        read op_v2
        case $op_v2 in 
            1) proto_v2ray_manager ;; 
            2) install_xray_reality ;;
            3) cambiar_puerto_v2ray ;;
            4) crear_usuario_v2ray ;; 
            5) eliminar_usuario_v2ray ;; 
            6) editar_usuario_v2ray ;; 
            7) renovar_usuario_v2ray ;; 
            8) detalles_usuario_v2ray ;; 
            0) break ;; 
        esac
    done
}

# ==================================================
# BLOQUE HYSTERIA V2 (FINAL: DB + OBFS FIX)
# ==================================================

# DEFINICION EXPLICITA DE RUTAS PARA EVITAR ERRORES
HY_USERS_DB="/etc/reagens/users/hysteria"
HY_CONF="/etc/hysteria/config.yaml"

regen_hysteria_config() {
    # Asegurar que existe el directorio DB
    mkdir -p "$HY_USERS_DB"

    # Leer puerto actual
    PORT_H=36712
    if [[ -f "$HY_CONF" ]]; then
        P_TMP=$(grep "listen:" "$HY_CONF" | grep -oE ':[0-9]+' | cut -d: -f2)
        [[ ! -z "$P_TMP" ]] && PORT_H=$P_TMP
    fi
    
    # --- GENERAR/LEER CLAVE DE OFUSCACION ---
    if [[ ! -f "/etc/hysteria/obfs_pass" ]]; then
        mkdir -p /etc/hysteria
        head -n 1 /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 16 | head -n 1 > /etc/hysteria/obfs_pass
    fi
    OBFS_PASS=$(cat /etc/hysteria/obfs_pass)
    # ----------------------------------------

    # Cabecera YAML con OFUSCACION
    cat <<EOF > "$HY_CONF"
listen: :$PORT_H
tls:
  cert: /etc/hysteria/server.crt
  key: /etc/hysteria/server.key
obfs:
  type: salamander
  salamander:
    password: "$OBFS_PASS"
auth:
  type: userpass
  userpass:
EOF
    # Loop usuarios
    count=0
    # Chequeo estricto de archivos
    if [ "$(ls -A $HY_USERS_DB 2>/dev/null)" ]; then
        for ufile in "$HY_USERS_DB"/*; do
            if [[ -f "$ufile" ]]; then
                u=$(basename "$ufile")
                source "$ufile"
                echo "    $u: \"$PASS\"" >> "$HY_CONF"
                ((count++))
            fi
        done
    fi
    
    # Usuario admin por defecto si no hay nadie
    if [[ "$count" -eq 0 ]]; then
        echo "    admin: \"admin123\"" >> "$HY_CONF"
    fi
    
    # Masquerade
    cat <<EOF >> "$HY_CONF"
masquerade:
  type: proxy
  proxy:
    url: https://bing.com/
    rewriteHost: true
EOF

    # FIX PERMISOS Y REINICIO
    chmod 644 "$HY_CONF"
    systemctl restart hysteria-server
}

install_hysteria() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} INSTALADOR HYSTERIA V2 PRO ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    echo -n " Ingrese Puerto UDP para Hysteria [Default 36712]: "
    read P_HY
    [[ -z "$P_HY" ]] && P_HY=36712

    echo -e " ${C_DATO}[+] Descargando binario oficial...${C_RESET}"
    curl -fsSL https://get.hy2.sh/ | bash >/dev/null 2>&1
    
    mkdir -p /etc/hysteria /etc/reagens/users/hysteria
    
    # Certificado persistente
    [[ ! -f "/etc/hysteria/server.key" ]] && openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout /etc/hysteria/server.key -out /etc/hysteria/server.crt -days 3650 -subj "/CN=ReagensVPN" &>/dev/null
    
    # Generar config inicial con el puerto elegido
    cat <<EOF > /etc/hysteria/config.yaml
listen: :$P_HY
tls:
  cert: /etc/hysteria/server.crt
  key: /etc/hysteria/server.key
auth:
  type: userpass
  userpass:
    admin: "admin123"
masquerade:
  type: proxy
  proxy:
    url: https://www.bing.com/
    rewriteHost: true
EOF

    # Forzar servicio
    cat <<EOF > /etc/systemd/system/hysteria-server.service
[Unit]
Description=Hysteria V2 Server
After=network.target
[Service]
ExecStart=/usr/local/bin/hysteria server -c /etc/hysteria/config.yaml
Restart=always
User=root
[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable hysteria-server && systemctl restart hysteria-server
    iptables -I INPUT -p udp --dport $P_HY -j ACCEPT
    fun_save_iptables
    echo -e "${C_VERDE} Hysteria V2 Instalado en el puerto $P_HY.${C_RESET}"
    sleep 2
}

add_hysteria_user() {
    clear
    # SEGURIDAD: Crear carpeta si no existe
    if [[ ! -d "$HY_USERS_DB" ]]; then
        mkdir -p "$HY_USERS_DB"
    fi

    echo -e "${C_BARRA} AGREGAR USUARIO HYSTERIA ${C_BARRA}"
    echo -n " Usuario: "
    read u
    [[ -z "$u" ]] && return
    if [[ -f "$HY_USERS_DB/$u" ]]; then echo "Existe"; sleep 1; return; fi
    
    echo -n " Clave: "
    read p
    [[ -z "$p" ]] && return
    
    echo -n " Dias: "
    read d
    [[ -z "$d" ]] && d=30
    
    fd=$(date -d "+$d days" +%Y-%m-%d)
    
    # GUARDADO EXPLICITO
    echo "PASS=\"$p\"" > "$HY_USERS_DB/$u"
    echo "EXP=\"$fd\"" >> "$HY_USERS_DB/$u"
    
    # VERIFICACION
    if [[ -f "$HY_USERS_DB/$u" ]]; then
        regen_hysteria_config
        echo -e "${C_VERDE} Usuario Agregado y Guardado.${C_RESET}"
    else
        echo -e "${C_ROJO} Error: No se pudo escribir en la base de datos.${C_RESET}"
    fi
    sleep 2
}

del_hysteria_user() {
    clear
    echo -e "${C_BARRA} ELIMINAR USUARIO HYSTERIA ${C_BARRA}"
    i=1
    declare -a h_users
    
    if [[ ! -d "$HY_USERS_DB" ]]; then echo "No hay DB"; sleep 2; return; fi
    
    # Fix para globbing vacio
    shopt -s nullglob
    for f in "$HY_USERS_DB"/*; do
        if [[ -f "$f" ]]; then
            u=$(basename "$f")
            echo " [$i] $u"
            h_users[$i]=$u
            let i++
        fi
    done
    shopt -u nullglob
    
    if [[ $i -eq 1 ]]; then echo "Vacio"; sleep 1; return; fi
    echo -n " Numero: "
    read op
    SEL=${h_users[$op]}
    if [[ ! -z "$SEL" ]]; then
        rm -f "$HY_USERS_DB/$SEL"
        regen_hysteria_config
        echo "Eliminado."
        sleep 1
    fi
}

show_hysteria_link() {
    clear
    echo -e "${C_BARRA} LINK HYSTERIA V2 (OBFS) ${C_BARRA}"
    i=1
    declare -a h_users
    
    if [[ ! -d "$HY_USERS_DB" ]]; then echo "No hay usuarios creados."; sleep 2; return; fi

    # Fix para globbing vacio
    shopt -s nullglob
    for f in "$HY_USERS_DB"/*; do
        if [[ -f "$f" ]]; then
            u=$(basename "$f")
            echo " [$i] $u"
            h_users[$i]=$u
            let i++
        fi
    done
    shopt -u nullglob
    
    if [[ $i -eq 1 ]]; then echo "Vacio"; sleep 1; return; fi
    echo -n " Numero: "
    read op
    SEL=${h_users[$op]}
    if [[ ! -z "$SEL" ]]; then
        source "$HY_USERS_DB/$SEL"
        IP=$(curl -s ipv4.icanhazip.com)
        PORT=$(grep "listen:" "$HY_CONF" | grep -oE ':[0-9]+' | cut -d: -f2)
        
        # Recuperar clave ofuscacion
        if [[ -f "/etc/hysteria/obfs_pass" ]]; then
             OBFS_PASS=$(cat /etc/hysteria/obfs_pass)
        else
             OBFS_PASS=""
        fi

        # Link con OFUSCACION
        LINK="hysteria2://$SEL:$PASS@$IP:$PORT/?insecure=1&sni=bing.com&obfs=salamander&obfs-password=$OBFS_PASS#$SEL"
        
        echo -e "${C_TEXTO} Vence: $EXP ${C_RESET}"
        echo -e "${C_DATO} Clave Obfs: $OBFS_PASS ${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e "${C_DATO}$LINK${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        read -p "Enter..."
    fi
}

menu_hysteria() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION HYSTERIA V2 (UDP) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # --- DETECCION MEJORADA (Garantiza el ON) ---
        if pgrep -x "hysteria" > /dev/null || [ -f "/usr/local/bin/hysteria" ] && { systemctl is-active --quiet hysteria-server || systemctl is-active --quiet hysteria; }; then
            ESTADO_HY="${C_VERDE}? INSTALADO / ON${C_RESET}"
        else
            ESTADO_HY="${C_ROJO}? NO INSTALADO / OFF${C_RESET}"
        fi
        
        echo -e " ESTADO: $ESTADO_HY"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1] > INSTALAR / REINSTALAR HYSTERIA${C_RESET}"
        echo -e " ${C_TEXTO}[2] > CREAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[3] > ELIMINAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[4] > VER LINK DE CONEXION${C_RESET}"
        echo -e " ${C_TEXTO}[5] > DESINSTALAR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1) install_hysteria ;;
            2) add_hysteria_user ;;
            3) del_hysteria_user ;;
            4) show_hysteria_link ;;
            5) 
               systemctl stop hysteria-server hysteria 2>/dev/null
               rm -f /etc/systemd/system/hysteria*
               rm -rf /etc/hysteria
               echo "Desinstalado."
               sleep 2
               ;;
            0) break ;;
        esac
    done
}

# ==================================================
# GESTION PROTOCOLOS Y PUERTOS (SMART FORCE)
# ==================================================

# --- NUEVO SISTEMA SMART FORCE UNIVERSAL (REEMPLAZO) ---
fun_force_smart() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} PROTOCOLO DE EMERGENCIA UNIVERSAL REAGENS ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"

    # 1. DETECCI�N DE ENTORNO
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_ID=$ID
    else
        echo -e "${C_ROJO} [X] No se pudo detectar el SO. Abortando.${C_RESET}"
        sleep 2 && return
    fi

    echo -e " ${C_DATO}[1] Detectado: $NAME ($VERSION_ID)${C_RESET}"
    echo -e " ${C_DATO}[2] Instalando herramientas necesarias...${C_RESET}"

    # 2. INSTALACI�N DE DEPENDENCIAS SEG�N SO
    case "$OS_ID" in
        ubuntu|debian)
            apt-get update -y >/dev/null 2>&1
            apt-get install -y python3 lsof net-tools psmisc iptables-persistent >/dev/null 2>&1
            ;;
        centos|almalinux|rocky)
            yum install -y python3 lsof net-tools psmisc iptables-services >/dev/null 2>&1
            ;;
    esac

    # 3. ESCANEO Y LIMPIEZA TOTAL (EXCEPTO PUERTO 22)
    echo -e " ${C_DATO}[3] Identificando y liberando puertos (Backup en /tmp/reagens_ports.log)${C_RESET}"
    netstat -tulpn | grep -v ":22 " > /tmp/reagens_ports.log

    # Obtenemos todos los PIDs que NO sean del SSH (puerto 22)
    PIDS_A_MATAR=$(lsof -i -P -n | grep LISTEN | grep -v ":22" | awk '{print $2}' | sort -u)

    if [ ! -z "$PIDS_A_MATAR" ]; then
        for pid in $PIDS_A_MATAR; do
            PROCNAME=$(ps -p $pid -o comm=)
            echo -e "     Liberando puerto ocupado por: ${C_ROJO}$PROCNAME${C_RESET} (PID: $pid)"
            kill -9 $pid 2>/dev/null
        done
    else
        echo -e "     No se encontraron procesos bloqueando otros puertos."
    fi

    # 4. CREACI�N DEL PROXY PYTHON (WS-FIX)
    echo -e " ${C_DATO}[4] Configurando Websocket Proxy (Puerto 80 -> 22)...${C_RESET}"
    mkdir -p /etc/reagens/bin

cat <<'EOF' > /etc/reagens/bin/ws-fix.py
import socket, threading, select, sys
BIND = ('0.0.0.0', 80)
DEST = ('127.0.0.1', 22)
def handler(client_sock):
    target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try: target_sock.connect(DEST)
    except: client_sock.close(); return
    try:
        request = client_sock.recv(4096)
        response = (b'HTTP/1.1 101 HIRVIP VPN PRO\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ReagensFix\r\n\r\n')
        client_sock.send(response)
        while True:
            r, w, x = select.select([client_sock, target_sock], [], [])
            if client_sock in r:
                data = client_sock.recv(4096)
                if not data: break
                target_sock.send(data)
            if target_sock in r:
                data = target_sock.recv(4096)
                if not data: break
                client_sock.send(data)
    except: pass
    finally: client_sock.close(); target_sock.close()
def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: server.bind(BIND); server.listen(5)
    except: sys.exit(1)
    while True:
        try: client, addr = server.accept(); threading.Thread(target=handler, args=(client,)).start()
        except: pass
if __name__ == '__main__': main()
EOF

    # 5. GESTI�N DEL SERVICIO SYSTEMD
    echo -e " ${C_DATO}[5] Desplegando servicio systemd...${C_RESET}"
cat <<EOF > /etc/systemd/system/ws-reagens.service
[Unit]
Description=Reagens Universal Emergency WS
After=network.target
[Service]
Type=simple
ExecStart=/usr/bin/python3 /etc/reagens/bin/ws-fix.py
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable ws-reagens >/dev/null 2>&1
    systemctl restart ws-reagens

    # 6. FIREWALL MULTI-SO
    echo -e " ${C_DATO}[6] Configurando Firewall Nativo...${C_RESET}"
    if command -v firewall-cmd >/dev/null 2>&1; then
        firewall-cmd --permanent --add-port=80/tcp >/dev/null 2>&1
        firewall-cmd --permanent --add-port=22/tcp >/dev/null 2>&1
        firewall-cmd --reload >/dev/null 2>&1
    fi
    if command -v ufw >/dev/null 2>&1; then
        ufw allow 80/tcp >/dev/null 2>&1
        ufw allow 22/tcp >/dev/null 2>&1
    fi
    iptables -I INPUT -p tcp --dport 80 -j ACCEPT
    iptables -I INPUT -p tcp --dport 22 -j ACCEPT

    # 7. DIAGN�STICO FINAL
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    if netstat -tuln | grep -q ":80 "; then
        echo -e " ${C_VERDE}[OK] Reagens Proxy activo en puerto 80.${C_RESET}"
    else
        echo -e " ${C_ROJO}[!] Error: El puerto 80 no levant�.${C_RESET}"
    fi
    echo -e " Registro guardado en: /tmp/reagens_ports.log"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Presione Enter para continuar..."
}

# --- GESTOR PYTHON SOCKET CON VERIFICADOR DE PUERTOS ---
fun_python_sock() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} AJUSTES PYTHON WEBSOCKET ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if systemctl is-active --quiet ws-reagens; then
        STATUS="${C_VERDE}ACTIVO${C_RESET}"
        PID=$(pgrep -f "ws-fix.py")
        PORT_ACT=$(netstat -tlpn | grep "$PID/python3" | awk '{print $4}' | awk -F: '{print $NF}')
        echo -e " Estado: $STATUS (Puerto: $PORT_ACT)"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Desactivar Python Socket"
        echo -e " [2] Cambiar Puerto / Reiniciar"
    else
        STATUS="${C_ROJO}DESACTIVADO${C_RESET}"
        echo -e " Estado: $STATUS"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Activar Python Socket"
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " 0) Volver"
    echo -n " Opcion: "
    read op
    
    if [[ "$op" == "0" ]]; then return; fi
    
    if systemctl is-active --quiet ws-reagens; then
        if [[ "$op" == "1" ]]; then
            systemctl stop ws-reagens
            systemctl disable ws-reagens
            echo -e "${C_ROJO} Servicio Detenido.${C_RESET}"
            sleep 2
            return
        fi
    fi
    
    echo -n " Ingrese Puerto para Python (Default 80): "
    read p_py
    [[ -z "$p_py" ]] && p_py=80

    # === MEJORA INTEGRADA: VALIDACION DE PUERTO ===
    # Si el puerto est� en uso, mostrar� error y cancelar� la instalaci�n
    fun_check_port $p_py "Python WebSocket" || return
    # ==============================================
    
    # Liberar puerto por seguridad
    fuser -k $p_py/tcp >/dev/null 2>&1
    
    mkdir -p /etc/reagens/bin
    cat <<EOF > /etc/reagens/bin/ws-fix.py
import socket, threading, select, sys
BIND = ('0.0.0.0', $p_py)
DEST = ('127.0.0.1', 22)
def handler(client_sock):
    target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try: target_sock.connect(DEST)
    except: client_sock.close(); return
    try:
        request = client_sock.recv(4096)
        response = (b'HTTP/1.1 101 HIRVIP VPN PRO\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ReagensFix\r\n\r\n')
        client_sock.send(response)
        while True:
            r, w, x = select.select([client_sock, target_sock], [], [])
            if client_sock in r:
                data = client_sock.recv(4096)
                if not data: break
                target_sock.send(data)
            if target_sock in r:
                data = target_sock.recv(4096)
                if not data: break
                client_sock.send(data)
    except: pass
    finally: client_sock.close(); target_sock.close()
def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: server.bind(BIND); server.listen(0)
    except Exception as e: sys.exit(1)
    while True:
        try: client, addr = server.accept(); threading.Thread(target=handler, args=(client,)).start()
        except: pass
if __name__ == '__main__': main()
EOF

    cat <<EOF > /etc/systemd/system/ws-reagens.service
[Unit]
Description=Reagens Python WS
After=network.target
[Service]
ExecStart=/usr/bin/python3 /etc/reagens/bin/ws-fix.py
Restart=always
RestartSec=2
[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable ws-reagens >/dev/null 2>&1
    systemctl restart ws-reagens
    
    iptables -I INPUT -p tcp --dport $p_py -j ACCEPT
    fun_save_iptables    
    echo -e "${C_VERDE} Python Activado en puerto $p_py.${C_RESET}"
    sleep 2
}

# ==================================================
# WS-EPRO: WEBSOCKET PRO (CUSTOM PORTS) - AGREGADO
# ==================================================

fun_instalar_ws_epro() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} INSTALADOR WS-EPRO (MULTI-PORT) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    # 1. DEFINIR PUERTO DE ESCUCHA (ENTRADA)
    echo -e " ${C_DATO}[1] Puerto de ENTRADA (Donde conectan las Apps)${C_RESET}"
    echo -n " Ingrese Puerto (Default 8080): "
    read P_LOCAL
    if [[ -z "$P_LOCAL" ]]; then P_LOCAL=8080; fi

    # 2. DEFINIR PUERTO DE SALIDA (DESTINO)
    echo -e "\n ${C_DATO}[2] Puerto de SALIDA (A donde redirige el tr�fico)${C_RESET}"
    echo -e " Ejemplos: 22 (SSH), 443 (SSL), 1194 (OVPN)"
    echo -n " Ingrese Puerto (Default 22): "
    read P_TARGET
    if [[ -z "$P_TARGET" ]]; then P_TARGET=22; fi

    echo -e "\n ${C_TEXTO}Configurando: Entrada ${C_VERDE}$P_LOCAL${C_RESET} -> Salida ${C_VERDE}$P_TARGET${C_RESET}..."
    sleep 1

    # Matar procesos previos en ese puerto para evitar choques
    fuser -k $P_LOCAL/tcp >/dev/null 2>&1

    mkdir -p /etc/reagens/bin
    
    # --- GENERACION DEL SCRIPT PYTHON OPTIMIZADO (WS-EPRO) ---
    cat <<EOF > /etc/reagens/bin/ws-epro.py
import socket, threading, select, sys

# CONFIGURACION DINAMICA
BIND_IP = '0.0.0.0'
BIND_PORT = $P_LOCAL
TARGET_IP = '127.0.0.1'
TARGET_PORT = $P_TARGET
BUFFER_SIZE = 8192

class Server(threading.Thread):
    def __init__(self, conn, addr):
        threading.Thread.__init__(self)
        self.client_socket = conn
        self.addr = addr
        self.running = True

    def run(self):
        target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            target_socket.connect((TARGET_IP, TARGET_PORT))
        except:
            self.client_socket.close()
            return

        try:
            request = self.client_socket.recv(BUFFER_SIZE)
            if request:
                # Handshake Universal
                response = (
                    b'HTTP/1.1 101 HIRVIP VPN PRO\r\n'
                    b'Upgrade: websocket\r\n'
                    b'Connection: Upgrade\r\n'
                    b'Sec-WebSocket-Accept: ReagensEpro\r\n\r\n'
                )
                self.client_socket.send(response)
                
                while self.running:
                    r, w, x = select.select([self.client_socket, target_socket], [], [], 30)
                    if self.client_socket in r:
                        data = self.client_socket.recv(BUFFER_SIZE)
                        if not data: break
                        target_socket.send(data)
                    if target_socket in r:
                        data = target_socket.recv(BUFFER_SIZE)
                        if not data: break
                        self.client_socket.send(data)
        except:
            pass
        finally:
            self.client_socket.close()
            target_socket.close()

def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_socket.bind((BIND_IP, BIND_PORT))
        server_socket.listen(100)
    except:
        sys.exit(1)

    while True:
        try:
            client_socket, addr = server_socket.accept()
            Server(client_socket, addr).start()
        except:
            pass

if __name__ == '__main__':
    main()
EOF

    # --- CREAR SERVICIO SYSTEMD ---
    cat <<EOF > /etc/systemd/system/ws-epro.service
[Unit]
Description=Reagens WS-EPRO (Port $P_LOCAL to $P_TARGET)
After=network.target

[Service]
ExecStart=/usr/bin/python3 /etc/reagens/bin/ws-epro.py
Restart=always
RestartSec=2
User=root

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable ws-epro >/dev/null 2>&1
    systemctl restart ws-epro
    
    iptables -I INPUT -p tcp --dport $P_LOCAL -j ACCEPT
    fun_save_iptables >/dev/null 2>&1
    
    echo -e "${C_VERDE} WS-EPRO INSTALADO.${C_RESET}"
    echo -e " Puerto Activo: ${C_DATO}$P_LOCAL${C_RESET} -> Destino: ${C_DATO}$P_TARGET${C_RESET}"
    sleep 3
}

fun_ws_epro_menu() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION WS-EPRO (AVANZADO) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if systemctl is-active --quiet ws-epro; then
            STATUS="${C_VERDE}ACTIVO${C_RESET}"
            if [[ -f "/etc/reagens/bin/ws-epro.py" ]]; then
                IN_P=$(grep "BIND_PORT =" /etc/reagens/bin/ws-epro.py | awk '{print $3}')
                OUT_P=$(grep "TARGET_PORT =" /etc/reagens/bin/ws-epro.py | awk '{print $3}')
                INFO_PORTS="Entrada: ${C_DATO}$IN_P${C_RESET} -> Salida: ${C_DATO}$OUT_P${C_RESET}"
            else
                INFO_PORTS="Puertos: Desconocido"
            fi
            echo -e " ESTADO: $STATUS"
            echo -e " $INFO_PORTS"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > DETENER Y ELIMINAR${C_RESET}"
            echo -e " ${C_TEXTO}[2] > REINICIAR SERVICIO${C_RESET}"
            echo -e " ${C_TEXTO}[3] > CAMBIAR PUERTOS (REINSTALAR)${C_RESET}"
        else
            STATUS="${C_ROJO}DETENIDO${C_RESET}"
            echo -e " ESTADO: $STATUS"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > INSTALAR WS-EPRO${C_RESET}"
        fi
        
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1)
                if systemctl is-active --quiet ws-epro; then
                    systemctl stop ws-epro
                    systemctl disable ws-epro
                    rm -f /etc/systemd/system/ws-epro.service
                    rm -f /etc/reagens/bin/ws-epro.py
                    systemctl daemon-reload
                    echo -e "${C_ROJO} Eliminado.${C_RESET}"; sleep 2
                else
                    fun_instalar_ws_epro
                fi
                ;;
            2) systemctl restart ws-epro; echo "Reiniciado."; sleep 2 ;;
            3) systemctl stop ws-epro; fun_instalar_ws_epro ;;
            0) break ;;
        esac
    done
}

# --- GESTOR BADVPN INTELLIGENTE INFALIBLE ---
fun_badvpn_menu() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} AJUSTES BADVPN UDP (INFALIBLE) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if systemctl is-active --quiet badvpn; then
            STATUS="${C_VERDE}[ON] ACTIVO${C_RESET}"
            PID_BAD=$(pgrep -f "badvpn-udpgw")
            echo -e " ESTADO: $STATUS (PID: $PID_BAD)"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > DESACTIVAR BADVPN${C_RESET}"
            echo -e " ${C_TEXTO}[2] > REINICIAR SERVICIO${C_RESET}"
        else
            STATUS="${C_ROJO}[OFF] DETENIDO${C_RESET}"
            echo -e " ESTADO: $STATUS"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > ACTIVAR BADVPN UDP${C_RESET}"
        fi
        
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op
        
        case $op in
            0) return ;;
            1) 
                if systemctl is-active --quiet badvpn; then
                    systemctl stop badvpn
                    systemctl disable badvpn
                    rm -f /etc/systemd/system/badvpn.service
                    echo -e "${C_ROJO} BadVPN Detenido.${C_RESET}"
                    sleep 2
                else
                    echo -n " Puerto UDP BadVPN (Default 7300): "
                    read port
                    if [[ -z "$port" ]]; then port=7300; fi
                    
                    # LOGICA INFALIBLE (BINARIOS ESTATICOS)
                    ARCH=$(uname -m)
                    echo -e " ${C_DATO}Arquitectura detectada: $ARCH${C_RESET}"
                    rm -f /usr/bin/badvpn-udpgw
                    
                    echo -e " ${C_DATO}Descargando binario estatico...${C_RESET}"
                    
                    if [[ "$ARCH" == "x86_64" ]]; then
                        wget -q --no-check-certificate -O /usr/bin/badvpn-udpgw "https://raw.githubusercontent.com/daybreakersx/prem/master/badvpn-udpgw64"
                    elif [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]]; then
                         wget -q --no-check-certificate -O /usr/bin/badvpn-udpgw "https://raw.githubusercontent.com/shadoowg/vps-mx/master/archivos/badvpn-udpgw"
                    else
                         # Fallback generico
                         wget -q --no-check-certificate -O /usr/bin/badvpn-udpgw "https://raw.githubusercontent.com/daybreakersx/prem/master/badvpn-udpgw64"
                    fi
                    
                    chmod +x /usr/bin/badvpn-udpgw
                    chmod 777 /usr/bin/badvpn-udpgw
                    
                    cat <<EOF > /etc/systemd/system/badvpn.service
[Unit]
Description=BadVPN UDP Gateway
After=network.target

[Service]
ExecStart=/usr/bin/badvpn-udpgw --listen-addr 127.0.0.1:$port --max-clients 1000 --loglevel none
User=root
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF
                    systemctl daemon-reload
                    systemctl enable badvpn >/dev/null 2>&1
                    systemctl restart badvpn
                    
                    iptables -I INPUT -p udp --dport $port -j ACCEPT
    iptables -I INPUT -i lo -j ACCEPT
    fun_save_iptables                    
                    if systemctl is-active --quiet badvpn; then
                        echo -e "${C_VERDE} BadVPN Activado con EXITO en puerto $port.${C_RESET}"
                    else
                         echo -e "${C_ROJO} Error al iniciar. Verificando...${C_RESET}"
                         # Intento de compilacion como ultimo recurso si falla el binario estatico
                         echo "Compilando fallback..."
if [[ -f /etc/redhat-release ]]; then
    yum install -y cmake make gcc unzip wget >/dev/null 2>&1
else
    apt-get install -y cmake make gcc unzip wget >/dev/null 2>&1
fi
                         apt-get install cmake make gcc -y >/dev/null 2>&1
                         mkdir -p /tmp/badvpn_build; cd /tmp/badvpn_build
                         wget -q https://github.com/ambrop72/badvpn/archive/refs/heads/master.zip
                         unzip -q master.zip; cd badvpn-master; mkdir build; cd build
                         cmake -DBUILD_NOTHING_BY_DEFAULT=1 -DBUILD_UDPGW=1 .. >/dev/null 2>&1
                         make >/dev/null 2>&1
                         cp udpgw/badvpn-udpgw /usr/bin/badvpn-udpgw
                         chmod +x /usr/bin/badvpn-udpgw
                         cd /root; rm -rf /tmp/badvpn_build
                         systemctl restart badvpn
                    fi
                    sleep 2
                fi
                ;;
            2)
                systemctl restart badvpn
                echo -e "${C_VERDE} Servicio Reiniciado.${C_RESET}"
                sleep 2
                ;;
        esac
    done
}

# --- GESTOR SSL STUNNEL REPARADO ---
fun_ssl_menu() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} AJUSTES SSL STUNNEL PRO (FIX) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    SSL_SVC="stunnel4"
    [[ -f /etc/redhat-release ]] && SSL_SVC="stunnel"

    if command -v stunnel >/dev/null 2>&1 || command -v stunnel4 >/dev/null 2>&1; then
        echo -e " Estado: ${C_VERDE}INSTALADO${C_RESET}"
        PORTS=$(grep "accept =" /etc/stunnel/stunnel.conf 2>/dev/null | cut -d= -f2 | tr '\n' ' ')
        echo -e " Puertos activos: ${C_DATO}${PORTS:-Ninguno}${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Agregar Nuevo Puerto SSL"
        echo -e " [2] Limpiar Configuraci�n y Desinstalar"
    else
        echo -e " Estado: ${C_ROJO}NO INSTALADO${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Instalar SSL (Certificado Auto-Firmado)"
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " 0) Volver"
    echo -n " Opcion: "
    read op
    
    case $op in
        1) 
           echo -e " ${C_DATO}[+] Verificando paquetes...${C_RESET}"
           [[ -f /etc/redhat-release ]] && yum install -y stunnel openssl || apt-get install -y stunnel4 openssl
           
           # Generar Certificado Robusto si no existe
           if [[ ! -f "/etc/stunnel/stunnel.pem" ]]; then
               echo -e " ${C_DATO}[+] Generando Certificado Seguro...${C_RESET}"
               openssl genrsa -out key.pem 2048 >/dev/null 2>&1
               openssl req -new -x509 -key key.pem -out cert.pem -days 1095 -subj "/CN=ReagensPro" >/dev/null 2>&1
               cat key.pem cert.pem > /etc/stunnel/stunnel.pem
               rm -f key.pem cert.pem
               chmod 600 /etc/stunnel/stunnel.pem
           fi

           echo -n " Puerto SSL a abrir (Ej: 443): "
           read p
           [[ -z "$p" ]] && return

           # Configuracion limpia
           cat <<EOF >> /etc/stunnel/stunnel.conf
[ssh-ssl-$p]
client = no
accept = $p
connect = 127.0.0.1:22
cert = /etc/stunnel/stunnel.pem
EOF
           # Habilitar servicio en Debian/Ubuntu
           [[ -f /etc/default/stunnel4 ]] && sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
           
           systemctl enable $SSL_SVC >/dev/null 2>&1
           systemctl restart $SSL_SVC
           iptables -I INPUT -p tcp --dport $p -j ACCEPT
           fun_save_iptables
           echo -e "${C_VERDE} SSL activo en puerto $p redirigiendo al 22.${C_RESET}"
           sleep 2 ;;
        2)
           systemctl stop $SSL_SVC && rm -rf /etc/stunnel/*
           echo "SSL Limpiado."; sleep 2 ;;
        0) return ;;
    esac
}

# --- GESTOR DROPBEAR FLEXIBLE (CON PERSISTENCIA) ---
fun_dropbear_menu() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTOR DROPBEAR SSH (PUERTO PERSONALIZADO) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        if systemctl is-active --quiet dropbear-custom; then
            PORT_ACTUAL=$(grep "ExecStart" /etc/systemd/system/dropbear-custom.service | grep -oE "\-p [0-9]+" | awk '{print $2}')
            echo -e " ESTADO: ${C_VERDE}ACTIVO${C_RESET} | PUERTO: ${C_DATO}$PORT_ACTUAL${C_RESET}"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > CAMBIAR PUERTO / REINSTALAR${C_RESET}"
            echo -e " ${C_TEXTO}[2] > DETENER Y DESINSTALAR${C_RESET}"
        else
            echo -e " ESTADO: ${C_ROJO}NO INSTALADO${C_RESET}"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > INSTALAR DROPBEAR${C_RESET}"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1)
                echo -n " Ingresa el Puerto [Default 9090]: "
                read DB_PORT
                [[ -z "$DB_PORT" ]] && DB_PORT="9090"
                fuser -k $DB_PORT/tcp >/dev/null 2>&1
                systemctl stop dropbear-custom >/dev/null 2>&1
                if ! command -v dropbear >/dev/null 2>&1; then
                    [[ -f /etc/redhat-release ]] && yum install dropbear -y || apt-get install dropbear -y; fi
                BIN_DB=$(command -v dropbear)
cat <<EOF > /etc/systemd/system/dropbear-custom.service
[Unit]
Description=Dropbear Custom Port $DB_PORT
After=network.target
[Service]
Type=simple
ExecStart=$BIN_DB -F -p $DB_PORT -w -g
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
EOF
                systemctl daemon-reload
                systemctl enable dropbear-custom
                systemctl restart dropbear-custom
                iptables -I INPUT -p tcp --dport $DB_PORT -j ACCEPT
                fun_save_iptables
                echo -e "${C_VERDE} DROPBEAR ACTIVO EN PUERTO $DB_PORT.${C_RESET}"; sleep 2 ;;
            2)
                systemctl stop dropbear-custom; systemctl disable dropbear-custom
                rm -f /etc/systemd/system/dropbear-custom.service
                fun_save_iptables
                echo "Servicio detenido y eliminado."; sleep 2 ;;
            0) return ;;
        esac
    done
}

# --- SLOWDNS MANAGER (FIX PUERTOS 53/5300) ---
fun_slowdns_menu() {
    SLOWDNS_DIR="/etc/slowdns"
    mkdir -p $SLOWDNS_DIR

    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} SLOWDNS DUAL PORT (53 / 5300) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        status_sd=$(systemctl is-active slowdns-server)
        curr_svc=$(grep "ExecStart" /etc/systemd/system/slowdns-server.service 2>/dev/null | awk '{print $NF}')
        
        echo -e " ESTADO      : $([[ "$status_sd" == "active" ]] && echo -e "${C_VERDE}ONLINE${C_RESET}" || echo -e "${C_ROJO}OFFLINE${C_RESET}")"
        echo -e " PUERTOS IN  : ${C_VERDE}53, 5300 (UDP)${C_RESET}"
        echo -e " SALIDA (TO) : ${C_DATO}${curr_svc:-No configurado}${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        
        if [[ "$status_sd" != "active" ]]; then
            echo -e " [1] INSTALAR SLOWDNS"
        else
            echo -e " [2] CAMBIAR PUERTO DE SALIDA (SSH/XRAY/SSL)"
            echo -e " [3] VER LLAVE P�BLICA"
            echo -e " [4] DESINSTALAR"
        fi
        echo -e " [0] VOLVER"
        echo -ne "\n Opcion: "
        read op_sd

        case $op_sd in
            1)
                echo -n " Ingrese su NS (Dominio): "
                read NS_DOMAIN
                echo -e " Seleccione puerto de salida interno:"
                echo -e " (22 = SSH, 443 = SSL, 8080 = V2RAY)"
                echo -n " Puerto destino [Default 22]: "
                read T_PORT
                [[ -z "$T_PORT" ]] && T_PORT=22
                
                # Detener procesos DNS del sistema
                systemctl stop systemd-resolved &>/dev/null
                systemctl disable systemd-resolved &>/dev/null
                fuser -k 53/udp &>/dev/null
                
                # Descarga seg�n arquitectura
                ARCH=$(uname -m)
                URL_SERVER="https://raw.githubusercontent.com/fisabiliyusri/SLDNS/main/slowdns/sldns-server"
                [[ "$ARCH" == "arm64" || "$ARCH" == "aarch64" ]] && URL_SERVER="https://github.com/vernesong/OpenClash/raw/core/master/core-backup/dnstt-server-linux-arm64"
                
                wget -q -O $SLOWDNS_DIR/sldns-server "$URL_SERVER"
                chmod +x $SLOWDNS_DIR/sldns-server
                
                # Generar llaves si no existen
                cd $SLOWDNS_DIR
                ./sldns-server -gen-key -privkey-file server.key -pubkey-file server.pub
                
                # Crear servicio (Escucha en 53)
                cat <<EOF > /etc/systemd/system/slowdns-server.service
[Unit]
Description=SlowDNS Reagens
After=network.target
[Service]
Type=simple
ExecStart=$SLOWDNS_DIR/sldns-server -udp :53 -mtu 1200 -privkey-file $SLOWDNS_DIR/server.key $NS_DOMAIN 127.0.0.1:$T_PORT
Restart=always
User=root
[Install]
WantedBy=multi-user.target
EOF
                # Redirecci�n de puerto 5300 -> 53 (Para que ambos funcionen)
                iptables -t nat -I PREROUTING -p udp --dport 5300 -j REDIRECT --to-ports 53
                iptables -I INPUT -p udp --dport 53 -j ACCEPT
                iptables -I INPUT -p udp --dport 5300 -j ACCEPT
                fun_save_iptables
                
                systemctl daemon-reload
                systemctl enable slowdns-server && systemctl restart slowdns-server
                echo -e "${C_VERDE} Instalado en 53 y 5300 redirigiendo a $T_PORT.${C_RESET}"
                sleep 3
                ;;
            2)
                echo -n " Nuevo puerto destino interno: "
                read n_tp
                if [[ ! -z "$n_tp" ]]; then
                    sed -i "s|127.0.0.1:[0-9]*|127.0.0.1:$n_tp|g" /etc/systemd/system/slowdns-server.service
                    systemctl daemon-reload && systemctl restart slowdns-server
                    echo -e "${C_VERDE} Puerto de salida cambiado a $n_tp.${C_RESET}"
                    sleep 2
                fi
                ;;
            3)
                clear
                echo -e " LLAVE P�BLICA (SERVER.PUB):"
                cat $SLOWDNS_DIR/server.pub
                read -p " Enter para continuar..."
                ;;
            4)
                systemctl stop slowdns-server; systemctl disable slowdns-server
                rm -f /etc/systemd/system/slowdns-server.service
                iptables -t nat -D PREROUTING -p udp --dport 5300 -j REDIRECT --to-ports 53 2>/dev/null
                echo "Eliminado."; sleep 2
                ;;
            0) break ;;
        esac
    done
}

# --- FUNCION AUXILIAR PARA GENERAR BLOQUES JSON (MODO WIZARD) ---
generar_json_inbound() {
    local NUM_PERFIL=$1
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_VERDE}CONFIGURANDO PERFIL #$NUM_PERFIL${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"

    # 1. PROTOCOLO
    echo -e " ${C_TEXTO}Protocolo:${C_RESET}"
    echo -e " [1] VLESS  [2] VMESS  [3] TROJAN"
    echo -n " Opcion: "; read op_p
    case $op_p in
        1) P_NOM="vless";;
        2) P_NOM="vmess";;
        3) P_NOM="trojan";;
        *) P_NOM="vless";;
    esac

    # 2. PUERTO
    echo -n " Puerto de Apertura (Ej: 8080, 443): "; read P_PORT
    [[ -z "$P_PORT" ]] && P_PORT=8080
    fun_check_port $P_PORT "Perfil Xray" || return

    # 3. TRANSPORTE Y HOST
    echo -e " ${C_TEXTO}Transporte / Red:${C_RESET}"
    echo -e " [1] TCP (Directo)"
    echo -e " [2] WS (WebSocket - CDN)"
    echo -e " [3] gRPC"
    echo -e " [4] HTTPUpgrade"
    echo -e " [5] mKCP"
    echo -n " Opcion: "; read op_n
    
    # --- VARIABLES POR DEFECTO ---
    LNET="tcp"
    STREAM_S=""
    DEFAULT_PATH="/HIRVIP VPN PRO/"
    P_HOST_HEADER=""

    case $op_n in
        2) # WebSocket
            LNET="ws"
            echo -e "\n ${C_DATO}--- CONFIGURACION WEBSOCKET ---${C_RESET}"
            echo -n " Host (Header/Payload) [Ej: midominio.com]: "; read P_HOST_HEADER
            echo -n " Ruta/Path [Enter para '$DEFAULT_PATH']: "; read P_PATH
            [[ -z "$P_PATH" ]] && P_PATH="$DEFAULT_PATH"
            
            # Construccion Settings WS
            STREAM_S="\"wsSettings\": { \"path\": \"$P_PATH\", \"headers\": { \"Host\": \"$P_HOST_HEADER\" } },"
            ;;
            
        3) # gRPC
            LNET="grpc"
            echo -n " ServiceName (Host) [Ej: grpc]: "; read P_SERV
            [[ -z "$P_SERV" ]] && P_SERV="grpc"
            STREAM_S="\"grpcSettings\": { \"serviceName\": \"$P_SERV\" },"
            ;;
            
        4) # HTTPUpgrade
            LNET="httpupgrade"
            echo -n " Host (Header) [Ej: midominio.com]: "; read P_HOST_HEADER
            echo -n " Ruta/Path [Enter para '$DEFAULT_PATH']: "; read P_PATH
            [[ -z "$P_PATH" ]] && P_PATH="$DEFAULT_PATH"
            STREAM_S="\"httpupgradeSettings\": { \"path\": \"$P_PATH\", \"host\": \"$P_HOST_HEADER\" },"
            ;;
            
        5) # mKCP
            LNET="kcp"
            STREAM_S="\"kcpSettings\": { \"header\": { \"type\": \"none\" }, \"seed\": \"reagens\" },"
            ;;
            
        *) # TCP
            LNET="tcp"
            STREAM_S="\"tcpSettings\": {},"
            ;;
    esac

    # 4. SEGURIDAD TLS Y DOMINIO VPS
    echo -e "\n ${C_TEXTO}Seguridad:${C_RESET}"
    echo -e " [1] NONE (Sin cifrado / HTTP)"
    echo -e " [2] TLS (Certificado / HTTPS)"
    if [[ "$P_NOM" == "vless" && "$LNET" == "tcp" ]]; then echo -e " [3] REALITY (Vision)"; fi
    echo -n " Opcion: "; read op_sec

    SEC="none"
    TLS_S=""
    P_DOMAIN_VPS=""
    
    if [[ "$op_sec" == "2" ]]; then
        SEC="tls"
        echo -e "\n ${C_DATO}--- CONFIGURACION DOMINIO (TLS) ---${C_RESET}"
        echo -e " Ingrese el DOMINIO que apunta a esta VPS (Para el certificado)."
        echo -n " Dominio VPS: "; read P_DOMAIN_VPS
        
        # Validacion de certificados
        if [[ -f "/etc/reagens/cert/public.crt" ]]; then
             # Inyectamos el dominio del VPS como serverName para el certificado
             TLS_S="\"tlsSettings\": { \"serverName\": \"$P_DOMAIN_VPS\", \"certificates\": [ { \"certificateFile\": \"/etc/reagens/cert/public.crt\", \"keyFile\": \"/etc/reagens/cert/private.key\" } ] },"
        else
             echo -e " ${C_ROJO}Alerta: No hay certificados en /etc/reagens/cert.${C_RESET}"
             echo -e " Se configurar�, pero Xray podr�a fallar si no los generas."
             TLS_S="\"tlsSettings\": { \"serverName\": \"$P_DOMAIN_VPS\" },"
        fi

    elif [[ "$op_sec" == "3" && "$P_NOM" == "vless" ]]; then
        SEC="reality"
        echo -n " SNI Destino (Ej: www.microsoft.com): "; read SNI_REAL
        [[ -z "$SNI_REAL" ]] && SNI_REAL="www.microsoft.com"
        
        KEYS=$(xray x25519)
        PK=$(echo "$KEYS" | grep "Private" | awk '{print $3}')
        PUB=$(echo "$KEYS" | grep "Public" | awk '{print $3}')
        SID=$(openssl rand -hex 4)
        
        mkdir -p /etc/reagens
        echo "$PUB" > /etc/reagens/reality_pub
        
        TLS_S="\"realitySettings\": { \"show\": false, \"dest\": \"$SNI_REAL:443\", \"xver\": 0, \"serverNames\": [ \"$SNI_REAL\" ], \"privateKey\": \"$PK\", \"shortIds\": [ \"$SID\" ], \"fingerprint\": \"chrome\" },"
    fi

    # GENERAR CLIENTE BASE
    UUID_INIT=$(uuidgen)
    if [[ "$P_NOM" == "vmess" ]]; then CL_STR="{ \"id\": \"$UUID_INIT\", \"alterId\": 0, \"email\": \"admin\" }"
    elif [[ "$P_NOM" == "trojan" ]]; then CL_STR="{ \"password\": \"$UUID_INIT\", \"email\": \"admin\" }"
    else 
        if [[ "$SEC" == "reality" ]]; then CL_STR="{ \"id\": \"$UUID_INIT\", \"email\": \"admin\", \"flow\": \"xtls-rprx-vision\" }"
        else CL_STR="{ \"id\": \"$UUID_INIT\", \"email\": \"admin\" }"
        fi
    fi
    
    # RETORNAR EL BLOQUE JSON EN VARIABLE GLOBAL
    JSON_OUT="{
      \"port\": $P_PORT,
      \"protocol\": \"$P_NOM\",
      \"settings\": { \"clients\": [ $CL_STR ], \"decryption\": \"none\" },
      \"streamSettings\": {
        \"network\": \"$LNET\",
        \"security\": \"$SEC\",
        $TLS_S
        $STREAM_S
        \"sockopt\": { \"mark\": 0 }
      }
    }"
    
    # Guardar datos para el usuario por defecto
    mkdir -p /etc/reagens/users/v2ray
    echo "EXP=$(date -d '+30 days' +%Y-%m-%d)" > "/etc/reagens/users/v2ray/admin"
    echo "UUID=$UUID_INIT" >> "/etc/reagens/users/v2ray/admin"
}

# --- MANAGER PRINCIPAL (CON SOPORTE DUAL Y PREGUNTAS COMPLETAS) ---
proto_v2ray_manager() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} INSTALADOR XRAY DUAL (FULL WIZARD) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if [[ ! -f "/usr/local/bin/xray" ]]; then
        echo -e " ${C_DATO}Instalando Nucleo...${C_RESET}"
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install --force
        sleep 2; clear
    fi

    # --- PERFIL 1 ---
    generar_json_inbound 1
    INBOUND_1="$JSON_OUT"
    
    # --- PREGUNTA PERFIL 2 ---
    INBOUND_FINAL="$INBOUND_1"
    
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_DATO}�Desea agregar un Segundo Puerto/Protocolo? (Dual)${C_RESET}"
    echo -n " [s/n]: "
    read op_dual
    
    if [[ "$op_dual" == "s" ]]; then
        generar_json_inbound 2
        INBOUND_2="$JSON_OUT"
        INBOUND_FINAL="$INBOUND_1, $INBOUND_2"
        TXT_INFO="SISTEMA DUAL (2 Puertos)"
    else
        TXT_INFO="SISTEMA SIMPLE (1 Puerto)"
    fi

    # --- ESCRIBIR ARCHIVO ---
    echo -e "\n ${C_DATO}Generando config.json...${C_RESET}"
    mkdir -p /usr/local/etc/xray
    
    cat > /usr/local/etc/xray/config.json <<EOF
{
  "log": { "loglevel": "warning" },
  "inbounds": [ $INBOUND_FINAL ],
  "outbounds": [ 
    { "protocol": "freedom", "tag": "direct" }, 
    { "protocol": "blackhole", "tag": "block" } 
  ]
}
EOF

    # --- APLICAR ---
    # Limpiar puertos usados en el config
    PORTS=$(grep "\"port\":" /usr/local/etc/xray/config.json | awk '{print $2}' | tr -d ',')
    for P in $PORTS; do
        fuser -k $P/tcp >/dev/null 2>&1
        fuser -k $P/udp >/dev/null 2>&1
        # Matar servicios web si se usa el 80 o 443
        if [[ "$P" == "80" || "$P" == "443" ]]; then
            systemctl stop nginx >/dev/null 2>&1
            systemctl stop apache2 >/dev/null 2>&1
        fi
        iptables -I INPUT -p tcp --dport $P -j ACCEPT
        iptables -I INPUT -p udp --dport $P -j ACCEPT
    done
    fun_save_iptables >/dev/null 2>&1
    
    systemctl restart xray
    systemctl enable xray >/dev/null 2>&1

    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e "${C_VERDE} �INSTALACION COMPLETADA!${C_RESET}"
    echo -e " Modo: $TXT_INFO"
    echo -e " Puertos Activos: ${C_DATO}$PORTS${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    sleep 4
}

# --- NUEVA FUNCION: CLONADOR DE PUERTOS (SOCAT) ---
# --- NUEVA FUNCION: CLONADOR DE PUERTOS V3 (SOCAT + SYSTEMD) ---
fun_puerto_espejo() {
    MIRROR_SVC="/etc/systemd/system/socat-mirror.service"
    
    # Intenta leer la configuraci�n actual del servicio
    P_OPEN="?"
    P_TARGET="?"
    if systemctl is-active --quiet socat-mirror; then
        STATUS_MIRROR="${C_VERDE}ACTIVO (Systemd)${C_RESET}"
        ACT_CODE=2
        # Intentar obtener los puertos desde el archivo de servicio
        EXEC_LINE=$(grep "ExecStart=" $MIRROR_SVC 2>/dev/null)
        P_OPEN=$(echo "$EXEC_LINE" | grep -oE "LISTEN:[0-9]+" | cut -d: -f2)
        P_TARGET=$(echo "$EXEC_LINE" | grep -oE "TCP:127.0.0.1:[0-9]+" | cut -d: -f3)
        OPT_TXT="DETENER Y ELIMINAR SERVICIO"
    elif [[ -f "$MIRROR_SVC" ]]; then
        STATUS_MIRROR="${C_ROJO}DETENIDO (Servicio Existe)${C_RESET}"
        ACT_CODE=2
        OPT_TXT="ELIMINAR SERVICIO EXISTENTE"
    else
        STATUS_MIRROR="${C_ROJO}DESACTIVADO${C_RESET}"
        ACT_CODE=1
        OPT_TXT="CREAR E INICIAR PUERTO CLON (Systemd)"
    fi

    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CLONADOR DE PUERTOS (SOCAT SYSTEMD) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if [[ "$ACT_CODE" == "2" ]]; then
            echo -e " ESTADO: $STATUS_MIRROR"
            echo -e " CLON: ${C_DATO}Puerto $P_OPEN imita al $P_TARGET${C_RESET}"
        else
             echo -e " ESTADO: $STATUS_MIRROR"
             echo -e " NOTA: Aseg�rate que el Puerto $P_TARGET est� activo (ej: Python Socket en 80)."
        fi
        
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > $OPT_TXT${C_RESET}"
        if systemctl is-active --quiet socat-mirror; then
             echo -e " ${C_DATO}[2] > REINICIAR SERVICIO CLON${C_RESET}"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op

        case $op in
            1)
                if [[ "$ACT_CODE" == "2" ]]; then
                    # DETENER Y ELIMINAR
                    systemctl stop socat-mirror
                    systemctl disable socat-mirror 2>/dev/null
                    rm -f "$MIRROR_SVC"
                    systemctl daemon-reload
                    iptables -D INPUT -p tcp --dport $P_OPEN -j ACCEPT 2>/dev/null
                    fun_save_iptables >/dev/null 2>&1
                    echo -e "${C_ROJO} Servicio de Clonaci�n Eliminado.${C_RESET}"
                    sleep 2
                else
                    # CREAR E INICIAR
                    if ! command -v socat &> /dev/null; then
                        echo -e " ${C_DATO}Instalando socat...${C_RESET}"
                        apt-get install socat -y > /dev/null 2>&1
                    fi

                    echo -e "\n ${C_DATO}--- CONFIGURACION ---${C_RESET}"
                    echo -n " Puerto ORIGINAL (El que da el 101) [Default 80]: "
                    read P_ORIG
                    [[ -z "$P_ORIG" ]] && P_ORIG=80
                    
                    echo -n " Puerto NUEVO (El que usar� tu App) [Default 90]: "
                    read P_NEW
                    [[ -z "$P_NEW" ]] && P_NEW=90

                    # 1. Crear el archivo de servicio
                    cat <<EOF > "$MIRROR_SVC"
[Unit]
Description=Socat Port Mirror $P_NEW -> $P_ORIG
After=network.target

[Service]
Type=simple
# El puerto de entrada escucha y reenv�a al puerto original (loopback 127.0.0.1)
ExecStart=/usr/bin/socat TCP-LISTEN:$P_NEW,fork,reuseaddr TCP:127.0.0.1:$P_ORIG
Restart=always
RestartSec=3
User=root

[Install]
WantedBy=multi-user.target
EOF

                    # 2. Abrir Firewall
                    iptables -I INPUT -p tcp --dport $P_NEW -j ACCEPT
                    fun_save_iptables >/dev/null 2>&1
                    
                    # 3. Iniciar Servicio
                    systemctl daemon-reload
                    systemctl enable socat-mirror >/dev/null 2>&1
                    systemctl restart socat-mirror
                    
                    echo -e "${C_VERDE} �CLON CREADO CON �XITO!${C_RESET}"
                    echo -e " El Puerto $P_NEW (TCP) ahora imita al Puerto $P_ORIG."
                    echo -e " RECUERDA: Abre el puerto $P_NEW en el Firewall Externo (Nube)."
                    sleep 3
                fi
                ;;
            2)
                if systemctl is-active --quiet socat-mirror; then
                    systemctl restart socat-mirror
                    echo -e "${C_VERDE} Servicio Reiniciado.${C_RESET}"
                    sleep 1
                fi
                ;;
            0) break ;;
        esac
    done
}

# --- NUEVA FUNCI�N DE VERIFICACI�N UNIVERSAL ---
is_installed() {
    local pkg=$1
    if command -v dpkg &> /dev/null; then
        dpkg -s "$pkg" &> /dev/null
    elif command -v rpm &> /dev/null; then
        rpm -q "$pkg" &> /dev/null
    else
        command -v "$pkg" &> /dev/null
    fi
}

# --- INSTALADOR VLESS REALITY (REPARADO POR REAGENS PRO) ---
install_xray_reality() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} INSTALADOR VLESS REALITY (SIN DOMINIO) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"

    # 1. Verificar si Xray est� instalado
    if [[ ! -f "/usr/local/bin/xray" ]]; then
        echo -e " ${C_DATO}[+] Instalando Xray Core...${C_RESET}"
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install --force > /dev/null 2>&1
    fi

    # 2. Datos de Configuraci�n
    echo -n " Puerto para Reality [Default 443]: "
    read R_PORT
    [[ -z "$R_PORT" ]] && R_PORT=443
    fun_check_port $R_PORT "VLESS Reality" || return

    echo -n " SNI de Destino [Default www.microsoft.com]: "
    read R_SNI
    [[ -z "$R_SNI" ]] && R_SNI="www.microsoft.com"

    # 3. Generaci�n de Seguridad
    echo -e " ${C_DATO}[+] Generando llaves de cifrado X25519...${C_RESET}"
    KEYS=$(/usr/local/bin/xray x25519)
    PRIV=$(echo "$KEYS" | grep "Private" | awk '{print $3}')
    PUB=$(echo "$KEYS" | grep "Public" | awk '{print $3}')
    SID=$(openssl rand -hex 4)
    UUID_R=$(uuidgen)

    # Guardar llave p�blica para el Panel Web
    mkdir -p /etc/reagens
    echo "$PUB" > /etc/reagens/reality_pub

    # 4. Construcci�n del JSON
    cat <<EOF > /usr/local/etc/xray/config.json
{
  "log": { "loglevel": "warning" },
  "inbounds": [
    {
      "port": $R_PORT,
      "protocol": "vless",
      "settings": {
        "clients": [
          {
            "id": "$UUID_R",
            "flow": "xtls-rprx-vision",
            "email": "admin"
          }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "$R_SNI:443",
          "xver": 0,
          "serverNames": ["$R_SNI"],
          "privateKey": "$PRIV",
          "shortIds": ["$SID"]
        }
      }
    }
  ],
  "outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "blackhole", "tag": "blocked" }
  ]
}
EOF

    # 5. Reinicio y Firewall
    fuser -k $R_PORT/tcp >/dev/null 2>&1
    iptables -I INPUT -p tcp --dport $R_PORT -j ACCEPT
    fun_save_iptables >/dev/null 2>&1
    
    systemctl restart xray
    systemctl enable xray >/dev/null 2>&1

    # 6. Registro para el Panel
    mkdir -p /etc/reagens/users/v2ray
    echo "EXP=$(date -d '+30 days' +%Y-%m-%d)" > "/etc/reagens/users/v2ray/admin"
    echo "UUID=$UUID_R" >> "/etc/reagens/users/v2ray/admin"

    # 7. Mostrar Resultados
    IP=$(curl -s ipv4.icanhazip.com)
    LINK_R="vless://$UUID_R@$IP:$R_PORT?security=reality&encryption=none&pbk=$PUB&headerType=none&fp=chrome&type=tcp&sni=$R_SNI&sid=$SID&flow=xtls-rprx-vision#REAGENS-REALITY"

    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e "${C_VERDE} �REALITY INSTALADO CORRECTAMENTE!${C_RESET}"
    echo -e " ${C_TEXTO}Puerto: ${C_DATO}$R_PORT${C_RESET}"
    echo -e " ${C_TEXTO}Public Key: ${C_DATO}$PUB${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_VERDE}LINK DE CONEXION:${C_RESET}"
    echo -e "$LINK_R"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Presione Enter para volver..."
}

menu_ajustes_puertos() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} AJUSTES DE PUERTOS Y PROTOCOLOS ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # --- CHEQUEOS DE ESTADO UNIVERSALES (CORREGIDO) ---
        s_py=$(systemctl is-active --quiet ws-reagens && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        s_epro=$(systemctl is-active --quiet ws-epro && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        s_bad=$(systemctl is-active --quiet badvpn && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        s_v2=$(systemctl is-active --quiet xray && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        s_dns=$(systemctl is-active --quiet slowdns-server && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        s_udp=$(systemctl is-active --quiet udp-custom && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")

        # Chequeo SSL (Stunnel)
        if is_installed stunnel4 || is_installed stunnel; then s_ssl="${C_VERDE}ON${C_RESET}"; else s_ssl="${C_ROJO}OFF${C_RESET}"; fi
        # Chequeo Dropbear
        if is_installed dropbear; then s_db="${C_VERDE}ON${C_RESET}"; else s_db="${C_ROJO}OFF${C_RESET}"; fi
         
        # --- DISE�O DEL MEN� ---
        echo -e " ${C_TEXTO}[1] > PYTHON SOCKET (Simple 80->22) [$s_py]${C_RESET}"
        echo -e " ${C_DATO}[2] > WS-EPRO (Avanzado Multi-Port) [$s_epro]${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[3] > SSL / STUNNEL4                 [$s_ssl]${C_RESET}"
        echo -e " ${C_TEXTO}[4] > BADVPN UDP GATEWAY             [$s_bad]${C_RESET}"
        echo -e " ${C_TEXTO}[5] > DROPBEAR SSH                    [$s_db]${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[6] > INSTALADOR XRAY / V2RAY         [$s_v2]${C_RESET}"
        echo -e " ${C_DATO}[7] > FORCE EMERGENCIA (Smart Recovery)${C_RESET}"
        echo -e " ${C_VERDE}[8] > SLOWDNS (DNS TUNNEL)             [$s_dns]${C_RESET}"
        echo -e " ${C_DATO}[9] > VLESS REALITY (UNIVERSAL)       [$s_v2]${C_RESET}"
        echo -e " ${C_VERDE}[10]> UDP-CUSTOM (HTTP CUSTOM)          [$s_udp]${C_RESET}" # <--- LINEA AGREGADA
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU ANTERIOR${C_RESET}"
        
        echo -ne "\n Opcion: "
        read op_proto
        
        case $op_proto in 
            1) fun_python_sock ;; 
            2) fun_ws_epro_menu ;; 
            3) fun_ssl_menu ;; 
            4) fun_badvpn_menu ;; 
            5) fun_dropbear_menu ;; 
            6) proto_v2ray_manager ;; 
            7) fun_force_smart ;;
            8) fun_slowdns_menu ;;
            9) install_xray_reality ;;
            10) fun_udp_custom ;; # <--- ACCI�N AGREGADA
            0) break ;;
            *) echo -e "${C_ROJO}Opcion Invalida${C_RESET}"; sleep 1 ;;
        esac
    done
}

fun_limpiar_ram_exec() { 
    sync
    echo 3 > /proc/sys/vm/drop_caches
    echo -e "${C_VERDE} Memoria RAM Liberada.${C_RESET}"
    sleep 1
}

# --- NUEVA FUNCION ZRAM (COMPRESION DE MEMORIA) ---
fun_activar_zram() {
    clear
    msg_center " OPTIMIZADOR DE MEMORIA (ZRAM UNIFICADO) "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if [[ -f /etc/redhat-release ]]; then
        echo -e " ${C_DATO}Configurando ZRAM para RHEL/CentOS/Alma...${C_RESET}"
        yum install -y zram-generator >/dev/null 2>&1
        cat <<EOF > /etc/systemd/zram-generator.conf
[zram0]
zram-size = ram / 2
compression-algorithm = lz4
EOF
        systemctl daemon-reload
        systemctl start /dev/zram0
    else
        echo -e " ${C_DATO}Configurando ZRAM para Debian/Ubuntu...${C_RESET}"
        apt-get install zram-tools -y >/dev/null 2>&1
        echo -e "ALGO=lz4\nPERCENT=50" > /etc/default/zramswap
        service zramswap reload || systemctl restart zramswap
    fi
    echo -e "${C_VERDE} ZRAM ACTIVADO (50% de tu RAM comprimida).${C_RESET}"
    sleep 3
}

fun_auto_ram_config() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LIMPIEZA AUTOMATICA DE RAM (CRON) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] Cada 1 Hora"
    echo -e " [2] Cada 6 Horas"
    echo -e " [3] Cada 12 Horas"
    echo -e " [4] Todos los dias a las 00:00"
    echo -e " [5] Desactivar limpieza autom�tica"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read tr
    
    # Definir comando de limpieza
    CMD_CLEAN="sync; echo 3 > /proc/sys/vm/drop_caches"
    
    # Eliminar tareas previas de limpieza
    (crontab -l 2>/dev/null | grep -v "drop_caches") | crontab -
    
    case $tr in
        1)
            (crontab -l 2>/dev/null; echo "0 * * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Cada 1 Hora.${C_RESET}"
            ;;
        2)
            (crontab -l 2>/dev/null; echo "0 */6 * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Cada 6 Horas.${C_RESET}"
            ;;
        3)
            (crontab -l 2>/dev/null; echo "0 */12 * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Cada 12 Horas.${C_RESET}"
            ;;
        4)
            (crontab -l 2>/dev/null; echo "0 0 * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Diario a las 00:00.${C_RESET}"
            ;;
        5)
            echo -e "${C_ROJO} Limpieza autom�tica desactivada.${C_RESET}"
            ;;
        *) echo "Invalido" ;;
    esac
    sleep 2
}

# --- MENU GESTION RAM ACTUALIZADO ---
menu_gestion_ram() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION DE MEMORIA RAM ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1] > LIMPIAR RAM AHORA (MANUAL)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > CONFIGURAR LIMPIEZA AUTOMATICA${C_RESET}"
        echo -e " ${C_DATO}[3] > INSTALAR ZRAM (MEMORIA COMPRIMIDA)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU ANTERIOR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op_r
        case $op_r in
            1) fun_limpiar_ram_exec ;;
            2) fun_auto_ram_config ;;
            3) fun_activar_zram ;;
            0) break ;;
        esac
    done
}

fun_acelerador() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} ACELERADOR DE RED (BBR + SYSCTL) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Aplicando configuraciones de optimizaci�n TCP..."
    cp /etc/sysctl.conf /etc/sysctl.conf.bak
    sed -i '/net.core.default_qdisc/d' /etc/sysctl.conf
    sed -i '/net.ipv4.tcp_congestion_control/d' /etc/sysctl.conf
    echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf
    echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf
    sysctl -p > /dev/null 2>&1
    echo -e "${C_VERDE} �Sistema Optimizado Exitosamente!${C_RESET}"
    sleep 2
}

fun_activar_root() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} ACTIVAR ACCESO ROOT Y CAMBIAR CLAVE ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Esto habilitar� el acceso directo por SSH al usuario 'root'"
    echo -e " y te pedir� una nueva clave."
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Ingrese NUEVA CLAVE para ROOT: "
    read pass
    if [[ -z "$pass" ]]; then 
        echo -e "${C_ROJO} clave vacia. Cancelado.${C_RESET}"
        sleep 2
        return
    fi
    
    echo "root:$pass" | chpasswd
    sed -i 's/#PermitRootLogin/PermitRootLogin/g' /etc/ssh/sshd_config
    sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/g' /etc/ssh/sshd_config
    sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/g' /etc/ssh/sshd_config
    sed -i 's/PermitRootLogin no/PermitRootLogin yes/g' /etc/ssh/sshd_config
    sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_config
    
    service ssh restart > /dev/null 2>&1
    service sshd restart > /dev/null 2>&1
    
    echo -e "${C_VERDE} �Acceso Root Activado y Clave Cambiada!${C_RESET}"
    sleep 2
}

menu_guardian() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MONITOR DE SEGURIDAD (GUARDIAN) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        if systemctl is-active --quiet reagens-guard; then G_ST="${C_VERDE}ACTIVO${C_RESET}"; else G_ST="${C_ROJO}DETENIDO${C_RESET}"; fi
        echo -e " ESTADO ACTUAL: $G_ST"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > ACTIVAR / REINICIAR GUARDIAN${C_RESET}"
        echo -e " ${C_TEXTO}[2] > DETENER Y DESACTIVAR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op_g
        case $op_g in
            1)
                echo -e " ${C_DATO}[+] Instalando Guardian Multiversal (SSH + TOKENS)...${C_RESET}"
                
                # --- INICIO DEL SCRIPT DEL GUARDIAN ---
                cat << 'EOF' > "$GUARD_BIN"
#!/bin/bash
# Rutas de Bases de Datos
DB_SSH="/etc/adm-lite/usuarios_ssh.db"
DB_TOKENS="/etc/adm-lite/usuarios_token.db"
DB_V2RAY="/etc/reagens/users/v2ray"
V2_CONF="/usr/local/etc/xray/config.json"

while true; do
    # 1. ESCANEO INDEPENDIENTE: USUARIOS SSH
    if [[ -f "$DB_SSH" ]]; then
        while IFS='|' read -r user pass exp limit_conn limit_mb; do
            if id "$user" &>/dev/null && [[ "$limit_conn" -gt 0 ]]; then
                conx_act=$(pgrep -u "$user" -f "sshd|dropbear" | wc -l)
                if [[ "$conx_act" -gt "$limit_conn" ]]; then
                    # Mantiene las conexiones viejas y mata las que exceden el l�mite
                    kill -9 $(ps -u "$user" --sort=-start_time | grep -E 'sshd|dropbear' | tail -n +$((limit_conn + 1)) | awk '{print $1}') >/dev/null 2>&1
                fi
            fi
        done < "$DB_SSH"
    fi

    # 2. ESCANEO INDEPENDIENTE: TOKENS ID (APP)
    if [[ -f "$DB_TOKENS" ]]; then
        while IFS='|' read -r user_t cliente_t exp_t mb_t; do
            if id "$user_t" &>/dev/null; then
                # Por defecto, el limite para Tokens de App es 1 conexi�n simult�nea
                limit_token=1 
                conx_token=$(pgrep -u "$user_t" -f "sshd|dropbear" | wc -l)
                if [[ "$conx_token" -gt "$limit_token" ]]; then
                    # Mata intentos de multi-login en la App
                    kill -9 $(ps -u "$user_t" --sort=-start_time | grep -E 'sshd|dropbear' | tail -n +$((limit_token + 1)) | awk '{print $1}') >/dev/null 2>&1
                fi
            fi
        done < "$DB_TOKENS"
    fi

    # 3. ESCANEO V2RAY / XRAY (Vencimientos)
    if [[ -d "$DB_V2RAY" ]]; then
        hoy=$(date +%Y%m%d)
        for f in "$DB_V2RAY"/*; do
            if [[ -f "$f" ]]; then
                u_v2=$(basename "$f")
                [[ "$u_v2" == "v2ray" ]] && continue
                source "$f" 2>/dev/null
                if [[ ! -z "$EXP" ]]; then
                    vence_v2=$(date -d "$EXP" +%Y%m%d 2>/dev/null)
                    if [[ ! -z "$vence_v2" && "$hoy" -gt "$vence_v2" ]]; then
                        # Eliminar de la configuraci�n de Xray sin tocar otros usuarios
                        jq --arg e "$u_v2" 'del(.inbounds[].settings.clients[] | select(.email == $e))' "$V2_CONF" > "$V2_CONF.tmp" && mv "$V2_CONF.tmp" "$V2_CONF"
                        systemctl restart xray
                        rm -f "$f"
                    fi
                fi
            fi
        done
    fi
    
    sleep 15
done
EOF
                chmod +x "$GUARD_BIN"
cat <<EOF > /etc/systemd/system/reagens-guard.service
[Unit]
Description=Guard Reagens
After=network.target
[Service]
ExecStart=$GUARD_BIN
Restart=always
[Install]
WantedBy=multi-user.target
EOF
                systemctl daemon-reload
                systemctl enable reagens-guard
                systemctl restart reagens-guard
                echo -e "${C_VERDE}Activado.${C_RESET}"
                sleep 2
                ;;
            2)
                systemctl stop reagens-guard
                systemctl disable reagens-guard
                rm -f /etc/systemd/system/reagens-guard.service
                systemctl daemon-reload
                echo -e "${C_ROJO}Desactivado.${C_RESET}"
                sleep 2
                ;;
            0) break ;;
        esac
    done
}

# --- SISTEMA CHECKUSER PROFESIONAL REAGENS (CORRECCI�N DE SINTAXIS) ---
menu_checkuser() {
    local CHECKUSER_BIN="/etc/reagens/bin/checkuser.py"
    local CHECKUSER_SERVICE="/etc/systemd/system/checkuser-reagens.service"
    local PREFS_FILE="/etc/reagens/checkuser_prefs"

    # --- FUNCI�N DE L�GICA DE INSTALACI�N ---
    fun_instalar_cu_logic() {
        local p=$1
        local f=$2
        local t=$3

        echo -e " ${C_DATO}[+] Limpiando puerto $p y preparando entorno...${C_RESET}"
        systemctl stop checkuser-reagens &>/dev/null
        fuser -k $p/tcp &>/dev/null 2>/dev/null
        sleep 1

        mkdir -p /etc/reagens/bin
        # Escribimos el script Python con placeholders limpios
        cat << 'PYTHON_EOF' > /etc/reagens/bin/checkuser.py
import os, sys, json
from datetime import datetime
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse, parse_qs

# Variables inyectadas
PORT = __PORT__
FMT = "__FMT__"
TYPE = "__TYPE__"
DB_TOKENS = "/etc/adm-lite/usuarios_token.db"
DB_SSH = "/etc/adm-lite/usuarios_ssh.db"

class UniversalHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        query = parse_qs(urlparse(self.path).query)
        # Soporta user, username o id
        user = query.get('user', query.get('username', query.get('id', [''])))[0]
        if not user and query: user = list(query.keys())[0]

        res_days = "0"
        if user:
            for db_path in [DB_TOKENS, DB_SSH]:
                if os.path.exists(db_path):
                    try:
                        with open(db_path, 'r', errors='ignore') as f:
                            for line in f:
                                parts = line.strip().split('|')
                                if parts[0] == user:
                                    if FMT == "DAYS":
                                        res_days = str(parts[2])
                                    else:
                                        # Calculo de dias restantes
                                        dt = datetime.strptime(parts[2], FMT)
                                        diff = dt - datetime.now()
                                        res_days = str(max(0, diff.days + 1))
                                    break
                    except: pass
                if res_days != "0": break

        self.send_response(200)
        self.send_header('Content-type', 'application/json' if TYPE == "JSON" else 'text/plain')
        self.end_headers()
        response = json.dumps({"days": res_days}) if TYPE == "JSON" else res_days
        self.wfile.write(response.encode('utf-8'))

    def log_message(self, format, *args): return

if __name__ == '__main__':
    try:
        httpd = HTTPServer(('0.0.0.0', PORT), UniversalHandler)
        httpd.serve_forever()
    except: sys.exit(1)
PYTHON_EOF

        # --- INYECCI�N SEGURA (CORREGIDO) ---
        # Quitamos las comillas extra en el sed porque el template ya las tiene
        sed -i "s|__PORT__|$p|" /etc/reagens/bin/checkuser.py
        sed -i "s|__FMT__|$f|" /etc/reagens/bin/checkuser.py
        sed -i "s|__TYPE__|$t|" /etc/reagens/bin/checkuser.py

        cat <<EOF > "$CHECKUSER_SERVICE"
[Unit]
Description=Reagens Universal CheckUser
After=network.target

[Service]
ExecStart=/usr/bin/python3 $CHECKUSER_BIN
Restart=always
RestartSec=5
User=root

[Install]
WantedBy=multi-user.target
EOF

        systemctl daemon-reload
        systemctl enable checkuser-reagens &>/dev/null
        systemctl start checkuser-reagens
        
        echo -e " ${C_DATO}[+] Verificando activaci�n...${C_RESET}"
        sleep 3
        
        if systemctl is-active --quiet checkuser-reagens; then
            echo -e "${C_VERDE} [OK] CheckUser Activado en puerto $p.${C_RESET}"
            sleep 2
        else
            echo -e "${C_ROJO} [ERROR] El servicio no inici� correctamente.${C_RESET}"
            echo -e "${C_TEXTO} Diagn�stico de error:${C_RESET}"
            /usr/bin/python3 $CHECKUSER_BIN 2>&1 | head -n 5
            read -p "Presione Enter para continuar..."
        fi
    }

    # --- INTERFAZ DEL MEN� ---
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTOR CHECKUSER PROFESIONAL ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if systemctl is-active --quiet checkuser-reagens; then
            source "$PREFS_FILE" 2>/dev/null
            echo -e " ESTADO   : ${C_VERDE}ONLINE / ACTIVO${C_RESET}"
            echo -e " PUERTO   : ${C_DATO}${CU_PORT:-6888}${C_RESET} | SALIDA: ${C_DATO}${CU_TYPE:-DIRECT}${C_RESET}"
            echo -e " FORMATO  : ${C_DATO}${CU_FMT:-YYYY-MM-DD}${C_RESET}"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > DESINSTALAR CHECKUSER${C_RESET}"
            echo -e " ${C_TEXTO}[2] > REINICIAR SERVICIO${C_RESET}"
            echo -e " ${C_TEXTO}[3] > EDITAR AJUSTES${C_RESET}"
        else
            echo -e " ESTADO   : ${C_ROJO}DESACTIVADO / ERROR${C_RESET}"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > INSTALAR / REPARAR CHECKUSER${C_RESET}"
        fi
        
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -ne "\n Opcion: "
        read op_cu

        case $op_cu in
            1)
                if systemctl is-active --quiet checkuser-reagens; then
                    systemctl stop checkuser-reagens &>/dev/null
                    systemctl disable checkuser-reagens &>/dev/null
                    rm -f "$CHECKUSER_SERVICE" "$CHECKUSER_BIN" "$PREFS_FILE"
                    echo -e "${C_ROJO}CheckUser eliminado.${C_RESET}"; sleep 2
                else
                    echo -n " Puerto [Ej: 6888]: "
                    read p_cu
                    [[ -z "$p_cu" ]] && p_cu=6888
                    echo -e "\n [1] DD/MM/YYYY | [2] MM/DD/YYYY | [3] YYYY-MM-DD | [4] DIAS"
                    read f_opt
                    case $f_opt in
                        1) f_date="%d/%m/%Y" ;; 2) f_date="%m/%d/%Y" ;; 3) f_date="%Y-%m-%d" ;; *) f_date="DAYS" ;;
                    esac
                    echo -e "\n [1] DIRECTO (Jenken) | [2] JSON"
                    read t_opt
                    [[ "$t_opt" == "2" ]] && r_type="JSON" || r_type="DIRECT"
                    echo -e "CU_PORT=$p_cu\nCU_FMT=$f_date\nCU_TYPE=$r_type" > "$PREFS_FILE"
                    fun_instalar_cu_logic "$p_cu" "$f_date" "$r_type"
                fi
                ;;
            2) systemctl restart checkuser-reagens; echo "Reiniciado."; sleep 2 ;;
            3)
                if [[ -f "$PREFS_FILE" ]]; then
                    source "$PREFS_FILE"
                    echo -n " Nuevo Puerto [$CU_PORT]: "
                    read n_port
                    [[ -z "$n_port" ]] && n_port=$CU_PORT
                    echo -e " Nuevo Formato: [1] DD/MM/YYYY [2] MM/DD/YYYY [3] YYYY-MM-DD [4] DIAS"
                    read n_f_opt
                    case $n_f_opt in
                        1) n_date="%d/%m/%Y" ;; 2) n_date="%m/%d/%Y" ;; 3) n_date="%Y-%m-%d" ;; 4) n_date="DAYS" ;; *) n_date=$CU_FMT ;;
                    esac
                    echo -e " Nueva Salida: [1] DIRECTO | [2] JSON"
                    read n_t_opt
                    [[ "$n_t_opt" == "2" ]] && n_type="JSON" || n_type="DIRECT"
                    echo -e "CU_PORT=$n_port\nCU_FMT=$n_date\nCU_TYPE=$n_type" > "$PREFS_FILE"
                    fun_instalar_cu_logic "$n_port" "$n_date" "$n_type"
                fi
                ;;
            0) break ;;
        esac
    done
}

submenu_fecha_hora() {
    while true; do 
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CONFIGURAR ZONA HORARIA MUNDIAL ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_DATO}Escriba parte del nombre de su Continente o Ciudad.${C_RESET}"
        echo -e " ${C_TEXTO}Ejemplos: America, Madrid, Mexico, Tokyo, Paris${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > BUSCAR Y SELECCIONAR${C_RESET}"
        echo -e " ${C_TEXTO}[2] > MOSTRAR TODAS LAS ZONAS (Larga lista)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1)
                echo -n " Busqueda (Ej: America): "
                read query
                if [[ -z "$query" ]]; then continue; fi
                
                # Crear array con resultados
                mapfile -t zonas < <(timedatectl list-timezones | grep -i "$query")
                
                if [[ ${#zonas[@]} -eq 0 ]]; then
                    echo -e "${C_ROJO}No se encontraron resultados.${C_RESET}"
                    sleep 2
                else
                    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
                    i=1
                    for z in "${zonas[@]}"; do
                        echo -e " [$i] $z"
                        ((i++))
                    done
                    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
                    echo -n " Seleccione Numero: "
                    read num
                    if [[ "$num" -gt 0 && "$num" -le "${#zonas[@]}" ]]; then
                        sel_zone="${zonas[$((num-1))]}"
                        timedatectl set-timezone "$sel_zone"
                        echo -e "${C_VERDE}Zona cambiada a: $sel_zone${C_RESET}"
                        echo -e "Hora actual: $(date)"
                        sleep 3
                        break
                    else
                        echo -e "${C_ROJO}Numero invalido.${C_RESET}"
                        sleep 1
                    fi
                fi
                ;;
            2)
                timedatectl list-timezones | less
                ;;
            0) break ;;
        esac
    done
}

# ==================================================
# GESTOR SSL REPARADO (REEMPLAZA TU FUNCI�N ANTIGUA)
# ==================================================
# ==================================================
# GESTOR SSL MULTIVERSAL (UBUNTU/DEBIAN/CENTOS/ALMA/ROCKY)
# ==================================================
# ==================================================
# GESTOR SSL MULTIVERSAL - VERSI�N ULTRA-COMPATIBLE
# ==================================================
fun_cert_manager() {
    clear
    CERT_DIR="/etc/reagens/cert"
    mkdir -p "$CERT_DIR"

    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTOR SSL PRO (ACME.SH + FIREWALL FIX) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if [[ -f "$CERT_DIR/public.crt" ]]; then
            echo -e " ${C_VERDE}[CERTIFICADO ACTIVO]${C_RESET}"
            echo -e " Dominio: $(openssl x509 -noout -subject -in $CERT_DIR/public.crt 2>/dev/null | sed 's/.*CN = //')"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        fi
        
        echo -e " ${C_TEXTO}[1] > GENERAR CERTIFICADO (AUTO-FIX FIREWALL)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > VER CONTENIDO DE LLAVES${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op_ssl

        case $op_ssl in
            1)
                clear
                echo -e " ${C_DATO}[+] Preparando entorno de validaci�n...${C_RESET}"
                
                # 1. INSTALAR DEPENDENCIAS Y ACTIVAR CRON
                if [[ -f /etc/redhat-release ]]; then
                    yum install socat tar gzip cronie psmisc -y &>/dev/null
                    systemctl enable cronie &>/dev/null
                    systemctl start cronie &>/dev/null
                    # DESACTIVAR SELINUX TEMPORALMENTE (Solo en RHEL/Alma)
                    setenforce 0 &>/dev/null
                else
                    apt-get update &>/dev/null
                    apt-get install socat tar gzip cron psmisc -y &>/dev/null
                    systemctl start cron &>/dev/null
                fi

                # 2. ABRIR PUERTO 80 EN EL FIREWALL DEL SISTEMA (ESENCIAL PARA ALMA/CENTOS)
                if command -v firewall-cmd &>/dev/null; then
                    firewall-cmd --add-port=80/tcp --permanent &>/dev/null
                    firewall-cmd --add-port=443/tcp --permanent &>/dev/null
                    firewall-cmd --reload &>/dev/null
                fi
                if command -v ufw &>/dev/null; then
                    ufw allow 80/tcp &>/dev/null
                    ufw allow 443/tcp &>/dev/null
                fi

                echo -n " Ingrese su Dominio: "
                read DOMINIO
                [[ -z "$DOMINIO" ]] && continue

                # 3. LIMPIEZA AGRESIVA DEL PUERTO 80
                echo -e " ${C_DATO}[!] Forzando liberaci�n del puerto 80...${C_RESET}"
                systemctl stop xray v2ray nginx apache2 httpd rvp-panel stunnel4 &>/dev/null
                fuser -k 80/tcp &>/dev/null
                fuser -k 80/tcp &>/dev/null # Doble limpieza
                sleep 2

                # 4. MOTOR ACME
                ACME_BIN="$HOME/.acme.sh/acme.sh"
                if [[ ! -f "$ACME_BIN" ]]; then
                    curl https://get.acme.sh | sh -s email=admin@$DOMINIO &>/dev/null
                fi
                
                # 5. VALIDACI�N (FORZANDO IPV4 PARA EVITAR ERRORES DE RED)
                echo -e " ${C_VERDE}[+] Solicitando a Let's Encrypt...${C_RESET}"
                "$ACME_BIN" --set-default-ca --server letsencrypt &>/dev/null
                # A�adimos --listen-v4 para evitar problemas con IPv6 mal configurados
                "$ACME_BIN" --issue -d "$DOMINIO" --standalone --keylength ec-256 --force --listen-v4

                # REINTENTO CON ZEROSSL SI FALLA
                if [[ ! -f "$HOME/.acme.sh/${DOMINIO}_ecc/${DOMINIO}.cer" ]]; then
                    echo -e "${C_DATO}[!] Reintentando con ZeroSSL...${C_RESET}"
                    "$ACME_BIN" --register-account -m admin@$DOMINIO --server zerossl &>/dev/null
                    "$ACME_BIN" --issue -d "$DOMINIO" --standalone --server zerossl --keylength ec-256 --force --listen-v4
                fi

                # 6. INSTALACI�N FINAL
                if [[ -f "$HOME/.acme.sh/${DOMINIO}_ecc/${DOMINIO}.cer" ]]; then
                    mkdir -p "$CERT_DIR"
                    "$ACME_BIN" --installcert -d "$DOMINIO" --ecc \
                        --fullchain-file "$CERT_DIR/public.crt" \
                        --key-file "$CERT_DIR/private.key" &>/dev/null
                    chmod 644 "$CERT_DIR"/*
                    echo -e "${C_VERDE} �CERTIFICADO GENERADO EXITOSAMENTE!${C_RESET}"
                else
                    echo -e "${C_ROJO} [X] ERROR CRITICO: La validaci�n fall�.${C_RESET}"
                    echo -e " ${C_DATO}CAUSA PROBABLE:${C_RESET} Si usas Google Cloud, AWS, Azure u Oracle,"
                    echo -e " debes abrir el PUERTO 80 en el panel de tu proveedor (Security Groups)."
                fi
                
                # Restaurar SELinux y reiniciar Xray
                [[ -f /etc/redhat-release ]] && setenforce 1 &>/dev/null
                systemctl start xray &>/dev/null
                read -p " Enter para continuar..."
                ;;
            2)
                # (Mantener igual que antes para ver las llaves)
                if [[ -f "$CERT_DIR/public.crt" ]]; then
                    clear
                    echo -e "--- CRT PUBLICO ---"
                    cat "$CERT_DIR/public.crt"
                    echo -e "\n--- KEY PRIVADA ---"
                    cat "$CERT_DIR/private.key"
                    read -p "Enter..."
                fi
                ;;
            0) break ;;
        esac
    done
}

# ==================================================
# MODULO ADBLOCK (DNSMASQ) - LIMPIEZA PUBLICIDAD
# ==================================================

fun_adblock_manager() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} ADBLOCK PRO (DNSMASQ) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # Verificar estado
        if pgrep "dnsmasq" > /dev/null; then
            STATUS_ADB="${C_VERDE}ACTIVO (Protegiendo)${C_RESET}"
            # Contar dominios bloqueados
            if [[ -f "/etc/reagens/adblock.hosts" ]]; then
                CNT=$(wc -l < /etc/reagens/adblock.hosts)
                INFO_L="Dominios en Blacklist: ${C_DATO}$CNT${C_RESET}"
            else
                INFO_L="Lista vac�a."
            fi
        else
            STATUS_ADB="${C_ROJO}DETENIDO / NO INSTALADO${C_RESET}"
            INFO_L=""
        fi

        echo -e " ESTADO: $STATUS_ADB"
        echo -e " $INFO_L"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[1] > INSTALAR Y ACTIVAR ADBLOCK${C_RESET}"
        echo -e " ${C_DATO}[2] > ACTUALIZAR LISTA DE BLOQUEO (Anti-Ads)${C_RESET}"
        echo -e " ${C_DATO}[3] > DESACTIVAR Y ELIMINAR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op

        case $op in
            1)
                echo -e " ${C_DATO}Instalando DNSMasq...${C_RESET}"
                apt-get update >/dev/null 2>&1
                apt-get install dnsmasq -y >/dev/null 2>&1

                echo -e " ${C_DATO}Descargando Lista Negra (100k+ dominios)...${C_RESET}"
                mkdir -p /etc/reagens
                # Usamos la lista de StevenBlack unificada (Ads + Malware)
                wget -q https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts -O /etc/reagens/adblock.hosts
                
                # Configurar DNSMasq
                echo -e " ${C_DATO}Configurando Rutas DNS...${C_RESET}"
                mv /etc/dnsmasq.conf /etc/dnsmasq.conf.bak 2>/dev/null
                
                cat <<EOF > /etc/dnsmasq.conf
port=5353
listen-address=127.0.0.1
bind-interfaces
server=8.8.8.8
server=1.1.1.1
domain-needed
bogus-priv
no-resolv
no-poll
cache-size=10000
addn-hosts=/etc/reagens/adblock.hosts
EOF
                # NOTA: Usamos puerto 5353 para evitar conflicto con SlowDNS/Systemd
                # Pero forzamos al sistema a usarlo mediante iptables o resolv personalizado
                
                # Modificar resolv.conf para que el VPS use nuestro DNS local
                # Primero hacemos backup
                cp /etc/resolv.conf /etc/resolv.conf.bak
                echo "nameserver 127.0.0.1" > /etc/resolv.conf
                
                # Reiniciar servicio
                service dnsmasq restart
                
                # --- TRUCO MAGICO: Redirigir consultas locales al 5353 ---
                # Esto evita choque con SlowDNS que usa el 53
                iptables -t nat -I OUTPUT -p udp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353
                iptables -t nat -I OUTPUT -p tcp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353
                fun_save_iptables >/dev/null 2>&1

                echo -e "${C_VERDE} ADBLOCK ACTIVADO.${C_RESET}"
                echo -e " La publicidad web ser� eliminada a nivel de servidor."
                sleep 3
                ;;
            2)
                if [[ -f "/etc/reagens/adblock.hosts" ]]; then
                    echo -e " ${C_DATO}Actualizando base de datos...${C_RESET}"
                    wget -q https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts -O /etc/reagens/adblock.hosts
                    service dnsmasq restart
                    echo -e "${C_VERDE} Lista actualizada.${C_RESET}"
                else
                    echo -e "${C_ROJO} Instale primero.${C_RESET}"
                fi
                sleep 2
                ;;
            3)
                echo -e " ${C_DATO}Restaurando DNS originales...${C_RESET}"
                # Restaurar resolv.conf a Google
                echo "nameserver 8.8.8.8" > /etc/resolv.conf
                
                # Limpiar iptables
                iptables -t nat -D OUTPUT -p udp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353 2>/dev/null
                iptables -t nat -D OUTPUT -p tcp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353 2>/dev/null
                fun_save_iptables >/dev/null 2>&1

                apt-get purge dnsmasq -y >/dev/null 2>&1
                rm -f /etc/reagens/adblock.hosts
                
                echo -e "${C_ROJO} AdBlock Eliminado. Internet restaurado.${C_RESET}"
                sleep 2
                ;;
            0) break ;;
        esac
    done
}

menu_ajustes() { 
    while true; do 
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} AJUSTES DEL SISTEMA PRO ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # CHEQUEOS VISUALES
        is_cu_sys=$(systemctl is-active --quiet checkuser-reagens.service && echo -e "${C_VERDE}[ON]${C_RESET}" || echo -e "${C_ROJO}[OFF]${C_RESET}")
        is_guard=$(systemctl is-active --quiet reagens-guard && echo -e "${C_VERDE}[ON]${C_RESET}" || echo -e "${C_ROJO}[OFF]${C_RESET}")
        
        echo -e " ${C_DATO}[1]  > AJUSTES DE PUERTOS (Protocolos)${C_RESET}"
        echo -e " ${C_VERDE}[2]  > OPTIMIZADOR GAMING (PING BAJO)${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[3]  > AJUSTES DE FECHA Y HORA (MUNDIAL)${C_RESET}"
        echo -e " ${C_TEXTO}[4]  > MENU CHECKUSER $is_cu_sys"
        echo -e " ${C_TEXTO}[5]  > MENU GUARDIAN (SEGURIDAD) $is_guard"
        echo -e " ${C_TEXTO}[6]  > ACELERADOR DE RED (BBR)${C_RESET}"
        echo -e " ${C_TEXTO}[7]  > ACTIVAR ACCESO ROOT / CAMBIAR CLAVE${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[8]  > SPEEDTEST OOKLA (VELOCIDAD)${C_RESET}"
        echo -e " ${C_DATO}[9]  > CENTRO DE SEGURIDAD PRO (ANTI-TORRENT)${C_RESET}"
        echo -e " ${C_DATO}[10] > ADBLOCK PRO (BLOQUEO ANUNCIOS)${C_RESET}"
        echo -e " ${C_VERDE}[11] > INSTALAR PANEL WEB (R-VP - PRO)${C_RESET}"
        echo -e " ${C_VERDE}[12] > GENERAR CERTIFICADO SSL (DOMINIO)${C_RESET}"
        echo -e " ${C_DATO}[13] > MANTENIMIENTO Y RESPALDO 1A${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU PRINCIPAL${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in 
            1) menu_ajustes_puertos ;;
            2) fun_gaming_pro ;;
            3) submenu_fecha_hora ;;
            4) menu_checkuser ;;
            5) menu_guardian ;;
            6) fun_acelerador ;;
            7) fun_activar_root ;;
            8) fun_speedtest ;;
            9) menu_seguridad_pro ;;
            10) fun_adblock_manager ;;
            11) fun_instalar_panel_web ;;
            12) fun_cert_manager ;;
            13) menu_mantenimiento ;;
             0) break ;;
        esac
    done 
}

# ==================================================
# MODULO DE SEGURIDAD PRO (NUEVO)
# ==================================================

# 1. ANTI-TORRENT
fun_seguridad_antitorrent() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} ANTI-TORRENT & P2P BLOCKER ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] ACTIVAR PROTECCION (Recomendado)"
    echo -e " [2] DESACTIVAR PROTECCION"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            # Limpiar primero
            iptables -D FORWARD -m string --algo bm --string "BitTorrent" -j DROP 2>/dev/null
            iptables -D OUTPUT -p tcp --dport 6881:6889 -j DROP 2>/dev/null
            
            # Aplicar reglas nuevas
            iptables -I FORWARD -m string --algo bm --string "BitTorrent" -j DROP
            iptables -I FORWARD -m string --algo bm --string "torrent" -j DROP
            iptables -I FORWARD -m string --algo bm --string "announce" -j DROP
            iptables -I FORWARD -m string --algo bm --string "info_hash" -j DROP
            iptables -I FORWARD -m string --algo bm --string "get_peers" -j DROP
            iptables -I FORWARD -m string --algo bm --string "find_node" -j DROP
            iptables -I FORWARD -m string --algo bm --string "peer_id=" -j DROP
            iptables -I OUTPUT -p tcp --dport 6881:6889 -j DROP
            iptables -I OUTPUT -p udp --dport 6881:6889 -j DROP
            
            fun_save_iptables >/dev/null 2>&1
            echo -e "${C_VERDE} PROTECCION ACTIVADA.${C_RESET}"; sleep 2 ;;
        2)
            iptables -D FORWARD -m string --algo bm --string "BitTorrent" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "torrent" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "announce" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "info_hash" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "get_peers" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "find_node" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "peer_id=" -j DROP 2>/dev/null
            iptables -D OUTPUT -p tcp --dport 6881:6889 -j DROP 2>/dev/null
            iptables -D OUTPUT -p udp --dport 6881:6889 -j DROP 2>/dev/null
            
            fun_save_iptables >/dev/null 2>&1
            echo -e "${C_ROJO} PROTECCION DESACTIVADA.${C_RESET}"; sleep 2 ;;
    esac
}

# 2. FAIL2BAN
fun_seguridad_fail2ban() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} PROTECCION FAIL2BAN (ANTI-HACK) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    if dpkg -s fail2ban >/dev/null 2>&1; then
        echo -e " ESTADO: ${C_VERDE}INSTALADO${C_RESET}"
        echo -e " [1] REINICIAR SERVICIO"
        echo -e " [2] DESINSTALAR"
    else
        echo -e " ESTADO: ${C_ROJO}NO INSTALADO${C_RESET}"
        echo -e " [1] INSTALAR Y CONFIGURAR"
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            if dpkg -s fail2ban >/dev/null 2>&1; then
                service fail2ban restart
                echo "Reiniciado."
            else
                apt-get install fail2ban -y >/dev/null 2>&1
                cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
                sed -i "/^\[sshd\]/a enabled = true" /etc/fail2ban/jail.local
                service fail2ban restart
                echo -e "${C_VERDE} INSTALADO.${C_RESET}"
            fi
            sleep 2 ;;
        2)
            apt-get remove fail2ban -y
            rm -rf /etc/fail2ban
            echo "Eliminado."; sleep 2 ;;
    esac
}

# 3. LIMITADOR
fun_seguridad_limiter() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LIMITADOR DE VELOCIDAD GLOBAL ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    NIC=$(ip route get 8.8.8.8 | grep -oP 'dev \K\S+')
    echo -e " Interfaz: ${C_DATO}$NIC${C_RESET}"
    echo -e " [1] ESTABLECER LIMITE (Mbps)"
    echo -e " [2] QUITAR LIMITES"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            if ! command -v wondershaper >/dev/null; then apt-get install wondershaper -y >/dev/null 2>&1; fi
            echo -n " Limite BAJADA (Mbps): "; read down
            echo -n " Limite SUBIDA (Mbps): "; read up
            wondershaper clear $NIC >/dev/null 2>&1
            wondershaper $NIC $(($down * 1024)) $(($up * 1024))
            echo "Limites aplicados."; sleep 2 ;;
        2)
            if command -v wondershaper >/dev/null; then wondershaper clear $NIC; echo "Limites borrados."; fi
            sleep 2 ;;
    esac
}

# 4. BLINDAJE
fun_seguridad_blindaje() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} BLINDAJE DE ARCHIVOS ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Bloquea acceso a carpetas sensibles para usuarios no-root."
    echo -n " �Aplicar? (s/n): "
    read conf
    if [[ "$conf" == "s" ]]; then
        chmod 700 /etc/reagens /etc/reagens/users /etc/reagens/bot /etc/hysteria /etc/slowdns /etc/udp-custom
        chmod 600 /etc/reagens/bot/reagens_bot.py /etc/hysteria/config.yaml /usr/local/etc/xray/config.json
        echo -e "${C_VERDE} �Sistema Blindado!${C_RESET}"; sleep 2
    fi
}

menu_seguridad_pro() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CENTRO DE SEGURIDAD PRO ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_DATO}[1] > ANTI-TORRENT (Evitar Ban VPS)${C_RESET}"
        echo -e " ${C_DATO}[2] > FAIL2BAN (Anti Fuerza Bruta)${C_RESET}"
        echo -e " ${C_DATO}[3] > LIMITADOR VELOCIDAD (Global)${C_RESET}"
        echo -e " ${C_DATO}[4] > BLINDAJE ARCHIVOS (Anti Robo)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1) fun_seguridad_antitorrent ;;
            2) fun_seguridad_fail2ban ;;
            3) fun_seguridad_limiter ;;
            4) fun_seguridad_blindaje ;;
            0) break ;;
        esac
    done
}

# ==================================================
# MODULOS DE MANTENIMIENTO 1A (BACKUP - SWAP - LOGS)
# ==================================================

# 1. BACKUP & RESTORE
# ==================================================
# CLONADOR INTELIGENTE (ORIGEN PROPIO vs EXTERNO)
# ==================================================
fun_backup_restore() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SISTEMA DE MIGRACI�N UNIVERSAL 1A ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_DATO}[1] > GENERAR RESPALDO (Esta VPS)${C_RESET}"
    echo -e " ${C_DATO}[2] > RESTAURAR DESDE LINK (Nueva VPS)${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -ne " Opcion: "
    read op_mig
    
    case $op_mig in
        1)
            # --- GENERADOR DE CLON COMPLETO ---
            echo -e "\n ${C_VERDE}[+] Preparando clonaci�n total del sistema...${C_RESET}"
            DIR_BKP="/tmp/reagens_clone"
            rm -rf "$DIR_BKP" && mkdir -p "$DIR_BKP/db" "$DIR_BKP/services" "$DIR_BKP/conf"
            
            # Sello de identidad para reconocer que es TU script
            echo "REAGENS_MASTER_CLONE" > "$DIR_BKP/reagens_id"

            # 1. Usuarios y Passwords (Shadow/Passwd)
            cp /etc/passwd /etc/shadow /etc/group /etc/gshadow "$DIR_BKP/"

            # 2. Claves de Configuraci�n (Token ID / SSH Pass)
            [[ -f "/etc/reagens_base_pass" ]] && cp "/etc/reagens_base_pass" "$DIR_BKP/conf/"
            [[ -f "/etc/reagens/default_pass" ]] && cp "/etc/reagens/default_pass" "$DIR_BKP/conf/"
            
            # 3. Bases de Datos y Tr�fico (Excluyendo el BOT)
            cp -r /etc/adm-lite "$DIR_BKP/db/" 2>/dev/null
            mkdir -p "$DIR_BKP/db/reagens"
            rsync -av --exclude='bot' /etc/reagens/ "$DIR_BKP/db/reagens/" &>/dev/null
            
            # 4. Ajustes de Protocolos (Xray, Hysteria, SlowDNS, SSL, UDP)
            [[ -d "/usr/local/etc/xray" ]] && cp -r "/usr/local/etc/xray" "$DIR_BKP/conf/"
            [[ -d "/etc/hysteria" ]] && cp -r "/etc/hysteria" "$DIR_BKP/conf/"
            [[ -d "/etc/slowdns" ]] && cp -r "/etc/slowdns" "$DIR_BKP/conf/"
            [[ -d "/etc/stunnel" ]] && cp -r "/etc/stunnel" "$DIR_BKP/conf/"
            [[ -d "/etc/udp-custom" ]] && cp -r "/etc/udp-custom" "$DIR_BKP/conf/"

            # 5. Servicios Systemd y Firewall
            cp /etc/systemd/system/reagens* "$DIR_BKP/services/" 2>/dev/null
            cp /etc/systemd/system/xray* "$DIR_BKP/services/" 2>/dev/null
            cp /etc/systemd/system/hysteria* "$DIR_BKP/services/" 2>/dev/null
            cp /etc/systemd/system/slowdns* "$DIR_BKP/services/" 2>/dev/null
            cp /etc/systemd/system/checkuser* "$DIR_BKP/services/" 2>/dev/null
            cp /etc/systemd/system/ws-* "$DIR_BKP/services/" 2>/dev/null
            cp /etc/sysctl.conf "$DIR_BKP/conf/sysctl.conf"
            iptables-save > "$DIR_BKP/conf/iptables.rules"

            # 6. Comprimir y Servir
            cd /tmp/ && tar -czf clone_pro.tar.gz reagens_clone/ &>/dev/null
            echo -ne "\n Puerto para la transferencia [Default 8181]: "
            read P_MIG
            [[ -z "$P_MIG" ]] && P_MIG="8181"
            fuser -k $P_MIG/tcp &>/dev/null
            iptables -I INPUT -p tcp --dport $P_MIG -j ACCEPT
            
            clear
            echo -e "${C_BARRA}=====================================================${C_RESET}"
            msg_center "${C_VERDE} SERVIDOR DE CLONACI�N ACTIVO ${C_RESET}"
            echo -e "${C_BARRA}=====================================================${C_RESET}"
            echo -e " Enlace directo: http://$(curl -s ipv4.icanhazip.com):$P_MIG/clone_pro.tar.gz"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            python3 -m http.server $P_MIG --directory /tmp &>/dev/null &
            PID_CLONE=$!
            read -p " Presione Enter para cerrar el servidor al terminar..."
            kill $PID_CLONE &>/dev/null
            rm -rf "$DIR_BKP" /tmp/clone_pro.tar.gz
            ;;
            
        2)
            # --- RESTAURACI�N INTELIGENTE ---
            if ! command -v tar &> /dev/null; then
                [[ -f /etc/redhat-release ]] && yum install tar -y &>/dev/null || apt install tar -y &>/dev/null
            fi
            echo -ne "\n Ingrese el LINK del respaldo: "
            read lnk
            [[ -z "$lnk" ]] && return
            
            wget -O /tmp/clon.tar.gz "$lnk" -q
            [[ ! -s "/tmp/clon.tar.gz" ]] && { echo -e "${C_ROJO}Error de descarga.${C_RESET}"; return; }
            
            mkdir -p /tmp/res_work
            tar -xzf /tmp/clon.tar.gz -C /tmp/res_work/
            
            # --- VALIDACI�N DE IDENTIDAD ---
            if [[ -f "/tmp/res_work/reagens_clone/reagens_id" ]]; then
                # CASO 1: ES TU SCRIPT (Restauraci�n de Ajustes + Usuarios)
                echo -e " ${C_VERDE}[!] IDENTIFICADO: REAGENS SCRIPT (Clonaci�n Full)${C_RESET}"
                
                # Restaurar todo el entorno
                cp /tmp/res_work/reagens_clone/passwd /etc/passwd
                cp /tmp/res_work/reagens_clone/shadow /etc/shadow
                cp /tmp/res_work/reagens_clone/group /etc/group
                cp /tmp/res_work/reagens_clone/gshadow /etc/gshadow
                cp -r /tmp/res_work/reagens_clone/db/* /etc/ 2>/dev/null
                cp -r /tmp/res_work/reagens_clone/conf/* /etc/ 2>/dev/null
                cp /tmp/res_work/reagens_clone/services/* /etc/systemd/system/ 2>/dev/null
                iptables-restore < /tmp/res_work/reagens_clone/conf/iptables.rules 2>/dev/null
                
                systemctl daemon-reload
                echo -e " ${C_DATO}[+] Reiniciando servicios clonados...${C_RESET}"
                systemctl restart xray hysteria-server slowdns-server checkuser-reagens 2>/dev/null
                echo -e "\n${C_VERDE} [OK] CLONACI�N TOTAL COMPLETADA.${C_RESET}"
                
            else
                # CASO 2: OTRO SCRIPT (Solo importaci�n de usuarios)
                echo -e " ${C_DATO}[!] IDENTIFICADO: PROVEEDOR DIFERENTE (Solo Usuarios)${C_RESET}"
                echo -e " ${C_TEXTO}[+] Extrayendo usuarios sin tocar tus ajustes...${C_RESET}"
                
                # Restaurar solo las tablas de usuarios (esto permite que logueen)
                # Buscamos passwd/shadow en la raiz del backup o dentro de carpetas
                B_ROOT="/tmp/res_work/reagens_clone"
                [[ ! -d "$B_ROOT" ]] && B_ROOT="/tmp/res_work" # Fallback para otros formatos de tar
                
                cp $B_ROOT/passwd /etc/passwd 2>/dev/null
                cp $B_ROOT/shadow /etc/shadow 2>/dev/null
                cp $B_ROOT/group /etc/group 2>/dev/null
                
                # Intentar mover DBs de carpetas comunes de Chumo/Rufu a tus rutas
                # Buscamos en /etc/adm-lite o /etc/usuarios que traiga el backup
                cp -r $B_ROOT/db/adm-lite/* /etc/adm-lite/ 2>/dev/null
                cp -r $B_ROOT/db/usuarios/* /etc/adm-lite/ 2>/dev/null
                
                echo -e "\n${C_VERDE} [OK] IMPORTACI�N DE USUARIOS FINALIZADA.${C_RESET}"
                echo -e " Tus puertos y ajustes actuales no han sido modificados."
            fi
            
            rm -rf /tmp/clon.tar.gz /tmp/res_work
            read -p " Use la Opci�n 9 (Reboot) para aplicar cambios."
            ;;
    esac
}

# 2. GESTOR SWAP (MEMORIA VIRTUAL)
fun_swap_manager() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} GESTOR MEMORIA SWAP (RAM VIRTUAL) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    # Detectar swap actual
    SWAP_ACT=$(free -h | grep Swap | awk '{print $2}')
    echo -e " SWAP ACTUAL: ${C_DATO}$SWAP_ACT${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " [1] CREAR SWAP 1GB (Recomendado 512MB RAM)"
    echo -e " [2] CREAR SWAP 2GB (Recomendado 1GB+ RAM)"
    echo -e " [3] ELIMINAR SWAP"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            swapoff -a
            dd if=/dev/zero of=/swapfile bs=1M count=1024
            mkswap /swapfile
            swapon /swapfile
            echo "/swapfile swap swap defaults 0 0" >> /etc/fstab
            echo -e "${C_VERDE} Swap 1GB Creada.${C_RESET}"; sleep 2 ;;
        2)
            swapoff -a
            dd if=/dev/zero of=/swapfile bs=1M count=2048
            mkswap /swapfile
            swapon /swapfile
            echo "/swapfile swap swap defaults 0 0" >> /etc/fstab
            echo -e "${C_VERDE} Swap 2GB Creada.${C_RESET}"; sleep 2 ;;
        3)
            swapoff -a
            sed -i '/swapfile/d' /etc/fstab
            rm -f /swapfile
            echo -e "${C_ROJO} Swap Eliminada.${C_RESET}"; sleep 2 ;;
    esac
}

# 3. VISOR DE LOGS
fun_log_viewer() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} VISOR DE LOGS (DEPURADOR) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] LOG XRAY / V2RAY"
    echo -e " [2] LOG HYSTERIA"
    echo -e " [3] LOG SLOWDNS"
    echo -e " [4] LOG SSH (AUTH)"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " CTRL + C para salir del log."
    echo -n " Opcion: "
    read op
    echo -e "${C_DATO} MOSTRANDO ULTIMAS 50 LINEAS... (CTRL+C SALIR)${C_RESET}"
    echo ""
    case $op in
        1) journalctl -u xray -n 50 -f ;;
        2) journalctl -u hysteria-server -n 50 -f ;;
        3) journalctl -u slowdns-server -n 50 -f ;;
        4) tail -f /var/log/auth.log ;;
    esac
}

# --- DESINSTALACION COMPLETA Y BORRADO DE HUELLAS (VERSION FINAL) ---
fun_deep_clean() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} PROTOCOLO DE BORRADO ABSOLUTO ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_ROJO}[!] ADVERTENCIA:${C_RESET} Se eliminar�n todos los usuarios,"
    echo -e " servicios, puertos, bases de datos y comandos."
    echo -e " La VPS volver� a su estado original de f�brica."
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Escribe 'BORRAR-SISTEMA' para confirmar: "
    read confirm
    if [[ "$confirm" == "BORRAR-SISTEMA" ]]; then
        echo -e "\n ${C_DATO}[1/5] Deteniendo todos los servicios...${C_RESET}"
        systemctl stop xray v2ray hysteria-server slowdns-server reagens-udp rvp-panel reagens-monitor reagens-guard reagens-bot checkuser-reagens ws-reagens ws-epro badvpn dropbear-custom stunnel4 >/dev/null 2>&1
        
        echo -e " ${C_DATO}[2/5] Eliminando usuarios reales del sistema...${C_RESET}"
        # Borrar usuarios de SSH y Tokens antes de borrar las DBs
        for db in "$DB_SSH" "$DB_TOKENS"; do
            if [[ -f "$db" ]]; then
                while IFS='|' read -r user rest; do
                    # Matamos procesos del usuario y lo eliminamos
                    pkill -u "$user" >/dev/null 2>&1
                    userdel --force "$user" >/dev/null 2>&1
                    rm -rf "/home/$user" >/dev/null 2>&1
                    # Limpiamos su rastro en la DB de tr�fico
                    sed -i "/^$user|/d" "$DB_TRAFFIC"
                done < "$db"
            fi
        done

        echo -e " ${C_DATO}[3/5] Limpiando Firewall y Ajustes de Nucleo...${C_RESET}"
        [[ -f /etc/sysctl.conf.bak ]] && mv /etc/sysctl.conf.bak /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        iptables -F && iptables -X && iptables -t nat -F && iptables -t nat -X
        iptables -P INPUT ACCEPT && iptables -P FORWARD ACCEPT && iptables -P OUTPUT ACCEPT
        fun_save_iptables

        echo -e " ${C_DATO}[4/5] Eliminando archivos, binarios y servicios...${C_RESET}"
        rm -rf /etc/reagens /etc/adm-lite /etc/hysteria /etc/slowdns /etc/udp-custom /usr/local/etc/xray /etc/stunnel
        rm -f /etc/systemd/system/xray.service /etc/systemd/system/hysteria-server.service /etc/systemd/system/slowdns-server.service /etc/systemd/system/reagens-*.service /etc/systemd/system/checkuser-reagens.service /etc/systemd/system/ws-*.service /etc/systemd/system/badvpn.service /etc/systemd/system/rvp-panel.service
        rm -f /usr/local/bin/reagens-* /usr/bin/badvpn-udpgw /usr/bin/r-vp /usr/bin/menu /usr/local/bin/xray
        systemctl daemon-reload

        echo -e " ${C_DATO}[5/5] Borrando comandos y banner de inicio...${C_RESET}"
        rm -f /usr/bin/menu >/dev/null 2>&1
        sed -i '/reagens/d' /root/.bashrc >/dev/null 2>&1
        sed -i '/menu/d' /root/.bashrc >/dev/null 2>&1
        echo "" > /etc/issue.net
        echo "" > /etc/motd
        crontab -r >/dev/null 2>&1

        echo -e "\n${C_VERDE} [OK] SISTEMA ELIMINADO AL 100%. NING�N RASTRO QUED�.${C_RESET}"
        sleep 3
        exit 0
    else
        echo -e "${C_ROJO} Cancelado.${C_RESET}"
        sleep 2
    fi
}

# --- FUNCION DE LIMPIEZA (P�gala aqu�, justo antes del men�) ---
fun_limpiar_logs() {
    clear
    msg_center " LIMPIEZA DE SISTEMA "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_DATO}Vaciando logs del sistema para liberar espacio...${C_RESET}"
    
    # Vaciar logs sin borrar archivos (Mantiene permisos)
    truncate -s 0 /var/log/syslog 2>/dev/null
    truncate -s 0 /var/log/auth.log 2>/dev/null
    truncate -s 0 /var/log/kern.log 2>/dev/null
    truncate -s 0 /var/log/dpkg.log 2>/dev/null
    
    # Logs de Xray (si existen)
    truncate -s 0 /var/log/xray/access.log 2>/dev/null
    truncate -s 0 /var/log/xray/error.log 2>/dev/null
    
    # Historial de comandos
    rm -f /root/.bash_history
    history -c
    
    # Limpieza de apt
    apt-get clean >/dev/null 2>&1
    apt-get autoremove -y >/dev/null 2>&1
    
    echo -e "${C_VERDE} �Logs y Basura Vaciados Exitosamente!${C_RESET}"
    sleep 2
}

# --- MENU MANTENIMIENTO (ACTUALIZADO CON LA OPCION 4) ---
menu_mantenimiento() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MANTENIMIENTO DEL SERVIDOR ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1] > COPIAS DE SEGURIDAD (MIGRAR)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > MEMORIA SWAP (ANTI-LAG)${C_RESET}"
        echo -e " ${C_TEXTO}[3] > VISOR DE LOGS (ERROR LOGS)${C_RESET}"
        echo -e " ${C_DATO}[4] > LIMPIAR LOGS Y BASURA (ESPACIO)${C_RESET}"  # <--- NUEVO BOTON
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1) fun_backup_restore ;;
            2) fun_swap_manager ;;
            3) fun_log_viewer ;;
            4) fun_limpiar_logs ;;  # <--- NUEVO COMANDO
            0) break ;;
        esac
    done
}

fun_instalar_panel_web() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION PANEL WEB R-VP (FINAL UI) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        P_WEB_ACTUAL="8888"
        if [[ -f "/etc/reagens/panel_rvp.py" ]]; then
            P_WEB_ACTUAL=$(grep "PORT =" /etc/reagens/panel_rvp.py | awk '{print $3}' | head -n1)
            [[ -z "$P_WEB_ACTUAL" ]] && P_WEB_ACTUAL="8888"
        fi

        if systemctl is-active --quiet rvp-panel; then
            ESTADO_WEB="${C_VERDE}ONLINE (Puerto $P_WEB_ACTUAL)${C_RESET}"
        else
            ESTADO_WEB="${C_ROJO}OFFLINE${C_RESET}"
        fi
        
        echo -e " ESTADO ACTUAL: $ESTADO_WEB"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[1] > REINSTALAR (APLICAR NUEVO SISTEMA)${C_RESET}"
        echo -e " ${C_DATO}[2] > DESINSTALAR COMPLETAMENTE${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[3] > INICIAR SERVICIO${C_RESET}"
        echo -e " ${C_TEXTO}[4] > DETENER SERVICIO${C_RESET}"
        echo -e " ${C_TEXTO}[5] > CAMBIAR CLAVE ADMIN${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op_web

        case $op_web in
            1)
                echo -e " ${C_DATO}[+] Deteniendo procesos...${C_RESET}"
                systemctl stop rvp-panel >/dev/null 2>&1
                pkill -f panel_rvp.py >/dev/null 2>&1
                
                echo -e "\n ${C_TEXTO}Puerto actual: ${C_DATO}$P_WEB_ACTUAL${C_RESET}"
                echo -n " Ingrese Nuevo Puerto [Default 8888]: "
                read P_WEB_NEW
                [[ -z "$P_WEB_NEW" ]] && P_WEB_NEW="8888"
                fun_check_port $P_WEB_NEW "Panel Web R-VP" || return

                fuser -k $P_WEB_NEW/tcp >/dev/null 2>&1
                if [[ "$P_WEB_NEW" == "80" ]]; then
                    systemctl stop nginx >/dev/null 2>&1
                    systemctl stop apache2 >/dev/null 2>&1
                    systemctl stop ws-reagens >/dev/null 2>&1
                fi

                mkdir -p /etc/adm-lite /etc/reagens /etc/reagens/users
                touch /etc/adm-lite/usuarios_ssh.db /etc/adm-lite/usuarios_token.db /etc/reagens/traffic.db
                chmod 777 /etc/adm-lite
                chmod 666 /etc/adm-lite/*.db
                chmod 666 /etc/reagens/traffic.db

                echo -e " ${C_DATO}[+] Instalando dependencias Python...${C_RESET}"
                if [[ -f /etc/redhat-release ]]; then
                    yum install -y python3-pip
                else
                    apt-get install -y python3-pip
                fi >/dev/null 2>&1
                pip3 install flask requests --break-system-packages >/dev/null 2>&1 || pip3 install flask requests >/dev/null 2>&1

cat <<'EOF' > /etc/reagens/panel_rvp.py
# -*- coding: utf-8 -*-
import os, subprocess, json, uuid, base64, datetime, re, shutil
from flask import Flask, request, redirect, url_for, session, render_template_string, flash, send_file
from datetime import timedelta

app = Flask(__name__)
app.secret_key = os.urandom(24)
app.permanent_session_lifetime = timedelta(days=7)

AUTH_FILE = "/etc/reagens/panel_auth"
DB_USERS = "/etc/reagens/users"
DB_V2_USERS = "/etc/reagens/users/v2ray"
V2_CONF = "/usr/local/etc/xray/config.json"
BASE_PASS_FILE = "/etc/reagens_base_pass"
DB_TRAFFIC = "/etc/reagens/traffic.db"
SLOW_KEY = "/etc/slowdns/server.pub"
SLOW_SVC = "/etc/systemd/system/slowdns-server.service"
DB_SSH_FILE = "/etc/adm-lite/usuarios_ssh.db"
DB_TOKEN_FILE = "/etc/adm-lite/usuarios_token.db"
REALITY_PUB = "/etc/reagens/reality_pub"
DEFAULT_SSH_PASS = "/etc/reagens/default_pass"
BANNER_FILE = "/etc/issue.net"

PORT = 8081

if not os.path.exists(DB_V2_USERS): os.makedirs(DB_V2_USERS, exist_ok=True)
if not os.path.exists("/etc/adm-lite"): os.makedirs("/etc/adm-lite", exist_ok=True)

def get_cmd(cmd):
    try: return subprocess.check_output(cmd, shell=True).decode().strip()
    except: return ""

def check_login(): return session.get('logged_in')

def get_base_pass():
    if os.path.exists(BASE_PASS_FILE):
        try: return open(BASE_PASS_FILE).read().strip()
        except: pass
    return "123456"

def db_append(filepath, line):
    try:
        with open(filepath, 'a') as f: 
            f.write(line + "\n")
            f.flush()
            os.fsync(f.fileno())
        return True
    except: return False

def get_user_data(user):
    path = f"{DB_USERS}/{user}"
    data = {}
    if os.path.exists(path):
        try:
            with open(path, 'r', errors='ignore') as f:
                for line in f:
                    if "=" in line: k, v = line.strip().split("=", 1); data[k] = v.strip()
        except: pass
    return data

def get_traffic_data(user):
    if not os.path.exists(DB_TRAFFIC): return (0, 0, 1)
    try:
        with open(DB_TRAFFIC, 'r') as f:
            for line in f:
                p = line.strip().split('|')
                if len(p) < 4: continue
                if p[0] == user:
                    return (int(int(p[1])/1048576), round(int(p[2])/1048576, 2), p[3])
    except: pass
    return (0, 0, 1)

def update_traffic_limit(user, mb_limit):
    if not os.path.exists(DB_TRAFFIC): return
    lines = []
    try:
        nb = int(mb_limit) * 1048576
        found = False
        with open(DB_TRAFFIC, 'r') as f:
            for line in f:
                p = line.strip().split('|')
                if len(p) < 4: lines.append(line); continue
                if p[0] == user:
                    st = "1" if nb == 0 or nb > int(p[2]) else p[3]
                    lines.append(f"{user}|{nb}|{p[2]}|{st}\n"); found = True
                else: lines.append(line)
        if not found: lines.append(f"{user}|{nb}|0|1\n")
        with open(DB_TRAFFIC, 'w') as f: f.writelines(lines)
        os.system(f"iptables -I OUTPUT -m owner --uid-owner {user} -j ACCEPT 2>/dev/null")
    except: pass

def get_users_list(user_type="ssh"):
    data = []
    target_db = DB_SSH_FILE if user_type == "ssh" else DB_TOKEN_FILE
    if os.path.exists(target_db):
        try:
            with open(target_db, 'r', errors='ignore') as f:
                for line in f:
                    line = line.strip()
                    if not line: continue
                    p = line.split('|')
                    u = p[0]
                    if user_type == "ssh" and len(p) >= 5:
                        pw = p[1]; date_raw = p[2]; lim = p[3]
                    elif user_type == "token" and len(p) >= 4:
                        pw = "---"; detail = p[1]; date_raw = p[2]; lim="0"
                    else: continue
                    
                    sys_check = get_cmd(f"id {u}")
                    if not sys_check: 
                        dias_restantes = "NO-SYS"; cre_date = "---"
                    else:
                        cre_date = get_cmd(f"ls -ld /etc/reagens/users/{u} 2>/dev/null | awk '{{print $6,$7}}'")
                        if not cre_date: cre_date = datetime.datetime.now().strftime("%Y-%m-%d")
                        try:
                            exp_dt = datetime.datetime.strptime(date_raw, "%Y-%m-%d")
                            delta = exp_dt - datetime.datetime.now()
                            dias_restantes = str(delta.days) if delta.days >= 0 else "EXP"
                        except: dias_restantes = "Err"
                    
                    lock = " L " in get_cmd(f"passwd -S {u}")
                    on = False
                    try:
                        if int(get_cmd(f"ps -u {u} | grep -E 'sshd|dropbear' | grep -v grep | wc -l")) > 0: on = True
                    except: pass
                    
                    data.append({
                        'name': u, 'password': pw, 'detail': p[1] if user_type=="token" else "SSH",
                        'exp': date_raw, 'days': dias_restantes, 'limit_conn': lim,
                        'locked': lock, 'online': on, 'created': cre_date
                    })
        except: pass
    return data

def get_v2ray_users():
    if not os.path.exists(V2_CONF): return []
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        users = []
        for x in c['inbounds'][0]['settings']['clients']:
            e = x.get('email', '?'); uid = x.get('id', x.get('password', '?'))
            blk = "BLOCKED_" in e; alias = e.replace("BLOCKED_", "")
            mf = f"{DB_V2_USERS}/{alias}"; exp = "---"
            if os.path.exists(mf):
                try: 
                    with open(mf, 'r') as f_meta:
                        for l in f_meta:
                            if "EXP=" in l: exp = l.split("=")[1].strip()
                except: pass
            users.append({'alias':alias, 'uuid':uid, 'blocked':blk, 'exp':exp})
        return users
    except: return []

def get_slowdns_info():
    info = {'status': 'OFF', 'ns': '---', 'pub': '---', 'out': '---', 'in': '53, 5300 (UDP)'}
    if os.system("systemctl is-active --quiet slowdns-server") == 0: info['status'] = 'ON'
    if os.path.exists(SLOW_KEY): info['pub'] = open(SLOW_KEY).read().strip()
    if os.path.exists(SLOW_SVC):
        try:
            with open(SLOW_SVC) as f:
                for l in f:
                    if "ExecStart=" in l:
                        parts = l.strip().split()
                        info['ns'] = parts[-2]
                        info['out'] = parts[-1].split(":")[-1]
        except: pass
    return info

CSS = """
<style>
:root { --bg:#121212; --card:#1e1e1e; --txt:#e0e0e0; --acc:#007bff; --nav:#000; }
body { background:var(--bg); color:var(--txt); font-family:'Segoe UI', sans-serif; margin:0; display:flex; min-height:100vh; }
.sidebar { width:220px; background:var(--nav); border-right:1px solid #333; display:flex; flex-direction:column; padding:20px; }
.content { flex:1; padding:30px; overflow-y:auto; }
a { text-decoration:none; color:#aaa; display:block; padding:12px; margin:5px 0; border-radius:6px; transition:0.2s; }
a:hover, a.active { background:var(--card); color:#fff; border-left:4px solid var(--acc); }
.card { background:var(--card); padding:20px; margin-bottom:20px; border-radius:8px; border:1px solid #333; box-shadow:0 4px 6px rgba(0,0,0,0.3); }
h2, h3 { margin-top:0; color:#fff; }
input, select, textarea { width:100%; padding:10px; margin:8px 0; background:#2c2c2c; border:1px solid #444; color:#fff; border-radius:4px; box-sizing:border-box; }
.btn { display:inline-block; padding:8px 15px; background:var(--acc); color:#fff; border:none; border-radius:4px; cursor:pointer; font-size:0.9rem; }
.btn:hover { opacity:0.9; }
.btn-red { background:#d32f2f; } .btn-green { background:#388e3c; } .btn-org { background:#f57c00; }
table { width:100%; border-collapse:collapse; margin-top:15px; font-size:0.9rem; }
th, td { text-align:left; padding:12px; border-bottom:1px solid #333; }
th { background:#252525; color:#fff; }
.badge { padding:4px 8px; border-radius:4px; font-size:0.75rem; font-weight:bold; }
.bg-on { background:#388e3c; color:#fff; } .bg-off { background:#616161; color:#fff; } .bg-lock { background:#d32f2f; color:#fff; }
.flash { padding:15px; margin-bottom:20px; border-radius:6px; background:#007bff; color:white; text-align:center; font-weight:bold; }
.grid-form { display:grid; grid-template-columns:1fr 1fr; gap:15px; }
.login-box { width:100%; max-width:400px; margin:100px auto; padding:40px; background:#1e1e1e; border-radius:10px; box-shadow:0 0 20px rgba(0,0,0,0.5); text-align:center; }
@media(max-width:768px) { body{flex-direction:column;} .sidebar{width:100%;} .grid-form{grid-template-columns:1fr;} }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
"""

LAYOUT = """
<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>R-VP PANEL HIRVIP</title>""" + CSS + """</head><body>
<div class="sidebar">
    <h2 style="color:#fff; text-align:center; letter-spacing:2px;">R-VP <span style="color:#007bff;">PRO</span></h2>
    <hr style="border:0; border-top:1px solid #333; margin-bottom:20px;">
    <a href="/"><i class="fas fa-chart-line"></i> Dashboard</a>
    <a href="/ssh"><i class="fas fa-user-shield"></i> Usuarios SSH</a>
    <a href="/tokens"><i class="fas fa-key"></i> Tokens App</a>
    <a href="/v2ray"><i class="fas fa-paper-plane"></i> V2Ray / Xray</a>
    <a href="/protos"><i class="fas fa-network-wired"></i> Protocolos UDP</a>
    <a href="/tools"><i class="fas fa-tools"></i> Centro de Control</a>
    <a href="/settings"><i class="fas fa-cogs"></i> Ajustes Panel</a>
    <a href="/logout" style="margin-top:auto; color:#ef5350;"><i class="fas fa-sign-out-alt"></i> Cerrar Sesion</a>
</div>
<div class="content">
    {% with m=get_flashed_messages() %}{% if m %}<div class="flash"><i class="fas fa-info-circle"></i> {{ m[0] }}</div>{% endif %}{% endwith %}
    {{ body|safe }}
</div>
</body></html>
"""

LOGIN_HTML = """
<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Login R-VP</title>""" + CSS + """</head><body style="display:block;">
<div class="login-box">
    <h2 style="color:#007bff; margin-bottom:30px;">ACCESO SEGURO</h2>
    <form method="post">
        <input name="u" placeholder="Usuario" style="padding:15px; margin-bottom:15px;">
        <input name="p" type="password" placeholder="Password" style="padding:15px; margin-bottom:25px;">
        <button class="btn" style="width:100%; padding:15px; font-size:1.1rem;">INICIAR SESION</button>
    </form>
</div></body></html>
"""

@app.route('/')
def home():
    if not check_login(): return redirect('/login')
    ram = get_cmd("free -h | grep Mem | awk '{print $3 \" / \" $2}'")
    ip = get_cmd("curl -s ipv4.icanhazip.com")
    uptime = get_cmd("uptime -p")
    cpu = get_cmd("top -bn1 | grep 'Cpu(s)' | awk '{print 100 - $8\"%\"}'")
    info = f"""<div class="card"><h2><i class="fas fa-server"></i> Estado del Servidor</h2><div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:20px; margin-top:20px;"><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-memory fa-2x" style="color:#007bff;"></i><br><b>RAM</b><br>{ram}</div><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-microchip fa-2x" style="color:#28a745;"></i><br><b>CPU</b><br>{cpu}</div><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-globe fa-2x" style="color:#ffc107;"></i><br><b>IP</b><br>{ip}</div><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-clock fa-2x" style="color:#dc3545;"></i><br><b>UPTIME</b><br>{uptime}</div></div></div>"""
    return render_template_string(LAYOUT, body=info)

@app.route('/login', methods=['GET','POST'])
def login():
    if request.method == 'POST':
        u = request.form.get('u'); p = request.form.get('p')
        real_u, real_p = "admin", "admin"
        if os.path.exists(AUTH_FILE):
            try: parts = open(AUTH_FILE).read().strip().split(':'); real_u=parts[0]; real_p=parts[1]
            except: pass
        if u==real_u and p==real_p:
            session.permanent = True
            session['logged_in'] = True; return redirect('/')
    return render_template_string(LOGIN_HTML)

@app.route('/logout')
def logout(): session.clear(); return redirect('/login')

@app.route('/ssh')
def ssh():
    if not check_login(): return redirect('/login')
    users = get_users_list("ssh")
    html = """<div class="card"><h3><i class="fas fa-user-plus"></i> Nuevo SSH</h3>
    <form action="/ssh/add" method="POST" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;">
    <input name="u" placeholder="Usuario" required>
    <input name="p" placeholder="Password" required>
    <input name="d" type="number" value="30" placeholder="Dias">
    <input name="l" type="number" placeholder="Limit Conexiones" required>
    <button class="btn">Crear</button></form></div>
    <div class="card"><h3>Lista SSH</h3><table>
    <thead><tr><th>Usuario</th><th>Pass</th><th>Creado</th><th>Limit IP</th><th>Vence</th><th>Estado</th><th>Acciones</th></tr></thead><tbody>"""
    
    for u in users:
        st_c, st_t = ('bg-on', 'ON') if u['online'] else ('bg-off', 'OFF')
        if u['locked']: st_c, st_t = 'bg-lock', 'BLOQ'
        l_a, l_c, l_i = ('unlock', 'btn-green', 'unlock') if u['locked'] else ('lock', 'btn-org', 'lock')
        html += f"""<tr><td>{u['name']}</td><td>{u['password']}</td><td>{u['created']}</td><td>{u['limit_conn']}</td><td>{u['exp']} <small>({u['days']}d)</small></td><td><span class="badge {st_c}">{st_t}</span></td><td><a href='/ssh/edit/{u['name']}' class='btn'><i class='fas fa-edit'></i></a> <a href='/user/{l_a}/{u['name']}' class='btn {l_c}'><i class='fas fa-{l_i}'></i></a> <a href='/user/del/{u['name']}' class='btn btn-red' onclick="return confirm('?');"><i class='fas fa-trash'></i></a> <a href='/user/renew/{u['name']}' class='btn btn-green'><i class='fas fa-sync'></i></a></td></tr>"""
    return render_template_string(LAYOUT, body=html+"</tbody></table></div>")

@app.route('/ssh/add', methods=['POST'])
def ssh_add():
    if not check_login(): return redirect('/login')
    u, p, d, l = request.form.get('u'), request.form.get('p'), request.form.get('d'), request.form.get('l')
    mb = "0"
    if get_cmd(f"id {u}"): flash("Existe")
    else:
        fd = get_cmd(f"date -d '+{d} days' +%Y-%m-%d")
        os.system(f"useradd -M -s /bin/false {u}; echo '{u}:{p}' | chpasswd; chage -E '{fd}' {u}")
        os.system(f"touch /etc/reagens/users/{u}")
        with open(DB_TRAFFIC, "a") as f: f.write(f"{u}|0|0|1\n")
        db_append(DB_SSH_FILE, f"{u}|{p}|{fd}|{l}|0")
        flash(f"Usuario {u} creado.")
    return redirect('/ssh')

@app.route('/ssh/edit/<uname>', methods=['GET','POST'])
def ssh_edit(uname):
    if not check_login(): return redirect('/login')
    d = get_user_data(uname)
    if request.method == 'POST':
        p, dy, l = request.form.get('p'), request.form.get('d'), request.form.get('l')
        if p: os.system(f"echo '{uname}:{p}' | chpasswd")
        final_date = ""
        if dy: 
            final_date = get_cmd(f"date -d '+{dy} days' +%Y-%m-%d")
            os.system(f"chage -E '{final_date}' {uname}")
        lines = []
        if os.path.exists(DB_SSH_FILE):
            with open(DB_SSH_FILE, 'r', errors='ignore') as f:
                for line in f:
                    pts = line.strip().split('|')
                    if pts[0] == uname:
                        new_p = p if p else pts[1]; new_e = final_date if dy else pts[2]; new_l = l if l else pts[3]
                        lines.append(f"{uname}|{new_p}|{new_e}|{new_l}|0\n")
                    else: lines.append(line + "\n")
            with open(DB_SSH_FILE, 'w') as f: f.writelines(lines)
        flash("Editado"); return redirect('/ssh')
    h = f"""<div class="card"><h3>Editar SSH: {uname}</h3><form method="POST"><div class="grid-form"><div><label>Pass</label><input name="p"></div><div><label>Limit Conn</label><input name="l" value="{d.get('LIMIT_CONN','1')}"></div><div><label>+/- Dias</label><input name="d" type="number"></div></div><br><button class="btn btn-green">Guardar</button></form><br><a href="/ssh" class="btn btn-red">Volver</a></div>"""
    return render_template_string(LAYOUT, body=h)

@app.route('/tokens')
def tokens():
    if not check_login(): return redirect('/login')
    users = get_users_list("token"); def_p = get_base_pass()
    html = f"""<div class="card" style="border-top:3px solid #8e44ad;"><h3>Crear Token</h3><form action="/token/add" method="POST" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;"><input name="u" placeholder="ID Token" required><input name="client" placeholder="Cliente" required><input name="d" type="number" value="30" placeholder="Dias"><input name="p" value="{def_p}" readonly style="background:#333;"><button class="btn" style="background:#8e44ad;">Crear</button></form></div>
    <div class="card"><h3>Tokens</h3><table>
    <thead><tr><th>Cliente</th><th>Token ID</th><th>Creado</th><th>Vence</th><th>Estado</th><th>Acciones</th></tr></thead><tbody>"""
    for u in users:
        st_c, st_t = ('bg-on', 'ON') if u['online'] else ('bg-off', 'OFF')
        if u['locked']: st_c, st_t = 'bg-lock', 'BLOQ'
        l_a, l_c, l_i = ('unlock', 'btn-green', 'unlock') if u['locked'] else ('lock', 'btn-org', 'lock')
        html += f"""<tr><td>{u['detail']}</td><td><b>{u['name']}</b></td><td>{u['created']}</td><td>{u['exp']} <small>({u['days']}d)</small></td><td><span class="badge {st_c}">{st_t}</span></td><td><a href='/token/edit/{u['name']}' class='btn'><i class='fas fa-edit'></i></a> <a href='/user/{l_a}/{u['name']}' class='btn {l_c}'><i class='fas fa-{l_i}'></i></a> <a href='/user/del/{u['name']}' class='btn btn-red' onclick="return confirm('?');"><i class='fas fa-trash'></i></a> <a href='/user/renew/{u['name']}' class='btn btn-green'><i class='fas fa-sync'></i></a></td></tr>"""
    return render_template_string(LAYOUT, body=html+"</tbody></table></div>")

@app.route('/token/add', methods=['POST'])
def token_add():
    if not check_login(): return redirect('/login')
    u, c, d, p = request.form.get('u'), request.form.get('client'), request.form.get('d'), request.form.get('p')
    if get_cmd(f"id {u}"): flash("Existe")
    else:
        fd = get_cmd(f"date -d '+{d} days' +%Y-%m-%d")
        os.system(f"useradd -M -s /bin/false -c '{c}' {u}; echo '{u}:{p}' | chpasswd; chage -E '{fd}' {u}")
        os.system(f"touch /etc/reagens/users/{u}")
        with open(DB_TRAFFIC, "a") as f: f.write(f"{u}|0|0|1\n")
        db_append(DB_TOKEN_FILE, f"{u}|{c}|{fd}|0")
        flash("Token Creado")
    return redirect('/tokens')

@app.route('/token/edit/<uname>', methods=['GET','POST'])
def token_edit(uname):
    if not check_login(): return redirect('/login')
    d = get_user_data(uname)
    if request.method == 'POST':
        c, dy = request.form.get('client'), request.form.get('d')
        if dy: 
            final_date = get_cmd(f"date -d '+{dy} days' +%Y-%m-%d")
            os.system(f"chage -E '{final_date}' {uname}")
        os.system(f"usermod -c '{c}' {uname}")
        lines = []
        if os.path.exists(DB_TOKEN_FILE):
            with open(DB_TOKEN_FILE, 'r', errors='ignore') as f:
                for line in f:
                    pts = line.strip().split('|')
                    if pts[0] == uname:
                        new_c = c if c else pts[1]; new_e = final_date if dy else pts[2]
                        lines.append(f"{uname}|{new_c}|{new_e}|0\n")
                    else: lines.append(line + "\n")
            with open(DB_TOKEN_FILE, 'w') as f: f.writelines(lines)
        flash("Editado"); return redirect('/tokens')
    h = f"""<div class="card"><h3>Edit Token: {uname}</h3><form method="POST"><div class="grid-form"><div><label>Cliente</label><input name="client" value="{d.get('CLIENT_REF','')}"></div><div><label>+/- Dias</label><input name="d" type="number"></div></div><br><button class="btn btn-green">Guardar</button></form><br><a href="/tokens" class="btn btn-red">Volver</a></div>"""
    return render_template_string(LAYOUT, body=h)

@app.route('/v2ray')
def v2ray():
    if not check_login(): return redirect('/login')
    users = []
    inbounds = []
    if os.path.exists(V2_CONF):
        with open(V2_CONF, 'r') as f: cfg = json.load(f)
        inbounds = cfg.get('inbounds', [])
        for c in inbounds[0]['settings']['clients']:
            name = c.get('email')
            uid = c.get('id', c.get('password'))
            users.append({'name': name, 'uuid': uid})
    
    # 1. FORMULARIO CREAR (UUID MANUAL/AUTO)
    html = """<h3>Gestion V2Ray / Xray</h3>
    <div class='card' style='border-top:3px solid #27ae60;'>
        <form action='/v2ray/add' method='post'>
            Nombre: <input name='u' required> 
            Dias: <input name='d' type='number' value='30'>
            UUID: <select name='mode'><option value='auto'>Automatico</option><option value='manual'>Manual</option></select>
            <input name='custom_uuid' placeholder='Escriba UUID si eligio Manual'>
            <button class='btn btn-green' style='width:100%; margin-top:10px;'>CREAR USUARIO</button>
        </form>
    </div>"""

    # 2. FORMULARIO CONFIGURACION GLOBAL DUPLEX
    html += """<div class='card' style='border-top:3px solid #f1c40f;'>
    <h3><i class='fas fa-sync-alt'></i> Configuracion Global Duplex</h3>
    <form action='/v2ray/config_global' method='POST'>"""
    for i, inb in enumerate(inbounds):
        p_act = inb.get('protocol', 'vless')
        t_act = inb.get('streamSettings', {}).get('network', 'tcp')
        port = inb.get('port', '???')
        html += f"""<div style='background:#252525; padding:15px; border-radius:6px; margin-bottom:10px;'>
            <b>PERFIL #{i+1} (Puerto: {port})</b><br><br>
            <label>Protocolo</label><select name='p{i}'>
                <option value='vless' {'selected' if p_act=='vless' else ''}>VLESS</option>
                <option value='vmess' {'selected' if p_act=='vmess' else ''}>VMESS</option>
                <option value='trojan' {'selected' if p_act=='trojan' else ''}>TROJAN</option>
            </select>
            <label>Transporte</label><select name='t{i}'>
                <option value='tcp' {'selected' if t_act=='tcp' else ''}>TCP</option>
                <option value='ws' {'selected' if t_act=='ws' else ''}>WS</option>
                <option value='grpc' {'selected' if t_act=='grpc' else ''}>GRPC</option>
                <option value='httpupgrade' {'selected' if t_act=='httpupgrade' else ''}>HTTPUPGRADE</option>
            </select></div>"""
    html += "<button class='btn btn-org' style='width:100%'>GUARDAR CAMBIOS GLOBALES</button></form></div>"

    # 3. TABLA DE USUARIOS CON QR/LINK
    html += """<table><thead><tr><th>Usuario</th><th>UUID / Clave</th><th>Acciones</th></tr></thead><tbody>"""
    for u in users:
        html += f"""<tr><td>{u['name']}</td><td><small>{u['uuid']}</small></td>
        <td>
            <a href='/v2ray/link/{u['name']}' class='btn btn-org'><i class='fas fa-qrcode'></i></a>
            <a href='/v2ray/edit/{u['name']}' class='btn btn-blue'><i class='fas fa-edit'></i></a>
            <a href='/v2ray/del/{u['name']}' class='btn btn-red'><i class='fas fa-trash'></i></a>
        </td></tr>"""
    
    return render_template_string(LAYOUT, body=html+"</tbody></table>")

@app.route('/v2ray/add', methods=['POST'])
def v2ray_add():
    if not check_login(): return redirect('/login')
    u = request.form.get('u').strip()
    d = request.form.get('d', 30)
    mode = request.form.get('mode')
    custom = request.form.get('custom_uuid').strip()
    
    # Seleccion de UUID
    new_uuid = custom if mode == 'manual' and custom else str(uuid.uuid4())
    u = re.sub(r'[^a-zA-Z0-9]', '', u) # Limpiar nombre
    
    if os.path.exists(V2_CONF):
        with open(V2_CONF, 'r') as f: cfg = json.load(f)
        for inb in cfg['inbounds']:
            cl = {"email": u}
            if inb['protocol'] == 'trojan': cl['password'] = new_uuid
            else:
                cl['id'] = new_uuid
                if inb['protocol'] == 'vless':
                    try:
                        if inb['streamSettings']['security'] == 'reality': cl['flow'] = 'xtls-rprx-vision'
                    except: pass
            inb['settings']['clients'].append(cl)
            
        with open(V2_CONF, 'w') as f: json.dump(cfg, f, indent=2)
        
        # Guardar metadata de dias y UUID
        os.makedirs(DB_V2_USERS, exist_ok=True)
        exp = (datetime.datetime.now() + datetime.timedelta(days=int(d))).strftime("%Y-%m-%d")
        with open(f"{DB_V2_USERS}/{u}", "w") as f:
            f.write(f"UUID={new_uuid}\nEXP={exp}\nDURATION={d}")
            
        os.system("systemctl restart xray")
    return redirect('/v2ray')

@app.route('/v2ray/edit/<uname>', methods=['GET','POST'])
def v2ray_edit(uname):
    if not check_login(): return redirect('/login')
    meta_path = f"{DB_V2_USERS}/{uname}"
    
    if request.method == 'POST':
        new_uuid = request.form.get('uuid').strip()
        new_days = int(request.form.get('days', 30))
        
        if os.path.exists(V2_CONF):
            with open(V2_CONF, 'r') as f: cfg = json.load(f)
            for inb in cfg['inbounds']:
                for cl in inb['settings']['clients']:
                    if cl.get('email') == uname:
                        if inb['protocol'] == 'trojan': cl['password'] = new_uuid
                        else: cl['id'] = new_uuid
            with open(V2_CONF, 'w') as f: json.dump(cfg, f, indent=2)
            
            exp = (datetime.datetime.now() + datetime.timedelta(days=new_days)).strftime("%Y-%m-%d")
            with open(meta_path, 'w') as f:
                f.write(f"UUID={new_uuid}\nEXP={exp}\nDURATION={new_days}")
            
            os.system("systemctl restart xray")
            return redirect('/v2ray')
    
    # Cargar UUID actual para el input
    curr_uuid = ""
    if os.path.exists(meta_path):
        with open(meta_path, 'r') as f:
            for l in f:
                if "UUID=" in l: curr_uuid = l.split('=')[1].strip()
                
    form = f"""
    <h3>Editar Usuario: {uname}</h3>
    <div class='card'>
        <form method='post'>
            UUID / Clave Actual: <input name='uuid' value='{curr_uuid}' required>
            Dias de duracion desde hoy: <input name='days' type='number' value='30'>
            <br><button class='btn btn-green' style='width:100%; margin-top:10px;'>GUARDAR CAMBIOS</button>
        </form>
    </div>
    <a href='/v2ray' class='btn btn-red'>VOLVER</a>
    """
    return render_template_string(LAYOUT, body=form)

@app.route('/v2ray/link/<u>')
def v2ray_link(u):
    if not check_login(): return redirect('/login')
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        ip = get_cmd("curl -s ipv4.icanhazip.com")
        html = ""; js = ""; uuid_val = ""
        # Buscar el UUID del usuario
        for cl in c['inbounds'][0]['settings']['clients']:
             if cl.get('email') == u:
                 uuid_val = cl.get('id', cl.get('password'))
                 break
        if not uuid_val: return redirect('/v2ray')

        # Generar links para cada inbound activo
        for idx, inb in enumerate(c['inbounds']):
            p = inb['port']; proto = inb['protocol']
            s = inb['streamSettings']; net = s.get('network','tcp'); tls = s.get('security','none')
            path = s.get('wsSettings',{}).get('path','/')
            host = s.get('wsSettings',{}).get('headers',{}).get('Host','')
            nm = f"{u}-{proto}-{net}"
            lnk = ""
            if proto == "vmess":
                ps_obj = { "v": "2", "ps": nm, "add": ip, "port": p, "id": uuid_val, "aid": "0", "scy": "auto", "net": net, "type": "none", "host": host, "path": path, "tls": tls, "sni": host }
                lnk = "vmess://" + base64.b64encode(json.dumps(ps_obj).encode()).decode()
            elif proto == "vless":
                lnk = f"vless://{uuid_val}@{ip}:{p}?security={tls}&encryption=none&type={net}#{nm}"
            elif proto == "trojan":
                lnk = f"trojan://{uuid_val}@{ip}:{p}?security={tls}&type={net}#{nm}"
            
            html += f"<div class='card'><b>{proto.upper()} ({net})</b><br><textarea style='width:100%; background:#000; color:#0f0;'>{lnk}</textarea><div id='qr_{idx}' style='background:white; padding:10px; display:inline-block; margin-top:10px;'></div></div>"
            js += f"new QRCode(document.getElementById('qr_{idx}'), {{ text: '{lnk}', width: 200, height: 200 }});"
            
        return render_template_string(LAYOUT + f"<script>{js}</script>", body=f"<h3>Conexiones para {u}</h3>{html}<a href='/v2ray' class='btn btn-blue'>VOLVER</a>")
    except Exception as e: return f"Error: {e}"


@app.route('/protos')
def protos():
    if not check_login(): return redirect('/login')
    sd = get_slowdns_info(); st_sd = f"<span class='badge bg-on'>ON</span>" if sd['status'] == 'ON' else "<span class='badge bg-off'>OFF</span>"
    html = f"""<div class="card" style="border-top:3px solid #d35400;"><h3><i class="fas fa-network-wired"></i> SlowDNS Manager</h3><div class="grid-form"><div style="background:#222; padding:10px; border-radius:4px;"><small>ESTADO</small><br>{st_sd}</div><div style="background:#222; padding:10px; border-radius:4px;"><small>DOMINIO NS</small><br><b style="color:#d35400;">{sd['ns']}</b></div><div style="background:#222; padding:10px; border-radius:4px;"><small>PUERTOS ENTRADA</small><br><b>53, 5300 (UDP)</b></div><div style="background:#222; padding:10px; border-radius:4px;"><small>PTO SALIDA (TARGET)</small><br><b style="color:#27ae60;">{sd['out']}</b></div></div><div style="margin-top:15px; background:#222; padding:10px; word-break:break-all;"><small>SERVER.PUB</small><br><code style="color:#f1c40f;">{sd['pub']}</code></div><hr><form action="/slow/conf" method="POST" style="display:flex; gap:10px; align-items:center;"><label>Cambiar Salida:</label><input name="p" type="number" placeholder="Ej: 22" style="width:100px;"><button class="btn btn-org">Update</button></form><div style="margin-top:15px;"><a href="/svc/slow/start" class="btn btn-green">INICIAR</a> <a href="/svc/slow/stop" class="btn btn-red">DETENER</a></div></div>"""
    return render_template_string(LAYOUT, body=html)

@app.route('/slow/conf', methods=['POST'])
def slow_conf():
    if not check_login(): return redirect('/login')
    p = request.form.get('p')
    if p and os.path.exists(SLOW_SVC):
        # Actualizar puerto de salida en Systemd
        os.system(f"sed -i 's|127.0.0.1:[0-9]*|127.0.0.1:{p}|g' {SLOW_SVC}")
        os.system("systemctl daemon-reload")
        # Forzar redirecci�n puerto 5300
        os.system("iptables -t nat -D PREROUTING -p udp --dport 5300 -j REDIRECT --to-ports 53 2>/dev/null")
        os.system("iptables -t nat -I PREROUTING -p udp --dport 5300 -j REDIRECT --to-ports 53")
        os.system("systemctl restart slowdns-server")
        flash(f"Salida cambiada a {p} y Puerto 5300 activo.")
    return redirect('/protos')

@app.route('/svc/slow/<action>')
def slow_svc(action):
    if not check_login(): return redirect('/login')
    if action == "start":
        # Asegurar puerto 5300 al iniciar
        os.system("iptables -t nat -D PREROUTING -p udp --dport 5300 -j REDIRECT --to-ports 53 2>/dev/null")
        os.system("iptables -t nat -I PREROUTING -p udp --dport 5300 -j REDIRECT --to-ports 53")
        os.system("systemctl start slowdns-server"); flash("Servidor Iniciado")
    else:
        os.system("systemctl stop slowdns-server"); flash("Servidor Detenido")
    return redirect('/protos')

@app.route('/v2ray/del/<uname>')
def v2ray_del(uname):
    with open(V2_CONF) as f: cfg = json.load(f)
    for inb in cfg['inbounds']:
        inb['settings']['clients'] = [c for c in inb['settings']['clients'] if c.get('email') != uname]
    with open(V2_CONF, 'w') as f: json.dump(cfg, f, indent=2)
    if os.path.exists(f"{DB_V2}/{uname}"): os.remove(f"{DB_V2}/{uname}")
    os.system("systemctl restart xray"); return redirect('/v2ray')

@app.route('/tools')
def tools():
    if not check_login(): return redirect('/login')
    st_bbr = "ACTIVO" if "bbr" in get_cmd("sysctl net.ipv4.tcp_congestion_control") else "INACTIVO"
    st_bad = "ON" if os.system("pgrep -x badvpn-udpgw > /dev/null") == 0 else "OFF"
    ip_pub = get_cmd("curl -s ipv4.icanhazip.com")
    h = f"""<div class="card" style="border-top: 3px solid #007bff;"><h2><i class="fas fa-rocket"></i> Optimizacion</h2><div class="grid-form"><div style="background:#222; padding:15px; border-radius:6px; text-align:center;"><b>LIMPIAR RAM</b><br><a href="/action/clear_ram" class="btn btn-green" style="width:100%;">EJECUTAR</a></div><div style="background:#222; padding:15px; border-radius:6px; text-align:center;"><b>ACELERADOR BBR</b><br>Estado: <span style="color:{'#28a745' if st_bbr == 'ACTIVO' else '#dc3545'}">{st_bbr}</span><br><a href="/action/toggle_bbr" class="btn">CAMBIAR</a></div><div style="background:#222; padding:15px; border-radius:6px; text-align:center;"><b>BADVPN (7300)</b><br>Estado: {st_bad}<br><a href="/action/toggle_badvpn" class="btn btn-org">ON / OFF</a></div></div></div><div class="card" style="border-top: 3px solid #27ae60;"><h2><i class="fas fa-shield-alt"></i> Gestion de Backups Pro</h2><div class="grid-form"><div style="background:#222; padding:15px;"><a href="/backup/download" class="btn btn-green" style="width:100%;">DESCARGAR CLON</a></div><div style="background:#222; padding:15px;"><form action="/backup/restore/file" method="POST" enctype="multipart/form-data"><input type="file" name="file" required><button class="btn btn-org" style="width:100%;">SUBIR ARCHIVO</button></form></div></div></div>"""
    return render_template_string(LAYOUT, body=h)

@app.route('/v2ray/config_global', methods=['POST'])
def v2ray_config_global():
    if not check_login(): return redirect('/login')
    try:
        with open(V2_CONF, 'r') as f: cfg = json.load(f)
        for i in range(len(cfg['inbounds'])):
            new_p = request.form.get(f'p{i}')
            new_t = request.form.get(f't{i}')
            if new_p: cfg['inbounds'][i]['protocol'] = new_p
            if new_t: cfg['inbounds'][i]['streamSettings']['network'] = new_t
        
        with open(V2_CONF, 'w') as f: json.dump(cfg, f, indent=2)
        os.system("systemctl restart xray")
        flash("Configuracion Global Actualizada")
    except Exception as e: flash(f"Error: {e}")
    return redirect('/v2ray')

@app.route('/action/<cmd>')
def system_actions(cmd):
    if cmd == "clear_ram": os.system("sync; echo 3 > /proc/sys/vm/drop_caches")
    elif cmd == "toggle_bbr":
        if "bbr" in get_cmd("sysctl net.ipv4.tcp_congestion_control"): os.system("sed -i '/bbr/d' /etc/sysctl.conf; sysctl -p > /dev/null")
        else: os.system("echo 'net.core.default_qdisc=fq' >> /etc/sysctl.conf; echo 'net.ipv4.tcp_congestion_control=bbr' >> /etc/sysctl.conf; sysctl -p > /dev/null")
    elif cmd == "toggle_badvpn":
        if os.system("pgrep -x badvpn-udpgw > /dev/null") == 0: os.system("systemctl stop badvpn")
        else: os.system("systemctl start badvpn")
    flash("Accion ejecutada."); return redirect('/tools')

@app.route('/backup/download')
def backup_download():
    create_full_archive(); return send_file("/tmp/clone_pro.tar.gz", as_attachment=True)

def create_full_archive():
    b = "/tmp/reagens_web_clone"; os.system(f"rm -rf {b} /tmp/clone_pro.tar.gz; mkdir -p {b}/db {b}/conf")
    os.system(f"cp /etc/passwd /etc/shadow /etc/group /etc/gshadow {b}/; cp -r /etc/adm-lite {b}/db/")
    os.system(f"cd /tmp && tar -czf clone_pro.tar.gz reagens_web_clone/")

@app.route('/settings', methods=['GET','POST'])
def settings():
    if not check_login(): return redirect('/login')
    if request.method == 'POST':
        t = request.form.get('type')
        if t == "admin":
            u = request.form.get('u'); p = request.form.get('p')
            if u and p: open(AUTH_FILE, 'w').write(f"{u}:{p}"); flash("Admin Update")
        elif t == "token":
            p = request.form.get('p')
            if p: open(BASE_PASS_FILE, 'w').write(p); flash("Token Pass Update")
        elif t == "def_ssh":
            p = request.form.get('p')
            if p:
                with open(DEFAULT_SSH_PASS, 'w') as f: f.write(p)
                flash("Default SSH Pass Updated")
        elif t == "banner":
            b = request.form.get('content')
            if b:
                with open(BANNER_FILE, 'w') as f: f.write(b)
                os.system("service ssh restart >/dev/null 2>&1; service dropbear restart >/dev/null 2>&1")
                flash("Banner Updated")
        return redirect('/settings')
    
    bp = get_base_pass()
    
    # Read Default SSH Pass
    def_ssh_pass = ""
    if os.path.exists(DEFAULT_SSH_PASS):
        try: def_ssh_pass = open(DEFAULT_SSH_PASS).read().strip()
        except: pass
    
    # Read Banner
    banner_content = ""
    if os.path.exists(BANNER_FILE):
        try: banner_content = open(BANNER_FILE).read()
        except: pass

    h = f"""
    <div class="grid-form">
        <div class="card"><h3>Admin Panel</h3><form method="POST"><input type="hidden" name="type" value="admin"><label>New User</label><input name="u"><label>New Pass</label><input name="p"><button class="btn btn-org">Update</button></form></div>
        <div class="card"><h3>Token Pass Base</h3><form method="POST"><input type="hidden" name="type" value="token"><label>Current</label><input name="p" value="{bp}"><button class="btn btn-green">Save</button></form></div>
        <div class="card"><h3>Default SSH Pass</h3><form method="POST"><input type="hidden" name="type" value="def_ssh"><label>Current</label><input name="p" value="{def_ssh_pass}"><button class="btn btn-green">Save</button></form></div>
    </div>
    <div class="card">
        <h3>SSH Banner Editor (/etc/issue.net)</h3>
        <form method="POST">
            <input type="hidden" name="type" value="banner">
            <textarea name="content" rows="10" style="width:100%; background:#2c2c2c; color:#fff; border:1px solid #444; padding:10px;">{banner_content}</textarea>
            <br><br>
            <button class="btn btn-org">Save Banner</button>
        </form>
    </div>
    """
    return render_template_string(LAYOUT, body=h)

@app.route('/settings/update_v2_ports', methods=['POST'])
def update_v2_ports():
    np1, np2 = request.form.get('np1'), request.form.get('np2')
    if os.path.exists(V2_CONF):
        with open(V2_CONF, 'r') as f: config = json.load(f)
        if np1: config['inbounds'][0]['port'] = int(np1)
        if np2 and len(config['inbounds']) > 1: config['inbounds'][1]['port'] = int(np2)
        with open(V2_CONF, 'w') as f: json.dump(config, f, indent=2)
        os.system("systemctl restart xray")
        flash("Puertos Actualizados")
    return redirect('/settings')

@app.route('/user/renew/<u>')
def u_renew(u):
    td = datetime.datetime.now(); ne = (td + datetime.timedelta(days=30)).strftime("%Y-%m-%d"); os.system(f"chage -E '{ne}' {u}")
    for db in [DB_SSH_FILE, DB_TOKEN_FILE]:
        if os.path.exists(db):
            res = get_cmd(f"grep -w '^{u}' {db}")
            if res:
                pts = res.split('|'); pts[2] = ne; n_l = "|".join(pts); os.system(f"sed -i 's|^{res}|{n_l}|' {db}")
    flash(f"Usuario {u} renovado"); return redirect(request.referrer)

@app.route('/user/del/<u>')
def u_del(u):
    os.system(f"userdel --force {u}; sed -i '/^{u}|/d' {DB_TRAFFIC}; sed -i '/^{u}|/d' {DB_SSH_FILE}; sed -i '/^{u}|/d' {DB_TOKEN_FILE}"); return redirect(request.referrer)
@app.route('/user/lock/<u>')
def u_lock(u): os.system(f"passwd -l {u}"); return redirect(request.referrer)
@app.route('/user/unlock/<u>')
def u_unlock(u): os.system(f"passwd -u {u}"); return redirect(request.referrer)

if __name__ == '__main__': app.run(host='0.0.0.0', port=PORT)
EOF

                sed -i "s/PORT = 8081/PORT = $P_WEB_NEW/" /etc/reagens/panel_rvp.py
                cat <<'END_SERVICE' > /etc/systemd/system/rvp-panel.service
[Unit]
Description=Reagens Web Panel PRO
After=network.target
[Service]
ExecStart=/usr/bin/python3 /etc/reagens/panel_rvp.py
Restart=always
RestartSec=5
User=root
WorkingDirectory=/etc/reagens
[Install]
WantedBy=multi-user.target
END_SERVICE
                
                if [[ ! -f "/etc/reagens/panel_auth" ]]; then echo "admin:admin" > /etc/reagens/panel_auth; fi
                systemctl daemon-reload
                systemctl enable rvp-panel >/dev/null 2>&1
                systemctl restart rvp-panel
                iptables -I INPUT -p tcp --dport $P_WEB_NEW -j ACCEPT
                fun_save_iptables >/dev/null 2>&1
                
                sleep 2
                if systemctl is-active --quiet rvp-panel; then
                    IP=$(curl -s ipv4.icanhazip.com)
                    echo -e "\n${C_VERDE} PANEL PRO ACTUALIZADO CORRECTAMENTE.${C_RESET}"
                    echo -e " URL: http://$IP:$P_WEB_NEW"
                fi
                
                cat <<CMD_EOF > /usr/bin/r-vp
#!/bin/bash
IP=\$(curl -s ipv4.icanhazip.com)
PORT=$P_WEB_NEW
echo -e "\033[1;32m R-VP ONLINE: \033[1;37mhttp://\$IP:\$PORT\033[0m"
CMD_EOF
                chmod +x /usr/bin/r-vp
                read -p " Enter para continuar..."
                ;;
                
            2)
                echo -e "${C_ROJO} [!] ELIMINANDO PANEL...${C_RESET}"
                systemctl stop rvp-panel; systemctl disable rvp-panel
                rm -f /etc/systemd/system/rvp-panel.service /etc/reagens/panel_rvp.py /usr/bin/r-vp
                echo -e "${C_VERDE} Panel Eliminado.${C_RESET}"
                sleep 2
                ;;
                
            3) systemctl start rvp-panel; echo "Iniciado."; sleep 2 ;;
            4) systemctl stop rvp-panel; echo "Detenido."; sleep 2 ;;
            5)
                echo -n " Nuevo User: "; read u
                echo -n " Nueva Pass: "; read p
                if [[ ! -z "$u" && ! -z "$p" ]]; then
                    echo "$u:$p" > /etc/reagens/panel_auth
                    echo -e "${C_VERDE}Actualizado.${C_RESET}"
                fi
                sleep 2
                ;;
            0) break ;;
        esac
    done
}

menu_bot_telegram() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CREADOR DE BOTS DE TELEGRAM (PRO 2026) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if systemctl is-active --quiet reagens-bot; then 
            BOT_ST="${C_VERDE}ACTIVO${C_RESET}"
        else 
            BOT_ST="${C_ROJO}DETENIDO${C_RESET}"
        fi
        
        echo -e " ESTADO ACTUAL: $BOT_ST"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > CREAR Y ACTIVAR BOT (SISTEMA COMPLETO)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > DETENER BOT${C_RESET}"
        echo -e " ${C_TEXTO}[3] > ELIMINAR BOT${C_RESET}"
        echo -e " ${C_DATO}[4] > VER LOG DE ERRORES${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -ne " Opcion: "
        read op

        case $op in
            1)
                echo -e " ${C_DATO}[+] Instalando dependencias...${C_RESET}"
                pip3 install pyTelegramBotAPI requests --break-system-packages > /dev/null 2>&1 || pip3 install pyTelegramBotAPI requests > /dev/null 2>&1
                
                echo -e "\n ${C_TEXTO}Ingresa tu ${C_DATO}API TOKEN${C_TEXTO}:${C_RESET}"
                read -p "> " TOKEN
                echo -e " ${C_TEXTO}Ingresa tu ${C_DATO}ID de Telegram${C_TEXTO}:${C_RESET}"
                read -p "> " ADMIN_ID
                
                if [[ -z "$TOKEN" || -z "$ADMIN_ID" ]]; then 
                    echo -e "${C_ROJO}[X] Error: Faltan datos.${C_RESET}"; sleep 2; continue
                fi

                cat <<'PYTHON' > "$BOT_SCRIPT"
# -*- coding: utf-8 -*-
import telebot, subprocess, os, json, datetime, time, uuid, base64, re, requests
from telebot import types
from datetime import datetime, timedelta

TOKEN = "$TOKEN"
ADMIN_ID = $ADMIN_ID

# Rutas
DB_SSH = "/etc/adm-lite/usuarios_ssh.db"
DB_TOKENS = "/etc/adm-lite/usuarios_token.db"
DB_TRAFFIC = "/etc/reagens/traffic.db"
V2_CONF = "/usr/local/etc/xray/config.json"
DB_V2_USERS = "/etc/reagens/users/v2ray"

bot = telebot.TeleBot(TOKEN)

def is_admin(m): return str(m.from_user.id) == str(ADMIN_ID)

def shell(cmd):
    try: return subprocess.check_output(cmd, shell=True).decode().strip()
    except: return ""

def add_traffic_user(user):
    os.system(f"sed -i '/^{user}|/d' {DB_TRAFFIC}")
    with open(DB_TRAFFIC, 'a') as f: f.write(f"{user}|0|0|1\n")
    os.system(f"iptables -I OUTPUT -m owner --uid-owner {user} -j ACCEPT 2>/dev/null")

def gen_v2ray_links(user, uuid_val):
    if not os.path.exists(V2_CONF): return "?? Xray no instalado."
    try:
        with open(V2_CONF, 'r') as f: config = json.load(f)
        ip = shell("curl -s ipv4.icanhazip.com")
        all_links = ""
        for idx, inb in enumerate(config['inbounds']):
            proto = inb.get('protocol')
            port = inb.get('port')
            stream = inb.get('streamSettings', {})
            net = stream.get('network', 'tcp')
            sec = stream.get('security', 'none')
            path = stream.get('wsSettings', {}).get('path', '/')
            host = stream.get('wsSettings', {}).get('headers', {}).get('Host', '')
            sni = stream.get('tlsSettings', {}).get('serverName', '')
            if sec == 'reality': sni = stream.get('realitySettings', {}).get('serverNames', [''])[0]
            name = f"REAGENS-{user}-{proto.upper()}"
            if proto == "vmess":
                js = {"v":"2","ps":name,"add":ip,"port":port,"id":uuid_val,"aid":"0","scy":"auto","net":net,"type":"none","tls":sec,"sni":sni,"path":path,"host":host}
                link = "vmess://" + base64.b64encode(json.dumps(js).encode()).decode()
            elif proto == "vless":
                link = f"vless://{uuid_val}@{ip}:{port}?security={sec}&type={net}&sni={sni}&path={path}&host={host}#{name}"
            elif proto == "trojan":
                link = f"trojan://{uuid_val}@{ip}:{port}?security={sec}&type={net}&sni={sni}#{name}"
            else: continue
            all_links += f"?? **Opcion {idx+1}:**\n<code>{link}</code>\n\n"
        return all_links
    except: return "?? Error generando links."

@bot.message_handler(commands=['start', 'menu', 'ayuda'])
def main_menu(m):
    if not is_admin(m): return
    txt = (
        "?? **PANEL DE CONTROL VPS**\n"
        "??????????????????\n"
        "?? **SSH / DROPBEAR:**\n"
        "<code>/addssh user clave dias limit</code>\n"
        "<code>/editssh user dias limit</code>\n"
        "<code>/delssh user</code>\n"
        "<code>/listssh1</code> | <code>/listssh2</code>\n\n"
        "?? **TOKEN ID (APPS):**\n"
        "<code>/addtoken ID dias Nombre</code>\n"
        "<code>/edittoken ID dias</code>\n"
        "<code>/deltoken ID</code>\n"
        "<code>/listtoken1</code> | <code>/listtoken2</code>\n\n"
        "?? **XRAY / V2RAY:**\n"
        "<code>/addv2 user dias uuid</code> (N=auto)\n"
        "<code>/editv2 user dias uuid</code> (N=mantener)\n"
        "<code>/delv2 user</code>\n"
        "<code>/listv2</code>\n"
        "??????????????????"
    )
    bot.reply_to(m, txt, parse_mode="HTML")

# --- COMANDOS SSH ---
@bot.message_handler(commands=['addssh'])
def a_ssh(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 5:
        bot.reply_to(m, "? **Uso:** `/addssh usuario clave dias limite`", parse_mode="HTML")
        return
    u, pw, d, l = args[1], args[2], args[3], args[4]
    fd = (datetime.now() + timedelta(days=int(d))).strftime("%Y-%m-%d")
    os.system(f"useradd -M -s /bin/false {u}; echo '{u}:{pw}' | chpasswd; chage -E '{fd}' {u}")
    add_traffic_user(u)
    with open(DB_SSH, 'a') as f: f.write(f"{u}|{pw}|{fd}|{l}|0\n")
    bot.reply_to(m, f"? SSH <code>{u}</code> creado.", parse_mode="HTML")

@bot.message_handler(commands=['editssh'])
def e_ssh(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 4:
        bot.reply_to(m, "? **Uso:** `/editssh user dias limit`", parse_mode="HTML")
        return
    u, d, l = args[1], args[2], args[3]
    old = shell(f"grep -w '^{u}' {DB_SSH}")
    if old:
        fd = (datetime.now() + timedelta(days=int(d))).strftime("%Y-%m-%d")
        os.system(f"chage -E '{fd}' {u}")
        pts = old.split('|'); n_l = f"{u}|{pts[1]}|{fd}|{l}|0"
        os.system(f"sed -i 's|^{re.escape(old)}|{n_l}|' {DB_SSH}")
        bot.reply_to(m, "? SSH actualizado.")
    else: bot.reply_to(m, "? No existe.")

@bot.message_handler(commands=['blockssh', 'unblockssh', 'blocktoken', 'unblocktoken'])
def handle_lock(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 2: return
    u = args[1]
    cmd = "passwd -l" if "unblock" not in m.text and "block" in m.text else "passwd -u"
    os.system(f"{cmd} {u}; pkill -u {u}")
    bot.reply_to(m, f"?? Usuario {u} gestionado.")

@bot.message_handler(commands=['delssh', 'deltoken'])
def handle_del(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 2: return
    u = args[1]
    db = DB_SSH if "ssh" in m.text else DB_TOKENS
    os.system(f"userdel -f {u}; sed -i '/^{u}|/d' {db}; sed -i '/^{u}|/d' {DB_TRAFFIC}")
    bot.reply_to(m, f"?? Eliminado: {u}")

@bot.message_handler(commands=['listssh1', 'listtoken1', 'listssh2', 'listtoken2'])
def handle_lists(m):
    if not is_admin(m): return
    cmd = m.text.split()[0]
    db = DB_SSH if "ssh" in cmd else DB_TOKENS
    if "1" in cmd:
        msg = "?? **DETALLES**\n"
        if os.path.exists(db):
            with open(db, 'r') as f:
                for l in f:
                    p = l.strip().split('|')
                    if len(p) >= 3: msg += f"?? <code>{p[0]}</code> | Exp: {p[2]}\n"
        bot.send_message(m.chat.id, msg if len(msg)>20 else "Vacio.", parse_mode="HTML")
    else:
        msg = "?? **ONLINE**\n"
        if os.path.exists(db):
            with open(db, 'r') as f:
                for l in f:
                    u = l.strip().split('|')[0]
                    con = shell(f"pgrep -u {u} -f 'sshd|dropbear' | wc -l")
                    ico = "?" if int(con or 0)>0 else "?"
                    msg += f"{ico} <code>{u}</code>: {con}\n"
        bot.send_message(m.chat.id, msg, parse_mode="HTML")

# --- TOKEN ID ---
@bot.message_handler(commands=['addtoken'])
def a_tok(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 4:
        bot.reply_to(m, "? **Uso:** `/addtoken ID dias Nombre`", parse_mode="HTML")
        return
    u, d, nom = args[1], args[2], args[3]
    pw = shell("cat /etc/reagens_base_pass") or "123456"
    fd = (datetime.now() + timedelta(days=int(d))).strftime("%Y-%m-%d")
    os.system(f"useradd -M -s /bin/false -c '{nom}' {u}; echo '{u}:{pw}' | chpasswd; chage -E '{fd}' {u}")
    add_traffic_user(u)
    with open(DB_TOKENS, 'a') as f: f.write(f"{u}|{nom}|{fd}|0\n")
    bot.reply_to(m, f"? Token <code>{u}</code> creado.", parse_mode="HTML")

@bot.message_handler(commands=['edittoken'])
def e_tok(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 3: return
    u, d = args[1], args[2]
    old = shell(f"grep -w '^{u}' {DB_TOKENS}")
    if old:
        fd = (datetime.now() + timedelta(days=int(d))).strftime("%Y-%m-%d")
        os.system(f"chage -E '{fd}' {u}")
        pts = old.split('|'); n_l = f"{u}|{pts[1]}|{fd}|0"
        os.system(f"sed -i 's|^{re.escape(old)}|{n_l}|' {DB_TOKENS}")
        bot.reply_to(m, "? Token actualizado.")

# --- V2RAY ---
@bot.message_handler(commands=['addv2'])
def a_v2(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 4:
        bot.reply_to(m, "? **Uso:** `/addv2 user dias uuid` (N=auto)", parse_mode="HTML")
        return
    try:
        u, d, uuid_in = args[1], args[2], args[3]
        uv = str(uuid.uuid4()) if uuid_in.upper() == 'N' else uuid_in
        with open(V2_CONF, 'r') as f: c = json.load(f)
        for inb in c['inbounds']:
            cl = {"email": u}
            if inb['protocol'] in ["vmess", "vless"]: cl["id"] = uv
            if inb['protocol'] == "trojan": cl["password"] = uv
            inb['settings']['clients'].append(cl)
        with open(V2_CONF, 'w') as f: json.dump(c, f, indent=2)
        os.system("systemctl restart xray")
        fd = (datetime.now() + timedelta(days=int(d))).strftime("%Y-%m-%d")
        os.makedirs(DB_V2_USERS, exist_ok=True)
        with open(f"{DB_V2_USERS}/{u}", "w") as f: f.write(f"EXP={fd}\nUUID={uv}\n")
        bot.reply_to(m, f"? **V2Ray Creado**\n\n{gen_v2ray_links(u, uv)}", parse_mode="HTML")
    except Exception as e: bot.reply_to(m, f"Error: {e}")

@bot.message_handler(commands=['editv2'])
def e_v2(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 4:
        bot.reply_to(m, "? **Uso:** `/editv2 user dias uuid` (N=mantener)", parse_mode="HTML")
        return
    try:
        u, d, uuid_in = args[1], args[2], args[3]
        mf = f"{DB_V2_USERS}/{u}"
        curr_uuid = ""
        if os.path.exists(mf):
            with open(mf, 'r') as f:
                for line in f:
                    if "UUID=" in line: curr_uuid = line.split('=')[1].strip()
        final_uuid = curr_uuid if uuid_in.upper() == 'N' else uuid_in
        with open(V2_CONF, 'r') as f: c = json.load(f)
        for inb in c['inbounds']:
            for cl in inb['settings']['clients']:
                if cl.get('email') == u:
                    if inb['protocol'] == 'trojan': cl['password'] = final_uuid
                    else: cl['id'] = final_uuid
        with open(V2_CONF, 'w') as f: json.dump(c, f, indent=2)
        os.system("systemctl restart xray")
        fd = (datetime.now() + timedelta(days=int(d))).strftime("%Y-%m-%d")
        with open(mf, "w") as f: f.write(f"EXP={fd}\nUUID={final_uuid}\n")
        bot.reply_to(m, f"? **Actualizado**\n\n{gen_v2ray_links(u, final_uuid)}", parse_mode="HTML")
    except Exception as e: bot.reply_to(m, f"Error: {e}")

@bot.message_handler(commands=['delv2'])
def d_v2(m):
    if not is_admin(m): return
    args = m.text.split()
    if len(args) < 2: return
    u = args[1]
    with open(V2_CONF, 'r') as f: c = json.load(f)
    for inb in c['inbounds']:
        inb['settings']['clients'] = [x for x in inb['settings']['clients'] if x.get('email') != u]
    with open(V2_CONF, 'w') as f: json.dump(c, f, indent=2)
    os.system("systemctl restart xray")
    if os.path.exists(f"{DB_V2_USERS}/{u}"): os.remove(f"{DB_V2_USERS}/{u}")
    bot.reply_to(m, f"?? V2Ray {u} borrado.")

# --- NUEVA LOGICA /LISTV2 DETALLADA ---
@bot.message_handler(commands=['listv2'])
def l_v2(m):
    if not is_admin(m): return
    if not os.path.exists(V2_CONF): return
    try:
        with open(V2_CONF) as f: c = json.load(f)
        clients = c['inbounds'][0]['settings']['clients']
        if not clients:
            bot.send_message(m.chat.id, "? No hay usuarios V2Ray.")
            return

        for x in clients:
            u = x.get('email')
            # El UUID lo sacamos del primer inbound disponible
            uid = x.get('id') or x.get('password')
            exp = "---"
            mf = f"{DB_V2_USERS}/{u}"
            if os.path.exists(mf):
                with open(mf, 'r') as fm:
                    for line in fm:
                        if "EXP=" in line: exp = line.split('=')[1].strip()
            
            # Generamos los links reales del sistema para este usuario
            links = gen_v2ray_links(u, uid)
            
            msg = (f"?? **USUARIO V2RAY**\n"
                   f"??????????????????\n"
                   f"?? **User:** <code>{u}</code>\n"
                   f"?? **UUID:** <code>{uid}</code>\n"
                   f"?? **Vence:** <code>{exp}</code>\n\n"
                   f"{links}"
                   f"??????????????????")
            bot.send_message(m.chat.id, msg, parse_mode="HTML")
    except: bot.reply_to(m, "Error al listar V2Ray.")

bot.polling(none_stop=True)
PYTHON
                sed -i "s/\$TOKEN/$TOKEN/" "$BOT_SCRIPT"
                sed -i "s/\$ADMIN_ID/$ADMIN_ID/" "$BOT_SCRIPT"
                cat <<EOF > "$BOT_SERVICE"
[Unit]
Description=Reagens Bot Telegram PRO
After=network.target
[Service]
ExecStart=/usr/bin/python3 $BOT_SCRIPT
Restart=always
RestartSec=5
User=root
[Install]
WantedBy=multi-user.target
EOF
                systemctl daemon-reload
                systemctl enable reagens-bot >/dev/null 2>&1
                systemctl restart reagens-bot
                echo -e " ${C_VERDE}BOT PRO ACTUALIZADO CON LISTADO DETALLADO.${C_RESET}"; sleep 2 ;;
            2) systemctl stop reagens-bot; echo "Detenido."; sleep 2 ;;
            3) systemctl stop reagens-bot; systemctl disable reagens-bot; rm -f "$BOT_SCRIPT" "$BOT_SERVICE"; echo "Eliminado."; sleep 2 ;;
            4) journalctl -u reagens-bot -n 30 --no-pager; read -p "Enter..." ;;
            0) break ;;
        esac
    done
}

# 5. MENU PRINCIPAL DE CONEXIONES (EL QUE NOABRIA)
menu_conexiones() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} ADMINISTRADOR DE CONEXIONES ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]  > GESTION CUENTAS SSH / DROPBEAR${C_RESET}"
        echo -e " ${C_TEXTO}[2]  > GESTION CUENTAS XRAY / V2RAY${C_RESET}"
        echo -e " ${C_DATO}[3]  > GESTION HYSTERIA V2 (UDP ACCEL)${C_RESET}"
        echo -e " ${C_DATO}[4]  > GESTION TOKENS (APP ID)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU PRINCIPAL${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op_c
        case $op_c in
            1) menu_ssh ;;
            2) menu_v2ray ;;
            3) menu_hysteria ;;
            4) menu_tokens ;;
            0) break ;;
        esac
    done
}

# --- FUNCION ACTUALIZAR SISTEMA REPARADA (FIX BAD INTERPRETER) ---
fun_update_system() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} ACTUALIZADOR AUTOMATICO REAGENS PRO ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_DATO}[+] Descargando instalador oficial...${C_RESET}"
    
    # 1. Descargar el instalador
    wget -O /root/setup.sh "https://gitlab.com/reagensjp/reagens-scritp/-/raw/main/setup.sh" >/dev/null 2>&1
    chmod +x /root/setup.sh
    
    # 2. LIMPIEZA QUIRURGICA (Elimina el error ^M / bad interpreter)
    sed -i 's/\r$//' /root/setup.sh
    
    echo -e " ${C_DATO}[+] Verificando estado de licencia por IP...${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    sleep 2
    
    # 3. Ejecutar el instalador limpio
    clear
    /bin/bash /root/setup.sh
    
    # Salir para que los cambios surtan efecto
    exit 0
}

# --- GESTOR UDP-CUSTOM REPARADO (SOPORTE HTTP CUSTOM) ---
fun_udp_custom() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} UDP-CUSTOM PRO: CONSTRUCTOR UNIVERSAL ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    s_udp=$(systemctl is-active --quiet udp-custom && echo -e "${C_VERDE}ONLINE${C_RESET}" || echo -e "${C_ROJO}OFFLINE${C_RESET}")
    echo -e " ESTADO ACTUAL: $s_udp"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_TEXTO}[1] > CONSTRUIR E INSTALAR (M�TODO INFALIBLE)${C_RESET}"
    echo -e " ${C_TEXTO}[2] > DETENER SERVICIO${C_RESET}"
    echo -e " ${C_TEXTO}[3] > ELIMINAR TODO${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
    echo -ne "\n Opcion: "
    read op_udp

    case $op_udp in
        1)
            echo -e " ${C_DATO}[+] Instalando herramientas de compilaci�n...${C_RESET}"
            if [[ -f /etc/redhat-release ]]; then
                yum install -y gcc git make &>/dev/null
            else
                apt-get update &>/dev/null
                apt-get install -y gcc git make &>/dev/null
            fi

            echo -e " ${C_DATO}[+] Limpiando basura previa...${C_RESET}"
            systemctl stop udp-custom &>/dev/null
            rm -f /usr/bin/udp-custom
            mkdir -p /etc/udp-custom

            # --- CONSTRUCCI�N DEL C�DIGO FUENTE (C NEGRO) ---
            # Escribimos un relay de alto rendimiento directamente en el disco
            cat <<'EOF' > /etc/udp-custom/main.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

struct relay { int udp_sock; struct sockaddr_in client_addr; int tcp_port; };

void *udp_to_tcp(void *arg) {
    struct relay *r = (struct relay *)arg;
    int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in serv_addr = { .sin_family = AF_INET, .sin_port = htons(r->tcp_port) };
    inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr);

    if (connect(tcp_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        close(tcp_sock); free(r); return NULL;
    }

    char buf[4096];
    int n;
    while ((n = recv(tcp_sock, buf, sizeof(buf), 0)) > 0) {
        sendto(r->udp_sock, buf, n, 0, (struct sockaddr *)&r->client_addr, sizeof(r->client_addr));
    }
    close(tcp_sock); free(r); return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 2) return 1;
    int port = atoi(argv[1]);
    int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(port) };
    bind(udp_sock, (struct sockaddr *)&addr, sizeof(addr));

    while (1) {
        char buf[4096];
        struct sockaddr_in client_addr;
        socklen_t len = sizeof(client_addr);
        int n = recvfrom(udp_sock, buf, sizeof(buf), 0, (struct sockaddr *)&client_addr, &len);
        if (n > 0) {
            struct relay *r = malloc(sizeof(struct relay));
            r->udp_sock = udp_sock; r->client_addr = client_addr; r->tcp_port = 22;
            pthread_t tid;
            pthread_create(&tid, NULL, udp_to_tcp, r);
            pthread_detach(tid);
        }
    }
    return 0;
}
EOF

            echo -e " ${C_DATO}[+] Compilando binario personalizado para tu procesador...${C_RESET}"
            gcc /etc/udp-custom/main.c -o /usr/bin/udp-custom -lpthread
            
            if [[ ! -f "/usr/bin/udp-custom" ]]; then
                echo -e "${C_ROJO} [X] Error fatal: No se pudo compilar el binario.${C_RESET}"
                read -p " Enter..." ; return
            fi
            chmod +x /usr/bin/udp-custom

            echo -n " Ingrese Puerto UDP [Default 36712]: "
            read p_u
            [[ -z "$p_u" ]] && p_u=36712
            fuser -k $p_u/udp &>/dev/null

            # Servicio Systemd
            cat <<EOF > /etc/systemd/system/udp-custom.service
[Unit]
Description=Reagens UDP-Custom Built-in
After=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/bin/udp-custom $p_u
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF

            echo -e " ${C_DATO}[+] Activando sistema y optimizando red...${C_RESET}"
            systemctl daemon-reload
            systemctl enable udp-custom &>/dev/null
            systemctl restart udp-custom
            
            iptables -I INPUT -p udp --dport $p_u -j ACCEPT
            fun_save_iptables >/dev/null 2>&1
            
            sleep 2
            if systemctl is-active --quiet udp-custom; then
                echo -e "${C_VERDE} [OK] �SISTEMA CONSTRUIDO Y ONLINE EN PUERTO $p_u!${C_RESET}"
                echo -e " Este binario es 100% compatible con tu CPU actual."
            else
                echo -e "${C_ROJO} [FALLO] Error al arrancar el binario compilado.${C_RESET}"
            fi
            read -p " Presione Enter para finalizar y celebrar..."
            ;;
        2) systemctl stop udp-custom; echo -e "${C_ROJO}Detenido.${C_RESET}"; sleep 2 ;;
        3) 
            systemctl stop udp-custom; systemctl disable udp-custom &>/dev/null
            rm -f /etc/systemd/system/udp-custom.service /usr/bin/udp-custom
            rm -rf /etc/udp-custom
            echo -e "${C_ROJO}Sistema Limpiado.${C_RESET}"; sleep 2 ;;
        0) return ;;
    esac
}

# --- ACTIVACI�N FINAL (ORDEN CORRECTO) ---
mkdir -p /etc/adm-lite  # Aseguramos que existan antes de activar
restore_traffic_rules   # Ahora Bash ya sabe qu� es esta funci�n
install_traffic_service # Ahora Bash ya sabe qu� es esta funci�n
fun_fix_permissions     # Aplicamos blindaje final

# --- MENU PRINCIPAL FINAL (OPTIMIZADO V4 - ASINCRONO + REFRESCO VISUAL) ---
clear
while true; do
    obtener_datos # Carga instantanea (datos viejos) + Lanza proceso de actualizacion
    if command -v tput &>/dev/null; then tput cup 0 0; else clear; fi

    echo -e "${C_BARRA}======================================================${C_RESET}"
    msg_center "${C_TITULO} HIRVIP VPN PRO MANAGER FOR VPS ${C_RESET}"
    echo -e "${C_BARRA}======================================================${C_RESET}"
    
    printf "${C_BARRA}| ${C_TEXTO}%-19s${C_BARRA}| ${C_TEXTO}%-14s${C_BARRA}| ${C_TEXTO}%-14s${C_BARRA}|${C_RESET}\n" "SISTEMA" "MEMORIA" "PROCESADOR"
    echo -e "${C_BARRA}|--------------------|---------------|---------------|${C_RESET}"

    printf "${C_BARRA}|${C_TEXTO} S.O: %-14s${C_BARRA}|${C_TEXTO} RAM: %-9s${C_BARRA}|${C_TEXTO} CPU: %-9s${C_BARRA}|${C_RESET}\n" "${OS_NAME:0:14}" "$RAM_TOTAL" "$CPU_CORES"
    printf "${C_BARRA}|${C_TEXTO} IP:  %-14s${C_BARRA}|${C_TEXTO} USE: %-9s${C_BARRA}|${C_TEXTO} USE: %-9s${C_BARRA}|${C_RESET}\n" "${IP_DISP:0:14}" "$RAM_USED" "$CPU_USAGE"
    printf "${C_BARRA}|${C_TEXTO} FEC: %-14s${C_BARRA}|${C_TEXTO} LIB: %-9s${C_BARRA}|${C_TEXTO} %-14s${C_BARRA}|${C_RESET}\n" "$FECHA_ACT" "$RAM_FREE" "${CPU_INFO:0:14}"
    printf "${C_BARRA}|${C_TEXTO} HOR: %-14s${C_BARRA}|${C_TEXTO} TOT: %-9s${C_BARRA}|${C_TEXTO} %-14s${C_BARRA}|${C_RESET}\n" "$HORA_ACT" "$RAM_PERC" ""

    echo -e "${C_BARRA}======================================================${C_RESET}"
    printf "${C_BARRA}|${C_TEXTO} ONLI: ${C_VERDE}%-4s${C_TEXTO} EXP: ${C_ROJO}%-4s${C_TEXTO} LOK: ${C_DATO}%-4s${C_TEXTO} TOTAL: %-13s${C_BARRA}|${C_RESET}\n" "$ONLI_USR" "$EXP_USR" "$LOK_USR" "$TOTAL_USR"
    echo -e "${C_BARRA}======================================================${C_RESET}"
    
    echo -e " ${C_TEXTO}[1] > ADMINISTRADOR DE CONEXIONES (SSH/Xray/Hysteria)${C_RESET}"
    echo -e " ${C_TEXTO}[2] > AJUSTES DEL SISTEMA (Puertos/Hora/Tools)${C_RESET}"
    echo -e " ${C_TEXTO}[3] > CREAR BOT TELEGRAM${C_RESET}"
    echo -e " ${C_VERDE}[5] > ACTUALIZAR SISTEMA REAGENS PRO${C_RESET}" # <-- NUEVA OPCION
    echo -e "${C_BARRA}------------------------------------------------------${C_RESET}"
    echo -e " ${C_ROJO}[4] > [!] DESINSTALAR SISTEMA HIRVIP VPN PRO${C_RESET}"    
    echo -e "${C_BARRA}======================================================${C_RESET}"
    echo -e " ${C_TEXTO}0) SALIR DEL VPS  8) SALIR DEL SCRIPT  9) REBOOT VPS${C_RESET}"
    echo -e "${C_BARRA}======================================================${C_RESET}"
    echo ""
    echo -n " Seleccione una Opcion: "
    
    # Mantenemos el refresco de 1s para que la hora se mueva y no se vea plano
    # Pero como obtener_datos es ASINCRONO, ya no se trabara.
    read -t 1 -n 1 opcion
    
    if [[ -z "$opcion" ]]; then continue; fi
    
    case $opcion in
        1) menu_conexiones; clear;;
        2) menu_ajustes; clear;;
        3) menu_bot_telegram ;;
        4) fun_deep_clean ;;
        5) fun_update_system ;;
        8) fun_salir_script;;
        9) clear; reboot;;
        0) clear; exit 0;;
        *) ;;
    esac
done