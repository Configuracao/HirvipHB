#!/bin/bash

### --- ZONA DE VARIABLES (INICIO) --- ###
# Directorios y Archivos de Base de Datos
DB_ROOT="/etc/reagens"
mkdir -p "$DB_ROOT"
DB_TRAFFIC="$DB_ROOT/traffic.db"

# --- BLINDAJE DE SEGURIDAD REAGENS ---
fun_fix_permissions() {
    # Carpeta de bases de datos
    chmod 700 /etc/adm-lite
    chmod 700 /etc/reagens
    
    # Archivos sensibles (Solo root lee/escribe)
    chmod 600 /etc/adm-lite/*.db 2>/dev/null
    chmod 600 /etc/reagens/traffic.db 2>/dev/null
    chmod 600 /etc/reagens_base_pass 2>/dev/null
    chmod 600 /etc/reagens/default_pass 2>/dev/null
    
    # Scripts y Binarios (Solo root ejecuta)
    chmod 700 /etc/reagens/bin/* 2>/dev/null
}

# Ejecutar al iniciar el script
fun_fix_permissions
# --- CREAR ACCESO DIRECTO 'menu' ---
if [[ ! -f "/usr/bin/menu" ]]; then
    ln -s "$(readlink -f "$0")" /usr/bin/menu
    chmod +x /usr/bin/menu
    # Opcional: Hacer que el menú abra solo al loguear
    echo "menu" >> /root/.bashrc
fi

# Base de datos SSH y Tokens
mkdir -p /etc/adm-lite
DB_SSH="/etc/adm-lite/usuarios_ssh.db"
DB_TOKENS="/etc/adm-lite/usuarios_token.db"

# --- FIX ALMALINUX / RHEL ---
# Creamos los archivos vacios AHORA para que no den error al leerlos luego
if [[ ! -f "$DB_SSH" ]]; then touch "$DB_SSH"; fi
if [[ ! -f "$DB_TOKENS" ]]; then touch "$DB_TOKENS"; fi
if [[ ! -f "$DB_TRAFFIC" ]]; then touch "$DB_TRAFFIC"; fi
### ---------------------------------- ###

# ==================================================
# REAGENS VPN PRO MANAGER FOR VPS - FINAL TRAFFIC EDITION
# INCLUYE: SSH, TOKEN, XRAY, HYSTERIA, SLOWDNS, UDP
# SISTEMA DE CUOTAS (MB) REAL + PERSISTENCIA
# ==================================================

# --- COLORES Y ESTILOS ---
C_BARRA='\033[1;34m'      # Azul Fuerte
C_TITULO='\033[1;44;37m'  # Fondo Azul, Letra Blanca
C_TEXTO='\033[1;37m'      # Blanco
C_DATO='\033[1;33m'       # Amarillo
C_ROJO='\033[1;31m'       # Rojo
C_VERDE='\033[1;32m'      # Verde
C_RESET='\033[0m'         # Reset

# --- BASE DE DATOS DE TRAFICO (NUEVO SISTEMA) ---
DB_ROOT="/etc/reagens"
DB_TRAFFIC="$DB_ROOT/traffic.db"
mkdir -p "$DB_ROOT"
touch "$DB_TRAFFIC"

# --- DIRECTORIOS Y ARCHIVOS ---
if [[ -f "/usr/local/etc/xray/config.json" ]]; then
    V2RAY_CONF="/usr/local/etc/xray/config.json"
    SERVICE_NAME="xray"
elif [[ -f "/usr/local/etc/v2ray/config.json" ]]; then
    V2RAY_CONF="/usr/local/etc/v2ray/config.json"
    SERVICE_NAME="v2ray"
else
    V2RAY_CONF="/usr/local/etc/xray/config.json"
    SERVICE_NAME="xray"
fi

# DIRECTORIOS HYSTERIA
HY_CONF="/etc/hysteria/config.yaml"
HY_DIR="/etc/hysteria"
HY_USERS_DB="/etc/reagens/users/hysteria"

# DIRECTORIOS NUEVOS (SLOWDNS & UDP CUSTOM)
SLOWDNS_DIR="/etc/slowdns"
UDP_DIR="/etc/udp-custom"
UDP_BIN="$UDP_DIR/udp-custom"

DB_USERS="/etc/reagens/users"
mkdir -p "$DB_USERS"
mkdir -p "$DB_USERS/v2ray"
mkdir -p "$HY_USERS_DB"
mkdir -p "/etc/reagens/bot"
FILE_PASS="/etc/reagens/default_pass"
TOKEN_PASS_FILE="/etc/reagens_base_pass"

GUARD_BIN="/usr/local/bin/reagens-guard"
MONITOR_BIN="/usr/local/bin/reagens-monitor" 
CHECKUSER_BIN="/etc/reagens/bin/checkuser.py"
CHECKUSER_SERVICE="/etc/systemd/system/checkuser-reagens.service"
BOT_SCRIPT="/etc/reagens/bot/reagens_bot.py"
BOT_SERVICE="/etc/systemd/system/reagens-bot.service"

# --- DEPENDENCIAS UNIVERSALES (OPTIMIZADO - NO LAG AL INICIO) ---
# Solo verifica paquetes si NO existe el archivo de control.
if [[ ! -f "/etc/reagens/.install_check" ]]; then
    echo "Verificando dependencias por primera vez..."
    if [[ -f /etc/redhat-release ]]; then
        PM="yum"
        CMD_CHECK="rpm -q"
        PKG_LIST="jq psmisc bc nano git curl socat net-tools python3-pip iptables iptables-services lsof dropbear wget cmake make gcc unzip openssl gnupg2 bind-utils"
    else
        PM="apt-get"
        CMD_CHECK="dpkg -s"
        PKG_LIST="jq psmisc bc nano git curl socat net-tools python3-pip iptables iptables-persistent lsof dropbear wget cmake make gcc build-essential unzip uuid-runtime openssl gnupg dnsutils"
    fi

    for p in $PKG_LIST; do
        if ! command -v $p &> /dev/null; then 
            $PM install -y $p > /dev/null 2>&1
        fi
    done
    # Crear archivo bandera para no volver a chequear
    touch "/etc/reagens/.install_check"
fi

# --- FUNCION PARA CENTRAR TITULOS (MEJORADA) ---
msg_center() {
  local text="$1"
  local clean_text=$(echo -e "$text" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g")
  local len=${#clean_text}
  local cols=53 # Ancho fijo para tu menú
  local space=$(( ($cols - $len) / 2 ))
  [[ $space -lt 0 ]] && space=0
  printf "%${space}s" " "
  echo -e "$text"
}

# --- VERIFICADOR DE CONFLICTOS DE PUERTOS ---
fun_check_port() {
    local port=$1
    local service_name=$2
    
    # Verifica si el puerto está siendo escuchado
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null ; then
        local process=$(lsof -i :$port | awk 'NR==2 {print $1}')
        echo -e "${C_ROJO}[X] ERROR: El puerto $port ya está ocupado por: $process.${C_RESET}"
        echo -e "${C_DATO}[!] Detén ese servicio antes de instalar $service_name.${C_RESET}"
        return 1 # Puerto ocupado
    else
        return 0 # Puerto libre
    fi
}

# --- GUARDADO PERSISTENTE DE REGLAS (CORRECCIÓN DEFINITIVA) ---
fun_save_iptables() {
    if [[ -f /etc/redhat-release ]]; then
        # Comando para AlmaLinux, Rocky, CentOS
        service iptables save >/dev/null 2>&1
    else
        # Comando para Ubuntu y Debian (NO llamar a la función aquí)
        netfilter-persistent save >/dev/null 2>&1
    fi
}

# --- OPTIMIZADOR GAMING & EXTREME PERFORMANCE (EXTREMIN) ---
fun_gaming_pro() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} GAMING OPTIMIZER & EXTREMIN PRO ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Este sistema modifica el Kernel para reducir el Ping"
    echo -e " y prioriza el tráfico de juegos en los túneles VPN."
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_TEXTO}[1] > ACTIVAR MODO GAMING (Latencia Cero)${C_RESET}"
    echo -e " ${C_TEXTO}[2] > DESACTIVAR Y VOLVER A CONFIG. ORIGINAL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
    echo -n " Opcion: "
    read opt_g

    case $opt_g in
        1)
            echo -e "\n ${C_DATO}[+] Aplicando ajustes sysctl de alto rendimiento...${C_RESET}"
            # Backup de seguridad
            [[ ! -f /etc/sysctl.conf.bak ]] && cp /etc/sysctl.conf /etc/sysctl.conf.bak
            
            # Limpieza de etiquetas anteriores
            sed -i '/reagens_gaming/d' /etc/sysctl.conf
            
            # Inyección de parámetros de red para Gaming
            cat <<EOF >> /etc/sysctl.conf
# reagens_gaming_start
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_autocorking = 0
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1
net.core.netdev_max_backlog = 5000
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
# reagens_gaming_end
EOF
            sysctl -p >/dev/null 2>&1

            echo -e " ${C_DATO}[+] Activando sistema EXTREMIN (Prioridad CPU)...${C_RESET}"
            # Elevamos la prioridad de los procesos de túnel a nivel -15 (Casi tiempo real)
            for srv in sshd dropbear xray hysteria-server reagens-udp; do
                PIDS=$(pgrep -x $srv)
                for pid in $PIDS; do
                    renice -n -15 -p $pid >/dev/null 2>&1
                done
            done
            
            echo -e "${C_VERDE} ¡VPS OPTIMIZADA PARA GAMING EXITOSAMENTE!${C_RESET}"
            sleep 3 ;;
            
        2)
            echo -e "\n ${C_ROJO}[!] Revirtiendo ajustes a estado original...${C_RESET}"
            if [[ -f /etc/sysctl.conf.bak ]]; then
                cp /etc/sysctl.conf.bak /etc/sysctl.conf
                sysctl -p >/dev/null 2>&1
                echo -e "${C_VERDE} Configuración original restaurada.${C_RESET}"
            else
                echo -e "${C_ROJO} No se encontró backup de configuración.${C_RESET}"
            fi
            sleep 2 ;;
        *) return ;;
    esac
}

fun_salir_script() {
    clear
    echo ""
    msg_center "${C_BARRA} ______  _____   ___   _____   _____  _   _  _____${NC}"
    msg_center "${C_BARRA}| ___ \ |  ___| / _ \ |  __ \ |  ___|| \ | |/  ___|${NC}"
    msg_center "${C_BARRA}| |_/ / | |__  / /_\ \| |  \/ | |__  |  \| |\ \`--. ${NC}"
    msg_center "${C_BARRA}|    /  |  __| |  _  || | __  |  __| | . \` | \`--. \\\\${NC}"
    msg_center "${C_BARRA}| |\ \  | |___ | | | || |_\ \ | |___ | |\  |/\__/ /${NC}"
    msg_center "${C_BARRA}\_| \_| \____/ \_| |_/ \____/ \____/ \_| \_/\____/ ${NC}"
    echo ""
    msg_center "${YELLOW}CREATOR : REAGENS JEAN${NC}"
    echo ""
    msg_center "${CYAN}Para iniciar REAGENS VPN PRO MANAGER escriba: menu${NC}"
    echo ""
    exit 0
}

# ==================================================
# MOTOR DE TRAFICO NUCLEAR (RAM IO - INFALIBLE)
# ==================================================
install_traffic_service() {
    systemctl stop reagens-monitor 2>/dev/null
    
    cat << 'EOF' > /usr/local/bin/reagens-monitor
#!/bin/bash
DB="/etc/reagens/traffic.db"
PID_DIR="/dev/shm/reagens_pids"
mkdir -p "$PID_DIR"

while true; do
    if [[ -f "$DB" ]]; then
        # Usamos un archivo temporal para no bloquear la lectura
        TEMP_DB=$(mktemp)
        
        while IFS='|' read -r user limit used state; do
            delta_bytes=0
            # Solo buscar procesos si el usuario está activo
            if [[ "$state" == "1" ]] && id "$user" &>/dev/null; then
                # Obtenemos PIDs de una sola vez para ahorrar CPU
                pids=$(pgrep -u "$user" -f "sshd|dropbear")
                for pid in $pids; do
                    if [[ -f "/proc/$pid/io" ]]; then
                        # Leer rchar (bytes leídos) y wchar (bytes escritos)
                        current_io=$(awk '/^rchar:|^wchar:/ { sum += $2 } END { print sum }' /proc/$pid/io)
                        
                        if [[ -f "$PID_DIR/$pid" ]]; then
                            last_io=$(cat "$PID_DIR/$pid")
                            [[ "$current_io" -gt "$last_io" ]] && delta_bytes=$((delta_bytes + current_io - last_io))
                        fi
                        echo "$current_io" > "$PID_DIR/$pid"
                    fi
                done
            fi
            
            # Cálculo de MB consumidos (con factor de corrección 0.2)
            new_used=$(echo "$used + ($delta_bytes * 0.1)" | bc -l)
            
            # Bloqueo automático por límite
            new_state="$state"
            if [[ "$limit" -gt 0 ]] && (( $(echo "$new_used >= $limit" | bc -l) )); then
                 if [[ "$state" == "1" ]]; then
                    passwd -l "$user" >/dev/null 2>&1
                    pkill -u "$user" >/dev/null 2>&1
                    new_state="0"
                 fi
            fi
            echo "$user|$limit|$new_used|$new_state" >> "$TEMP_DB"
        done < "$DB"
        
        mv "$TEMP_DB" "$DB"
        chmod 600 "$DB"
        
        # Limpiar PIDs de sesiones cerradas
        find "$PID_DIR" -type f -mmin +5 -delete
    fi
    sleep 10 # Aumentamos el tiempo de espera para reducir impacto en CPU
done
EOF
    chmod +x /usr/local/bin/reagens-monitor
    systemctl restart reagens-monitor
}

# 2. Restaurar reglas de iptables (Persistencia tras reinicio)
restore_traffic_rules() {
    if [[ -f "$DB_TRAFFIC" ]]; then
        while IFS='|' read -r user limit used state; do
            if id "$user" &>/dev/null; then
                if ! iptables -C OUTPUT -m owner --uid-owner "$user" -j ACCEPT 2>/dev/null; then
                    iptables -I OUTPUT -m owner --uid-owner "$user" -j ACCEPT
                fi
            fi
        done < "$DB_TRAFFIC"
    fi
}

# 3. Función auxiliar para agregar usuarios al monitor (Persistencia añadida)
add_traffic_user() {
    local u=$1
    local mb=$2
    local bytes=0
    if [[ "$mb" -gt 0 ]]; then
        bytes=$(echo "$mb * 1048576" | bc)
    fi
    sed -i "/^$u|/d" "$DB_TRAFFIC"
    echo "$u|$bytes|0|1" >> "$DB_TRAFFIC"
    iptables -I OUTPUT -m owner --uid-owner "$u" -j ACCEPT 2>/dev/null
    fun_save_iptables
}

# --- DATOS DEL SISTEMA (VERSION FINAL: UNIVERSAL + RAPIDA) ---
obtener_datos() {
    # Definir rutas
    CACHE_STATS="/tmp/reagens_stats_cache"
    DB_SSH="/etc/adm-lite/usuarios_ssh.db"
    DB_TOKENS="/etc/adm-lite/usuarios_token.db"
    DB_TRAFFIC="/etc/reagens/traffic.db"

    # 1. CARGA DE CACHÉ (Lo que ve el usuario al instante)
    if [[ -f "$CACHE_STATS" ]]; then
        source "$CACHE_STATS"
    else
        ONLI_USR="."; EXP_USR="."; LOK_USR="."; TOTAL_USR="."
        IP_DISP="Cargando..."
    fi

    # 2. DATOS DE HARDWARE (Se calculan al momento)
    if [ -f /etc/os-release ]; then 
        OS_NAME=$(grep -w "PRETTY_NAME" /etc/os-release | cut -d= -f2 | tr -d '"')
    else 
        OS_NAME="Linux"
    fi
    OS_NAME=${OS_NAME:0:13}
    FECHA_ACT=$(date +%d/%m/%y)
    HORA_ACT=$(date +%H:%M:%S)
    
    # --- RAM (CORREGIDO Y MEJORADO) ---
    # Capturamos la salida de memoria en MB
    local ram_out=$(free -m | grep Mem:)
    
    # Extraemos valores asegurando que no queden vacios
    local ram_t=$(echo "$ram_out" | awk '{print $2}')
    local ram_u=$(echo "$ram_out" | awk '{print $3}')
    
    # Intentamos leer la columna 7 (Available/Disponible) que es la real
    local ram_f=$(echo "$ram_out" | awk '{print $7}')
    
    # Si la columna 7 esta vacia (Linux viejos), leemos la 4 (Free)
    if [[ -z "$ram_f" ]]; then 
        ram_f=$(echo "$ram_out" | awk '{print $4}')
    fi

    # Asignamos variables finales
    RAM_TOTAL="${ram_t}Mi"
    RAM_USED="${ram_u}Mi"
    RAM_FREE="${ram_f}Mi"
    
    # Porcentaje de uso
    if [[ "$ram_t" -gt 0 ]]; then 
        RAM_PERC=$(( (ram_u * 100) / ram_t ))"%"
    else 
        RAM_PERC="0%"
    fi
    
    # CPU (FIX UNIVERSAL ALMALINUX / UBUNTU)
    # Usamos /proc/stat que funciona en todos los Linux igual
    CPU_CORES=$(nproc)
    CPU_USAGE=$(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage}' | awk -F. '{print $1}')"%"
    
    # Frecuencia CPU
    local freq=$(grep -m1 "cpu MHz" /proc/cpuinfo | awk '{print $4}' | cut -d. -f1)
    if [[ -n "$freq" ]]; then freq=$(awk "BEGIN {printf \"%.1fGHz\", $freq/1000}"); else freq="Virtual"; fi
    CPU_INFO="$CPU_CORES @ $freq"

    # 3. ACTUALIZADOR SILENCIOSO (Calcula usuarios en 2do plano)
    (
        # IP
        if [[ ! -f "/tmp/ip_cache" ]] || [[ $(find /tmp/ip_cache -mmin +60) ]]; then
            curl -s -m 2 ipv4.icanhazip.com > /tmp/ip_cache
        fi
        NEW_IP=$(cat /tmp/ip_cache 2>/dev/null); NEW_IP=${NEW_IP:0:15}

        # ONLINE (Procesos sshd/dropbear reales)
        # COPIA ESTA VERSIÓN PARA MAYOR PRECISIÓN EN ROCKY:
# --- ONLINE (FIX PARA ELIMINAR CONEXIONES FANTASMA) ---
        NEW_ONLI=0
        if [[ -f "$DB_SSH" || -f "$DB_TOKENS" ]]; then
            # Creamos una lista de todos tus usuarios reales de las DBs
            USR_DATABASE=$(awk -F'|' '{print $1}' "$DB_SSH" "$DB_TOKENS" 2>/dev/null | sort -u)
            
            for u_db in $USR_DATABASE; do
                # pgrep -u filtra estrictamente por el nombre del usuario
                # Esto ignora procesos de root, de sistema y falsos positivos
                conx_real=$(pgrep -u "$u_db" -f "sshd|dropbear" | wc -l)
                NEW_ONLI=$((NEW_ONLI + conx_real))
            done
        fi

for user in $USR_LIST; do
    # Verificamos si el usuario tiene procesos ssh o dropbear activos
    if pgrep -u "$user" -f "sshd|dropbear" >/dev/null 2>&1; then
        # Contamos cuántas conexiones tiene ese usuario
        count=$(ps -u "$user" -f | grep -E "sshd|dropbear" | grep -v "grep" | wc -l)
        NEW_ONLI=$((NEW_ONLI + count))
    fi
done

        # TOTAL
        T1=$(wc -l < "$DB_SSH" 2>/dev/null || echo 0)
        T2=$(wc -l < "$DB_TOKENS" 2>/dev/null || echo 0)
        NEW_TOTAL=$((T1 + T2))

        # BLOQUEADOS (Lee DB Monitor)
        NEW_LOK=0
        if [[ -f "$DB_TRAFFIC" ]]; then
            NEW_LOK=$(awk -F'|' '$4 == "0" {count++} END {print count+0}' "$DB_TRAFFIC")
        fi
        
        # EXPIRADOS (Calculo fecha)
        TODAY=$(date +%Y-%m-%d)
        EXP1=0; EXP2=0
        if [[ -f "$DB_SSH" ]]; then
            EXP1=$(awk -F'|' -v today="$TODAY" '$3 < today && $3 != "" {count++} END {print count+0}' "$DB_SSH")
        fi
        if [[ -f "$DB_TOKENS" ]]; then
            EXP2=$(awk -F'|' -v today="$TODAY" '$3 < today && $3 != "" {count++} END {print count+0}' "$DB_TOKENS")
        fi
        NEW_EXP=$((EXP1 + EXP2))

        # Guardar Cache
        cat <<EOF_CACHE > "$CACHE_STATS"
IP_DISP="$NEW_IP"
ONLI_USR="$NEW_ONLI"
TOTAL_USR="$NEW_TOTAL"
LOK_USR="$NEW_LOK"
EXP_USR="$NEW_EXP"
EOF_CACHE
    ) & >/dev/null 2>&1
}

get_v2_days() {
    local user=$1
    local meta="$DB_USERS/v2ray/$user"
    if [[ -f "$meta" ]]; then
        source "$meta"
        if [[ -z "$EXP" ]]; then 
            echo "0"
            return
        fi
        local exp_sec=$(date -d "$EXP" +%s)
        local today_sec=$(date +%s)
        echo $(( (exp_sec - today_sec) / 86400 ))
    else 
        echo "0"
    fi
}

obtener_clave_default() { 
    if [[ -f "$FILE_PASS" ]]; then 
        cat "$FILE_PASS"
    else 
        echo ""
    fi 
}

listar_usuarios_vpn_all() { 
    awk -F: '$3>=1000 {print $1}' /etc/passwd | grep -vE "^(ubuntu|debian|centos|fedora|opc|admin|ec2-user|nobody|root|syslog)$" 
}

# --- FUNCION SPEEDTEST OOKLA REPARADA (MULTIVERSAL) ---
fun_speedtest() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SPEEDTEST OOKLA (SISTEMA DE EMERGENCIA) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if ! command -v speedtest &> /dev/null; then
        echo -e " ${C_DATO}[+] Limpiando instalaciones fallidas...${C_RESET}"
        # Borrar rastros de repositorios que fallaron
        sudo rm -f /etc/apt/sources.list.d/ookla_speedtest-cli.list
        
        echo -e " ${C_DATO}[+] Descargando Binario Oficial de Ookla...${C_RESET}"
        ARCH=$(uname -m)
        
        # Detectar arquitectura y descargar el archivo correcto
        if [[ "$ARCH" == "x86_64" ]]; then
            URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz"
        elif [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]]; then
            URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-aarch64.tgz"
        else
            URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz"
        fi

        # Descarga e instalación manual (bypass de apt)
        wget -qO speedtest.tgz "$URL"
        tar -xzf speedtest.tgz speedtest
        sudo mv speedtest /usr/bin/
        sudo chmod +x /usr/bin/speedtest
        rm -f speedtest.tgz speedtest.8 speedtest.md
    fi
    
    if command -v speedtest &> /dev/null; then
        echo -e " ${C_VERDE}Ejecutando prueba de velocidad...${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        speedtest --accept-license --accept-gdpr
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    else
        echo -e "${C_ROJO} [X] Error: No se pudo instalar el binario.${C_RESET}"
    fi
    
    echo -e " ${C_DATO}Prueba Finalizada.${C_RESET}"
    read -p " Presione Enter para continuar..."
}

# FUNCION: Seleccionar Usuario SSH
seleccionar_usuario_ssh() {
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SELECCIONAR USUARIO SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    i=1
    declare -a users_array
    for u in $(listar_usuarios_vpn_all); do 
        if [[ -f "$DB_USERS/$u" ]] && grep -q "CLIENT_REF=" "$DB_USERS/$u"; then
            continue
        fi
        echo -e " [${C_DATO}$i${C_RESET}] $u"
        users_array[$i]=$u
        let i++
    done
    if [[ $i -eq 1 ]]; then 
        echo -e " ${C_ROJO}No hay usuarios SSH.${C_RESET}"
        return 1
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Seleccione numero: "
    read opt_user
    USER_SEL=${users_array[$opt_user]}
    if [[ -z "$USER_SEL" ]]; then 
        echo -e " ${C_ROJO}Invalido.${C_RESET}"
        return 1
    fi
    return 0
}

seleccionar_usuario_token() {
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SELECCIONAR TOKEN (APP) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    i=1
    declare -a users_array
    for u in $(listar_usuarios_vpn_all); do 
        if [[ -f "$DB_USERS/$u" ]] && grep -q "CLIENT_REF=" "$DB_USERS/$u"; then
            echo -e " [${C_DATO}$i${C_RESET}] $u"
            users_array[$i]=$u
            let i++
        fi
    done
    if [[ $i -eq 1 ]]; then 
        echo -e " ${C_ROJO}No hay tokens.${C_RESET}"
        return 1
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Seleccione numero: "
    read opt_user
    USER_SEL=${users_array[$opt_user]}
    if [[ -z "$USER_SEL" ]]; then 
        echo -e " ${C_ROJO}Invalido.${C_RESET}"
        return 1
    fi
    return 0
}

# --- CREAR USUARIO SSH (SOLO SSH) ---
fun_crear_usuario() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CREAR USUARIO SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Nombre de Usuario: "; read u
    if [[ -z "$u" ]]; then return; fi
    if id "$u" >/dev/null 2>&1; then echo -e "${C_ROJO}Existe.${C_RESET}"; sleep 2; return; fi
    
    # Clave Default o Manual
    def_pass=$(obtener_clave_default)
    if [[ ! -z "$def_pass" ]]; then
        echo -e " Clave Default: ${C_DATO}$def_pass${C_RESET}"
        echo -n " Contraseña (Enter para Default): "; read p
        [[ -z "$p" ]] && p="$def_pass"
    else
        echo -n " Contraseña: "; read p
    fi
    if [[ -z "$p" ]]; then echo "Error: Clave vacia"; sleep 2; return; fi
    
    echo -n " Dias: "; read d
    echo -n " Limite MB (0=Inf): "; read mb
    [[ -z "$mb" ]] && mb=0
    echo -n " Limite Conexiones (0=Inf): "; read lc
    [[ -z "$lc" ]] && lc=0
    
    fd=$(date -d "+$d days" +%Y-%m-%d)
    useradd -M -s /bin/false "$u"
    echo "$u:$p" | chpasswd
    chage -E "$fd" "$u"
    
    add_traffic_user "$u" "$mb"
    echo "$u|$p|$fd|$lc|$mb" >> "$DB_SSH"
    
    echo -e "\n ${C_VERDE}Usuario $u creado.${C_RESET}"
    sleep 2
}

# --- LISTA SSH LIMPIA (SOLO SSH) ---
fun_detalles_usuarios() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LISTA DE USUARIOS SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    printf "${C_TEXTO}%-12s %-10s %-6s %-14s %-5s${C_RESET}\n" "USER" "PASS" "DIAS" "DATOS(U/T)" "LIM"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    
    if [[ -f "$DB_SSH" ]]; then
        while IFS='|' read -r user pass exp limit_conn limit_mb; do
            if id "$user" >/dev/null 2>&1; then
                exp_sec=$(date -d "$exp" +%s); now_sec=$(date +%s)
                dias=$(( (exp_sec - now_sec) / 86400 ))
                [[ $dias -lt 0 ]] && dias="EXP"

                consumo=$(grep -w "^$user" "$DB_TRAFFIC" | cut -d'|' -f3)
                [[ -z "$consumo" ]] && consumo=0
                mb_used=$(( consumo / 1048576 ))
                
                if [[ "$limit_mb" == "0" ]]; then disp_mb="$mb_used/Inf"; else disp_mb="$mb_used/$limit_mb"; fi
                [[ "$limit_conn" == "0" ]] && limit_conn="Inf"

                printf "%-12s %-10s %-6s %-14s %-5s\n" "${user:0:12}" "${pass:0:10}" "$dias" "$disp_mb" "$limit_conn"
            fi
        done < "$DB_SSH"
    else
        echo " Base de datos vacía."
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Presiona Enter para salir..."
}

# --- NUEVO: VER DATOS INDIVIDUALES SSH ---
fun_ver_usuario_individual() {
    clear
    seleccionar_usuario_ssh || return
    datos=$(grep -w "^$USER_SEL" "$DB_SSH")
    if [[ -z "$datos" ]]; then
        echo -e "${C_ROJO} Error: Usuario no encontrado en DB SSH.${C_RESET}"; read -p "Enter..."; return
    fi
    IFS='|' read -r u p e l m <<< "$datos"
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center " DATOS DEL USUARIO: $u "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_TEXTO}Usuario:${C_RESET}   ${C_VERDE}$u${C_RESET}"
    echo -e " ${C_TEXTO}Clave:${C_RESET}     ${C_DATO}$p${C_RESET}"
    echo -e " ${C_TEXTO}Vence:${C_RESET}     ${C_DATO}$e${C_RESET}"
    echo -e " ${C_TEXTO}Limite IP:${C_RESET} ${C_DATO}$l${C_RESET}"
    echo -e " ${C_TEXTO}Limite MB:${C_RESET} ${C_DATO}$m MB${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Enter para salir..."
}

# --- MONITOR SSH (SALIR CON 0) ---
fun_monitor_online() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MONITOR SSH ONLINE (0 Salir) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        printf "${C_TEXTO}%-20s %-15s${C_RESET}\n" "USUARIO" "ESTADO"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        if [[ -f "$DB_SSH" ]]; then
            while IFS='|' read -r user _ _ _ _; do
                if id "$user" >/dev/null 2>&1; then
                    conx=$(ps -u "$user" | grep -E 'sshd|dropbear' | grep -v grep | wc -l)
                    if [[ "$conx" -gt 0 ]]; then
                        printf "%-20s ${C_VERDE}ONLINE ($conx)${C_RESET}\n" "$user"
                    else
                        printf "%-20s ${C_ROJO}OFFLINE${C_RESET}\n" "$user"
                    fi
                fi
            done < "$DB_SSH"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        read -t 2 -n 1 key
        if [[ "$key" == "0" ]]; then break; fi
    done
}

# --- ELIMINAR SOLO SSH VENCIDOS ---
fun_eliminar_vencidos_ssh() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center " LIMPIANDO SSH VENCIDOS "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo " Analizando fechas..."
    
    # Crear archivo temporal
    touch "$DB_SSH.tmp"
    count=0
    
    if [[ -f "$DB_SSH" ]]; then
        while IFS='|' read -r user pass exp limit_conn limit_mb; do
            # Validar fecha
            if [[ ! -z "$exp" ]]; then
                today_sec=$(date +%s)
                exp_sec=$(date -d "$exp" +%s 2>/dev/null)
                
                # Si la fecha es valida y ya paso
                if [[ ! -z "$exp_sec" && $today_sec -ge $exp_sec ]]; then
                    echo -e "${C_ROJO} Eliminando: $user (Venció: $exp)${C_RESET}"
                    userdel --force "$user" 2>/dev/null
                    rm -f "/etc/reagens/users/$user"
                    sed -i "/^$user|/d" "$DB_TRAFFIC"
                    ((count++))
                else
                    # Si no esta vencido, lo guardamos en el temporal
                    echo "$user|$pass|$exp|$limit_conn|$limit_mb" >> "$DB_SSH.tmp"
                fi
            fi
        done < "$DB_SSH"
    fi
    
    # Reemplazar DB original con la limpia
    mv "$DB_SSH.tmp" "$DB_SSH"
    
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_VERDE}Total eliminados: $count${C_RESET}"
    read -p " Enter para continuar..."
}

# --- ELIMINAR TODOS LOS SSH ---
fun_eliminar_todos_ssh() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_ROJO}[PELIGRO] ESTO BORRARA TODOS LOS USUARIOS SSH${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Escribe 'SSH' para confirmar: "
    read conf
    if [[ "$conf" == "SSH" ]]; then
        echo " Eliminando..."
        if [[ -f "$DB_SSH" ]]; then
            while IFS='|' read -r user _ _ _ _; do
                userdel --force "$user" 2>/dev/null
                rm -f "/etc/reagens/users/$user"
                sed -i "/^$user|/d" "$DB_TRAFFIC"
            done < "$DB_SSH"
            # Vaciar archivo DB
            > "$DB_SSH"
        fi
        echo -e "${C_VERDE} Lista SSH vaciada por completo.${C_RESET}"
    else
        echo " Cancelado."
    fi
    sleep 2
}

# --- ELIMINAR SSH (REPARADO) ---
fun_eliminar_usuario() { 
    clear
    seleccionar_usuario_ssh || return
    iptables -D OUTPUT -m owner --uid-owner "$USER_SEL" -j ACCEPT > /dev/null 2>&1
    fun_save_iptables
    userdel --force "$USER_SEL"
    rm -f "$DB_USERS/$USER_SEL"
    sed -i "/^$USER_SEL|/d" "$DB_TRAFFIC"
    sed -i "/^$USER_SEL|/d" "$DB_SSH"
    echo -e "${C_VERDE} Eliminado.${C_RESET}"
    sleep 2
}

# --- FIJAR CLAVE DEFAULT SSH ---
fun_clave_default() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center " FIJAR CLAVE DEFAULT SSH "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Nueva Clave: "
    read p
    if [[ ! -z "$p" ]]; then
        echo "$p" > "$FILE_PASS"
        echo -e "${C_VERDE} Clave guardada: $p${C_RESET}"
    fi
    sleep 2
}

# --- FUNCIONES FALTANTES AGREGADAS ---

# [3] EDITAR USUARIO
fun_editar_usuario() {
    clear
    seleccionar_usuario_ssh || return
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " EDITAR USUARIO: ${C_VERDE}$USER_SEL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] Cambiar Contraseña"
    echo -e " [2] Cambiar Limite de Conexiones"
    echo -e " [3] Cambiar Limite MB (Trafico)"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Opcion: "
    read op_edit
    
    # Leer datos actuales
    datos=$(grep -w "^$USER_SEL" "$DB_SSH")
    IFS='|' read -r u p e l m <<< "$datos"

    case $op_edit in
        1)
            echo -n " Nueva Contraseña: "
            read new_pass
            if [[ -z "$new_pass" ]]; then echo "Cancelado"; sleep 1; return; fi
            echo "$USER_SEL:$new_pass" | chpasswd
            p=$new_pass
            echo -e "${C_VERDE} Contraseña cambiada.${C_RESET}"
            ;;
        2)
            echo -n " Nuevo Limite Conexiones (0=Inf): "
            read new_limit
            if [[ -z "$new_limit" ]]; then echo "Cancelado"; sleep 1; return; fi
            l=$new_limit
            echo -e "${C_VERDE} Limite cambiado.${C_RESET}"
            ;;
        3)
            echo -n " Nuevo Limite MB (0=Inf): "
            read new_mb
            if [[ -z "$new_mb" ]]; then echo "Cancelado"; sleep 1; return; fi
            m=$new_mb
            add_traffic_user "$USER_SEL" "$m"
            echo -e "${C_VERDE} Limite MB actualizado.${C_RESET}"
            ;;
        *) return ;;
    esac

    # Guardar cambios en DB_SSH
    sed -i "/^$USER_SEL|/d" "$DB_SSH"
    echo "$u|$p|$e|$l|$m" >> "$DB_SSH"
    sleep 2
}

# [4] RENOVAR USUARIO
fun_renovar_usuario() {
    clear
    seleccionar_usuario_ssh || return
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " RECARGA ACUMULATIVA: ${C_VERDE}$USER_SEL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    # 1. Obtener datos actuales de la DB SSH
    datos=$(grep -w "^$USER_SEL" "$DB_SSH")
    IFS='|' read -r u p e l m_limit <<< "$datos"
    
    # 2. Obtener consumo actual de traffic.db
    consumo_bytes=$(grep -w "^$USER_SEL" "$DB_TRAFFIC" | cut -d'|' -f3)
    [[ -z "$consumo_bytes" ]] && consumo_bytes=0
    consumo_mb=$(echo "$consumo_bytes / 1048576" | bc)

    # 3. Calcular MB sobrantes (Suma al limite)
    sobrante_mb=$(echo "$m_limit - $consumo_mb" | bc)
    if (( $(echo "$sobrante_mb < 0" | bc -l) )); then sobrante_mb=0; fi
    
    # El paquete base de recarga es el mismo que tenia originalmente (m_limit)
    # Si quieres un paquete fijo de 50GB por ejemplo, cambia 'm_limit' por 51200
    paquete_base=$m_limit
    nuevo_limite_mb=$(echo "$paquete_base + $sobrante_mb" | bc)
    nuevo_limite_bytes=$(echo "$nuevo_limite_mb * 1048576" | bc)

    # 4. Calcular Dias sobrantes
    echo -n " Dias a sumar (Base 30): "
    read dias_sumar
    [[ -z "$dias_sumar" ]] && dias_sumar=30

    now_sec=$(date +%s)
    exp_sec=$(date -d "$e" +%s 2>/dev/null)
    
    if [[ -z "$exp_sec" || $now_sec -ge $exp_sec ]]; then
        # Vencido: Solo sumamos desde hoy
        nueva_fecha=$(date -d "+$dias_sumar days" +%Y-%m-%d)
    else
        # Vigente: Sumamos a lo que le quedaba
        nueva_fecha=$(date -d "$e + $dias_sumar days" +%Y-%m-%d)
    fi

    # 5. Aplicar cambios en Sistema y DBs
    chage -E "$nueva_fecha" "$USER_SEL"
    passwd -u "$USER_SEL" >/dev/null 2>&1
    pkill -u "$USER_SEL"
    iptables -Z FORWARD

    # Actualizar traffic.db (Reset a 0 usado)
    sed -i "/^$USER_SEL|/d" "$DB_TRAFFIC"
    echo "$USER_SEL|$nuevo_limite_bytes|0|1" >> "$DB_TRAFFIC"

    # Actualizar usuarios_ssh.db
    sed -i "/^$USER_SEL|/d" "$DB_SSH"
    echo "$u|$p|$nueva_fecha|$l|$nuevo_limite_mb" >> "$DB_SSH"

    echo -e "${C_VERDE} RECARGA EXITOSA!${C_RESET}"
    echo -e " Nuevo Limite: ${C_DATO}$nuevo_limite_mb MB${C_RESET} (Acumulado)"
    echo -e " Nueva Fecha : ${C_DATO}$nueva_fecha${C_RESET}"
    sleep 3
}

# [5] BLOQUEAR / DESBLOQUEAR
fun_bloqueo_usuario() {
    clear
    seleccionar_usuario_ssh || return
    # Verificar estado actual
    status=$(passwd -S "$USER_SEL" | awk '{print $2}')
    
    if [[ "$status" == "L" ]]; then
        echo -e " El usuario esta ${C_ROJO}BLOQUEADO${C_RESET}"
        echo -n " ¿Desbloquear? (s/n): "
        read op
        if [[ "$op" == "s" ]]; then
            passwd -u "$USER_SEL"
            echo -e "${C_VERDE} Usuario DESBLOQUEADO.${C_RESET}"
        fi
    else
        echo -e " El usuario esta ${C_VERDE}ACTIVO${C_RESET}"
        echo -n " ¿Bloquear? (s/n): "
        read op
        if [[ "$op" == "s" ]]; then
            passwd -l "$USER_SEL"
            pkill -u "$USER_SEL"
            echo -e "${C_ROJO} Usuario BLOQUEADO.${C_RESET}"
        fi
    fi
    sleep 2
}

# [11] CONFIGURAR BANNER
fun_banner() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CONFIGURAR BANNER SSH ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Se abrirá el editor de texto."
    echo -e " Escribe tu mensaje HTML/Texto y guarda con: Ctrl+O, Enter, Ctrl+X"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    read -p " Presiona Enter para editar..."
    nano /etc/issue.net
    
    echo -e " Aplicando cambios..."
    service ssh restart >/dev/null 2>&1
    service dropbear restart >/dev/null 2>&1
    echo -e "${C_VERDE} Banner actualizado.${C_RESET}"
    sleep 2
}

# -------------------------------------

# --- MENU SSH ACTUALIZADO ---
menu_ssh() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION DE CUENTAS SSH / DROPBEAR ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]  > CREAR NUEVO USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[2]  > ELIMINAR USUARIO${C_RESET}"  
        echo -e " ${C_TEXTO}[3]  > EDITAR USUARIO (Sumar Días/MB)${C_RESET}" # <-- Llama a fun_editar_usuario
        echo -e " ${C_TEXTO}[4]  > RENOVAR USUARIO (Acumulativo)${C_RESET}"  # <-- Llama a fun_renovar_usuario
        echo -e " ${C_TEXTO}[5]  > BLOQUEAR / DESBLOQUEAR (Lista)${C_RESET}" # <-- Llama a fun_bloqueo_usuario
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[6]  > LISTA GENERAL SSH (SOLO SSH)${C_RESET}"
        echo -e " ${C_DATO}[7]  > VER DATOS DE 1 USUARIO (Detalle)${C_RESET}"
        echo -e " ${C_TEXTO}[8]  > MONITOR ONLINE (Salir con 0)${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[9]  > ELIMINAR SSH VENCIDOS${C_RESET}"
        echo -e " ${C_ROJO}[10] > ELIMINAR TODOS LOS SSH${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[11] > CONFIGURAR BANNER SSH${C_RESET}"
        echo -e " ${C_DATO}[12] > FIJAR CLAVE DEFAULT SSH${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0)    VOLVER AL MENU ANTERIOR${C_RESET}"
        echo -n " Opcion: "
        read op_ssh
        case $op_ssh in 
            1) fun_crear_usuario ;; 
            2) fun_eliminar_usuario ;;       # Verifica que tengas esta funcion
            3) fun_editar_usuario ;;         # Esta es la NUEVA que te di (Suma MB/Dias)
            4) fun_renovar_usuario ;;        # Esta es la NUEVA (Acumulativa)
            5) fun_bloqueo_usuario ;;        # Esta es la NUEVA (Con lista)
            6) fun_detalles_usuarios ;; 
            7) fun_ver_usuario_individual ;; 
            8) fun_monitor_online ;; 
            9) fun_eliminar_vencidos_ssh ;;  # Asegurate de haber pegado esta del paso anterior
            10) fun_eliminar_todos_ssh ;;    # Asegurate de haber pegado esta del paso anterior
            11) fun_banner ;; 
            12) fun_clave_default ;; 
            0) break ;; 
        esac
    done
}

# ==================================================
# BLOQUE GESTION TOKENS (DISEÑO CLASICO + LOGICA FIX)
# ==================================================

# Aseguramos variables clave
DB_TOKENS="/etc/adm-lite/usuarios_token.db"
TOKEN_PASS_FILE="/etc/reagens_base_pass"

# 1. FUNCION DE CONTRASEÑA (CRITICA)
check_base_pass() {
    if [ ! -f "$TOKEN_PASS_FILE" ]; then
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e "${C_DATO} ¡CONFIGURACION INICIAL TOKEN ID!${C_RESET}"
        echo -e " Esta App usa una contraseña fija interna para todos."
        echo -e " Necesito saber cuál es esa contraseña."
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        read -p " Introduce la CONTRASEÑA BASE de la APK: " BASE_PASS
        if [[ -z "$BASE_PASS" ]]; then echo "Error: vacio"; return; fi
        echo "$BASE_PASS" > "$TOKEN_PASS_FILE"
        echo -e "${C_VERDE}Contraseña guardada.${C_RESET}"; sleep 2
    fi
}

change_base_pass() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e "${C_ROJO} CUIDADO: Esto afectará a los nuevos usuarios.${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Nueva contraseña base de la APK: " NUEVA_PASS
    if [[ -z "$NUEVA_PASS" ]]; then echo "Cancelado"; sleep 1; return; fi
    echo "$NUEVA_PASS" > "$TOKEN_PASS_FILE"
    echo -e "${C_VERDE}Contraseña actualizada.${C_RESET}"; sleep 2
}

# 2. SELECTOR DE USUARIO (SOLUCION DEL PROBLEMA)
# Esta funcion lee tu base de datos y permite elegir sin fallar
seleccionar_usuario_token() {
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} SELECCIONAR TOKEN (APP) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    i=1
    declare -a users_array
    
    # Leemos la DB linea por linea para no perder ninguno
    if [[ -f "$DB_TOKENS" ]]; then
        while IFS='|' read -r user cliente rest; do
            if id "$user" >/dev/null 2>&1; then
                echo -e " [${C_DATO}$i${C_RESET}] $user | ${C_TEXTO}$cliente${C_RESET}"
                users_array[$i]=$user
                let i++
            fi
        done < "$DB_TOKENS"
    fi

    if [[ $i -eq 1 ]]; then 
        echo -e " ${C_ROJO}No hay tokens creados.${C_RESET}"
        return 1
    fi
    
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Seleccione numero: "
    read opt_user
    USER_SEL=${users_array[$opt_user]}
    
    if [[ -z "$USER_SEL" ]]; then 
        echo -e " ${C_ROJO}Opcion invalida.${C_RESET}"
        return 1
    fi
    return 0
}

# 3. CREAR TOKEN
crear_token() {
    clear
    check_base_pass
    BASE_PASS=$(cat "$TOKEN_PASS_FILE")
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center " CREAR TOKEN ID (APP) "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Nombre Cliente: "; read c
    echo -n " Token ID: "; read u
    if [[ -z "$u" ]]; then return; fi
    if id "$u" >/dev/null 2>&1; then echo -e "${C_ROJO}Existe.${C_RESET}"; sleep 2; return; fi
    
    echo -n " Dias: "; read d
    echo -n " Limite MB (0=Inf): "; read mb
    [[ -z "$mb" ]] && mb=0
    
    fd=$(date -d "+$d days" +%Y-%m-%d)
    useradd -M -s /bin/false -c "$c" "$u"
    echo "$u:$BASE_PASS" | chpasswd
    chage -E "$fd" "$u"
    
    add_traffic_user "$u" "$mb"
    echo "$u|$c|$fd|$mb" >> "$DB_TOKENS"
    
    echo -e "\n ${C_VERDE}Token Creado.${C_RESET}"
    sleep 2
}

# --- ELIMINAR SSH (REPARADO) ---
fun_eliminar_usuario() { 
    clear
    seleccionar_usuario_ssh || return
    iptables -D OUTPUT -m owner --uid-owner "$USER_SEL" -j ACCEPT > /dev/null 2>&1
    fun_save_iptables
    userdel --force "$USER_SEL"
    rm -f "$DB_USERS/$USER_SEL"
    sed -i "/^$USER_SEL|/d" "$DB_TRAFFIC"
    sed -i "/^$USER_SEL|/d" "$DB_SSH"
    echo -e "${C_VERDE} Eliminado.${C_RESET}"
    sleep 2
}

# --- ELIMINAR TOKEN (REPARADO) ---
eliminar_token_func() {
    clear
    seleccionar_usuario_token || return
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ELIMINAR TOKEN: ${C_ROJO}$USER_SEL${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Confirmar borrado (s/n): "
    read op
    if [[ "$op" == "s" ]]; then
        iptables -D OUTPUT -m owner --uid-owner "$USER_SEL" -j ACCEPT > /dev/null 2>&1
        fun_save_iptables
        userdel --force "$USER_SEL"
        rm -f "$DB_USERS/$USER_SEL"
        sed -i "/^$USER_SEL|/d" "$DB_TRAFFIC"
        sed -i "/^$USER_SEL|/d" "$DB_TOKENS"
        echo -e "${C_VERDE} Eliminado correctamente.${C_RESET}"
        sleep 2
    fi
}

# 5. EDITAR TOKEN (LOGICA REPARADA)
editar_token_func() {
    clear
    seleccionar_usuario_token || return
    
    # Extraer info actual
    datos=$(grep -w "^$USER_SEL" "$DB_TOKENS")
    IFS='|' read -r u cliente exp limit_mb <<< "$datos"
    
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " EDITAR: ${C_VERDE}$USER_SEL${C_RESET} ($cliente)"
    echo -e " Vence: $exp | Limite: $limit_mb MB"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] Renovar Dias"
    echo -e " [2] Cambiar Limite MB"
    echo -e " [3] Cambiar Nombre Cliente"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Opcion: "
    read op_edit

    case $op_edit in
        1)
            echo -n " Dias a sumar: "; read dias
            if [[ ! -z "$dias" ]]; then
                now_sec=$(date +%s); exp_sec=$(date -d "$exp" +%s 2>/dev/null)
                if [[ -z "$exp_sec" || $now_sec -ge $exp_sec ]]; then
                    new_date=$(date -d "+$dias days" +%Y-%m-%d)
                else
                    new_date=$(date -d "$exp + $dias days" +%Y-%m-%d)
                fi
                chage -E "$new_date" "$USER_SEL"
                passwd -u "$USER_SEL" >/dev/null 2>&1
                exp=$new_date
                echo -e "${C_VERDE} Fecha actualizada: $exp${C_RESET}"
            fi
            ;;
        2)
            echo -n " Nuevos MB (0=Inf): "; read new_mb
            if [[ ! -z "$new_mb" ]]; then
                limit_mb=$new_mb
                add_traffic_user "$USER_SEL" "$limit_mb"
                echo -e "${C_VERDE} Limite MB actualizado.${C_RESET}"
            fi
            ;;
        3)
            echo -n " Nuevo Nombre: "; read new_client
            if [[ ! -z "$new_client" ]]; then
                usermod -c "$new_client" "$USER_SEL"
                cliente=$new_client
                echo -e "${C_VERDE} Nombre cambiado.${C_RESET}"
            fi
            ;;
    esac
    
    # Guardar en DB
    sed -i "/^$USER_SEL|/d" "$DB_TOKENS"
    echo "$u|$cliente|$exp|$limit_mb" >> "$DB_TOKENS"
    sleep 2
}

# 6. BLOQUEAR TOKEN (LOGICA REPARADA)
bloqueo_token_func() {
    clear
    seleccionar_usuario_token || return
    status=$(passwd -S "$USER_SEL" | awk '{print $2}')
    
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    if [[ "$status" == "L" ]]; then
        echo -e " Estado: ${C_ROJO}BLOQUEADO${C_RESET}"
        echo -n " ¿Desbloquear? (s/n): "; read op
        if [[ "$op" == "s" ]]; then
            passwd -u "$USER_SEL"
            echo -e "${C_VERDE} Token Activado.${C_RESET}"
        fi
    else
        echo -e " Estado: ${C_VERDE}ACTIVO${C_RESET}"
        echo -n " ¿Bloquear? (s/n): "; read op
        if [[ "$op" == "s" ]]; then
            passwd -l "$USER_SEL"
            pkill -u "$USER_SEL"
            echo -e "${C_ROJO} Token Bloqueado.${C_RESET}"
        fi
    fi
    sleep 2
}

# 7. LISTA Y MONITOR
listar_tokens() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LISTA DE TOKENS APP ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    printf "${C_TEXTO}%-15s %-15s %-6s %-14s${C_RESET}\n" "TOKEN ID" "CLIENTE" "DIAS" "DATOS"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    
    if [[ -f "$DB_TOKENS" ]]; then
        while IFS='|' read -r user cliente exp limit_mb; do
            if id "$user" >/dev/null 2>&1; then
                exp_sec=$(date -d "$exp" +%s); now_sec=$(date +%s)
                dias=$(( (exp_sec - now_sec) / 86400 ))
                [[ $dias -lt 0 ]] && dias="EXP"
                
                consumo=$(grep -w "^$user" "$DB_TRAFFIC" | cut -d'|' -f3)
                [[ -z "$consumo" ]] && consumo=0
                mb_used=$(( consumo / 1048576 ))
                if [[ "$limit_mb" == "0" ]]; then disp_mb="$mb_used/Inf"; else disp_mb="$mb_used/$limit_mb"; fi

                printf "%-15s %-15s %-6s %-14s\n" "${user:0:14}" "${cliente:0:14}" "$dias" "$disp_mb"
            fi
        done < "$DB_TOKENS"
    else
        echo " No hay tokens."
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Enter para volver..."
}

fun_monitor_tokens() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MONITOR TOKENS ONLINE (0 Salir) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        printf "${C_TEXTO}%-20s %-15s${C_RESET}\n" "TOKEN ID" "ESTADO"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        
        if [[ -f "$DB_TOKENS" ]]; then
            while IFS='|' read -r user _ _ _; do
                if id "$user" >/dev/null 2>&1; then
                    conx=$(ps -u "$user" | grep -E 'sshd|dropbear' | grep -v grep | wc -l)
                    if [[ "$conx" -gt 0 ]]; then
                        printf "%-20s ${C_VERDE}ONLINE ($conx)${C_RESET}\n" "$user"
                    else
                        printf "%-20s ${C_ROJO}OFFLINE${C_RESET}\n" "$user"
                    fi
                fi
            done < "$DB_TOKENS"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        read -t 2 -n 1 key
        if [[ "$key" == "0" ]]; then break; fi
    done
}

# 8. MENU PRINCIPAL TOKENS (DISEÑO RESTAURADO)
menu_tokens() {
    while true; do
        clear
        check_base_pass
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION TOKENS (APP ID) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]   > CREAR TOKEN (MB/DIAS)${C_RESET}"
        echo -e " ${C_TEXTO}[2]   > ELIMINAR TOKEN${C_RESET}"
        echo -e " ${C_TEXTO}[3]   > EDITAR TOKEN (Renovar)${C_RESET}"
        echo -e " ${C_TEXTO}[4]   > BLOQUEAR / DESBLOQUEAR${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[5]   > VER LISTA Y CONSUMO (MB)${C_RESET}"
        echo -e " ${C_TEXTO}[6]   > MONITOR ONLINE${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[7]   > ELIMINAR TOKENS VENCIDOS${C_RESET}"
        echo -e " ${C_ROJO}[8]   > ELIMINAR TODOS LOS TOKENS${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[9]   > CAMBIAR CONTRASEÑA BASE (APP)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "; read op
        case $op in
            1) crear_token ;;
            2) eliminar_token_func ;; 
            3) editar_token_func ;; 
            4) bloqueo_token_func ;;
            5) listar_tokens ;;
            6) fun_monitor_tokens ;;
            7) fun_eliminar_vencidos_token ;;
            8) fun_eliminar_todos_token ;;
            9) change_base_pass ;; 
            0) break ;;
        esac
    done
}

# ==================================================
# BLOQUE GESTION XRAY/V2RAY (INTEGRADO XRAY CORE)
# ==================================================
get_v2_data() {
    if [[ ! -f "$V2RAY_CONF" ]]; then V2_PORT="Error"; return; fi
    # Detectar configuracion
    V2_PORT=$(jq -r '.inbounds[0].port' "$V2RAY_CONF" 2>/dev/null)
    V2_PROTO=$(jq -r '.inbounds[0].protocol' "$V2RAY_CONF" 2>/dev/null)
    if [[ -z "$V2_PORT" || "$V2_PORT" == "null" ]]; then V2_PORT="Error"; fi
}

seleccionar_usuario_v2() {
    echo -e "${C_BARRA} SELECCIONAR USUARIO XRAY ${C_BARRA}"
    if [[ ! -f "$V2RAY_CONF" ]]; then 
        echo -e " ${C_ROJO}No instalado${C_RESET}"
        return 1
    fi
    i=1
    declare -a v2_users
    # Xray users are in .clients[] with 'email' or 'id'
    clients=$(jq -r '.inbounds[0].settings.clients[] | .email // .id' "$V2RAY_CONF")
    if [[ -z "$clients" ]]; then 
        echo -e " ${C_ROJO}Vacio${C_RESET}"
        return 1
    fi
    for c in $clients; do 
        echo -e " [${C_DATO}$i${C_RESET}] $c"
        v2_users[$i]=$c
        let i++
    done
    echo -n " Numero: "
    read opt_v
    USER_V2=${v2_users[$opt_v]}
    if [[ -z "$USER_V2" ]]; then 
        echo "Error"
        return 1
    fi
    return 0
}

# --- FUNCION DE LECTURA INTELIGENTE XRAY ---
cargar_datos_xray() {
    CONF="/usr/local/etc/xray/config.json"
    if [[ ! -f "$CONF" ]]; then echo "Error: No config.json"; return 1; fi

    # 1. Extraer Protocolo y Puerto
    X_PORT=$(jq -r '.inbounds[0].port' "$CONF")
    X_PROTO=$(jq -r '.inbounds[0].protocol' "$CONF")
    
    # 2. Extraer Transporte (ws, tcp, etc)
    X_NET=$(jq -r '.inbounds[0].streamSettings.network // "tcp"' "$CONF")
    
    # 3. Extraer Seguridad (tls, none)
    X_SEC=$(jq -r '.inbounds[0].streamSettings.security // "none"' "$CONF")
    
    # 4. Extraer Path y Host (Solo si es WS)
    X_PATH=$(jq -r '.inbounds[0].streamSettings.wsSettings.path // "/"' "$CONF")
    X_HOST=$(jq -r '.inbounds[0].streamSettings.wsSettings.headers.Host // ""' "$CONF")
    
    # 5. IP Publica
    X_IP=$(curl -s ipv4.icanhazip.com)
}

# FUNCION: CREAR USUARIO V2RAY (AUTO DUAL)
crear_usuario_v2ray() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CREAR USUARIO XRAY (AUTO-DETECT) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    CONF="/usr/local/etc/xray/config.json"
    if [[ ! -f "$CONF" ]]; then echo "Error: Xray no instalado."; return; fi
    
    echo -n " Nombre del Usuario: "; read user
    if [[ -z "$user" ]]; then return; fi
    
    # Validar duplicados
    if grep -q "$user" "$CONF"; then 
        echo -e "${C_ROJO} El usuario ya existe.${C_RESET}"; sleep 2; return
    fi
    
    echo -n " Dias de Duración: "; read dias
    [[ -z "$dias" ]] && dias=30
    
    uuid=$(uuidgen)
    final_date=$(date -d "+$dias days" +%Y-%m-%d)
    
    # --- INYECCION INTELIGENTE ---
    # Detectamos cuántas entradas (inbounds) hay y añadimos el usuario a TODAS.
    total_inbounds=$(jq '.inbounds | length' "$CONF")
    
    echo -e " ${C_DATO}Añadiendo a $total_inbounds puertos activos...${C_RESET}"
    
    for ((i=0; i<$total_inbounds; i++)); do
        PROTO=$(jq -r ".inbounds[$i].protocol" "$CONF")
        
        # Estructura del cliente según el protocolo
        if [[ "$PROTO" == "vmess" ]]; then
            jq --arg u "$uuid" --arg e "$user" \
            ".inbounds[$i].settings.clients += [{\"id\": \$u, \"alterId\": 0, \"email\": \$e}]" \
            "$CONF" > "$CONF.tmp" && mv "$CONF.tmp" "$CONF"
            
        elif [[ "$PROTO" == "vless" ]]; then
            # Detectar si es Reality para agregar el 'flow'
            SEC=$(jq -r ".inbounds[$i].streamSettings.security" "$CONF")
            if [[ "$SEC" == "reality" ]]; then
                jq --arg u "$uuid" --arg e "$user" \
                ".inbounds[$i].settings.clients += [{\"id\": \$u, \"email\": \$e, \"flow\": \"xtls-rprx-vision\"}]" \
                "$CONF" > "$CONF.tmp" && mv "$CONF.tmp" "$CONF"
            else
                jq --arg u "$uuid" --arg e "$user" \
                ".inbounds[$i].settings.clients += [{\"id\": \$u, \"email\": \$e}]" \
                "$CONF" > "$CONF.tmp" && mv "$CONF.tmp" "$CONF"
            fi
            
        elif [[ "$PROTO" == "trojan" ]]; then
            jq --arg u "$uuid" --arg e "$user" \
            ".inbounds[$i].settings.clients += [{\"password\": \$u, \"email\": \$e}]" \
            "$CONF" > "$CONF.tmp" && mv "$CONF.tmp" "$CONF"
        fi
    done
    
    systemctl restart xray
    
    # Registro en Base de Datos para el Panel Web
    mkdir -p "$DB_USERS/v2ray"
    echo "EXP=$final_date" > "$DB_USERS/v2ray/$user"
    echo "UUID=$uuid" >> "$DB_USERS/v2ray/$user"
    echo "DURATION=$dias" >> "$DB_USERS/v2ray/$user"
    
    echo -e "${C_VERDE} Usuario Registrado.${C_RESET}"
    echo -e " Generando accesos en 'Detalles'..."
    sleep 2
}

# FUNCION: VER DETALLES Y QR (DUAL)
detalles_usuario_v2ray() {
    clear
    seleccionar_usuario_v2 || return 
    CONF="/usr/local/etc/xray/config.json"
    IP=$(curl -s ipv4.icanhazip.com)
    
    # Extraer UUID del usuario seleccionado
    UUID_FINAL=$(jq -r --arg u "$USER_V2" '.inbounds[0].settings.clients[] | select(.email == $u) | .id // .password' "$CONF")
    days=$(get_v2_days "$USER_V2")
    
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LINK DE CONEXION ($USER_V2) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " UUID: ${C_DATO}$UUID_FINAL${C_RESET}"
    echo -e " DIAS: ${C_VERDE}$days${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    
    # Iterar sobre todos los inbounds (puertos)
    total_inbounds=$(jq '.inbounds | length' "$CONF")
    
    for ((i=0; i<$total_inbounds; i++)); do
        # --- LECTURA DE CONFIGURACION ---
        P_PORT=$(jq -r ".inbounds[$i].port" "$CONF")
        P_PROTO=$(jq -r ".inbounds[$i].protocol" "$CONF")
        
        # Stream Settings
        S_SET=".inbounds[$i].streamSettings"
        P_NET=$(jq -r "$S_SET.network" "$CONF")
        P_SEC=$(jq -r "$S_SET.security" "$CONF")
        
        # Variables por defecto
        P_PATH=""
        P_HOST=""
        P_SERV=""
        P_TYPE="none"
        P_FLOW=""
        P_SNI=""
        P_FP=""
        P_PBK=""
        P_SID=""
        
        # DETECCION AVANZADA DE TRANSPORTE
        case $P_NET in
            "ws")
                P_PATH=$(jq -r "$S_SET.wsSettings.path // \"/\"" "$CONF")
                P_HOST=$(jq -r "$S_SET.wsSettings.headers.Host // \"\"" "$CONF")
                P_SNI=$P_HOST
                ;;
            "grpc")
                P_SERV=$(jq -r "$S_SET.grpcSettings.serviceName // \"\"" "$CONF")
                P_TYPE="grpc" # Para VMess
                P_SNI=$(jq -r "$S_SET.tlsSettings.serverName // \"\"" "$CONF") # Intentar leer SNI de TLS
                ;;
            "httpupgrade")
                P_PATH=$(jq -r "$S_SET.httpupgradeSettings.path // \"/\"" "$CONF")
                P_TYPE="httpupgrade"
                ;;
            "kcp")
                P_TYPE=$(jq -r "$S_SET.kcpSettings.header.type // \"none\"" "$CONF")
                P_PATH=$(jq -r "$S_SET.kcpSettings.seed // \"\"" "$CONF") # Usamos path para seed en visualizacion
                ;;
            "tcp")
                P_TYPE="none"
                if [[ "$P_SEC" == "reality" ]]; then
                     P_SNI=$(jq -r "$S_SET.realitySettings.serverNames[0]" "$CONF")
                     P_PBK=$(cat /etc/reagens/reality_pub 2>/dev/null)
                     P_SID=$(jq -r "$S_SET.realitySettings.shortIds[0]" "$CONF")
                     P_FP=$(jq -r "$S_SET.realitySettings.fingerprint // \"chrome\"" "$CONF")
                     P_FLOW="xtls-rprx-vision"
                fi
                ;;
        esac

        # Si hay TLS estándar, intentar sacar el SNI del certificado o usar la IP
        if [[ "$P_SEC" == "tls" && -z "$P_SNI" ]]; then
             # Si no hay SNI definido en config, asumimos que el usuario debe ponerlo o es la IP (si tiene dominio)
             P_SNI="" 
        fi

        NAME="$USER_V2-$P_PROTO-$P_NET"

        # --- GENERACION DE LINKS ---
        LINK=""
        
        # 1. VMESS (JSON Format base64)
        if [[ "$P_PROTO" == "vmess" ]]; then
            # Construimos el JSON de VMess dinamicamente
            VMESS_JSON="{\"v\":\"2\",\"ps\":\"$NAME\",\"add\":\"$IP\",\"port\":\"$P_PORT\",\"id\":\"$UUID_FINAL\",\"aid\":\"0\",\"scy\":\"auto\",\"net\":\"$P_NET\",\"type\":\"$P_TYPE\",\"tls\":\"$P_SEC\",\"sni\":\"$P_SNI\"}"
            
            # Agregamos campos especificos
            if [[ "$P_NET" == "ws" ]]; then
                VMESS_JSON=$(echo $VMESS_JSON | jq --arg p "$P_PATH" --arg h "$P_HOST" '. + {path:$p, host:$h}')
            elif [[ "$P_NET" == "grpc" ]]; then
                VMESS_JSON=$(echo $VMESS_JSON | jq --arg s "$P_SERV" '. + {path:$s, type:"multi"}') # gRPC usa path para serviceName en algunos clientes, o type multi
            elif [[ "$P_NET" == "httpupgrade" ]]; then
                VMESS_JSON=$(echo $VMESS_JSON | jq --arg p "$P_PATH" '. + {path:$p}')
            elif [[ "$P_NET" == "kcp" ]]; then
                VMESS_JSON=$(echo $VMESS_JSON | jq --arg p "$P_PATH" '. + {path:$p}') # Seed
            fi
            
            LINK="vmess://$(echo -n "$VMESS_JSON" | base64 -w 0)"

        # 2. VLESS (Query params)
        elif [[ "$P_PROTO" == "vless" ]]; then
            LINK="vless://$UUID_FINAL@$IP:$P_PORT?security=$P_SEC&type=$P_NET"
            
            # Parametros Extra
            if [[ "$P_SEC" == "reality" ]]; then
                LINK+="&sni=$P_SNI&pbk=$P_PBK&sid=$P_SID&fp=$P_FP&flow=$P_FLOW"
            elif [[ "$P_SEC" == "tls" && ! -z "$P_SNI" ]]; then
                LINK+="&sni=$P_SNI"
            fi
            
            if [[ "$P_NET" == "ws" ]]; then LINK+="&path=$(urlencode $P_PATH)&host=$P_HOST"; fi
            if [[ "$P_NET" == "grpc" ]]; then LINK+="&serviceName=$P_SERV&mode=multi"; fi
            if [[ "$P_NET" == "httpupgrade" ]]; then LINK+="&path=$(urlencode $P_PATH)"; fi
            if [[ "$P_NET" == "kcp" ]]; then LINK+="&headerType=$P_TYPE&seed=$P_PATH"; fi
            
            LINK+="#$NAME"

        # 3. TROJAN
        elif [[ "$P_PROTO" == "trojan" ]]; then
            LINK="trojan://$UUID_FINAL@$IP:$P_PORT?security=$P_SEC&type=$P_NET"
            
            if [[ "$P_SEC" == "tls" && ! -z "$P_SNI" ]]; then LINK+="&sni=$P_SNI"; fi
            if [[ "$P_NET" == "ws" ]]; then LINK+="&path=$(urlencode $P_PATH)&host=$P_HOST"; fi
            if [[ "$P_NET" == "grpc" ]]; then LINK+="&serviceName=$P_SERV&mode=multi"; fi
            if [[ "$P_NET" == "httpupgrade" ]]; then LINK+="&path=$(urlencode $P_PATH)"; fi
            
            LINK+="#$NAME"
        fi

        echo -e " ${C_DATO}Opción #$((i+1)): ${C_VERDE}$P_PROTO + $P_NET ($P_SEC)${C_RESET}"
        echo -e " ${C_TEXTO}$LINK${C_RESET}"
        echo ""
        
        # Guardar el primer link para el QR
        if [[ $i -eq 0 ]]; then LINK_QR=$LINK; fi
    done
    
    if command -v qrencode &> /dev/null; then 
        echo -e " ${C_DATO}QR (Primera Opción):${C_RESET}"
        qrencode -t ANSIUTF8 "$LINK_QR"
    fi
    
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    read -p " Enter para volver..."
}

# AUXILIAR PARA URL ENCODE (Necesario para rutas con /)
urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * )               printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}

eliminar_usuario_v2ray() { 
    clear
    seleccionar_usuario_v2 || return
    jq --arg e "$USER_V2" 'del(.inbounds[0].settings.clients[] | select(.email == $e))' "$V2RAY_CONF" > "$V2RAY_CONF.tmp"
    mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"
    rm -f "$DB_USERS/v2ray/$USER_V2"
    systemctl restart xray
    echo "Borrado."
    sleep 2
}

editar_usuario_v2ray() {
    clear
    seleccionar_usuario_v2 || return
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " [1] Editar Dias (Sumar/Restar)"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Opcion: "
    read o
    meta_file="$DB_USERS/v2ray/$USER_V2"
    case $o in
        1)
            echo -n " Nuevo total de dias desde hoy (Ej: 30): "
            read d
            if [[ "$d" =~ ^[0-9]+$ ]]; then
               fd=$(date -d "+$d days" +%Y-%m-%d)
               sed -i "/EXP=/d" "$meta_file"
               echo "EXP=$fd" >> "$meta_file"
               sed -i "/DURATION=/d" "$meta_file"
               echo "DURATION=$d" >> "$meta_file"
               echo "Hecho. Vence: $fd"
            fi
            ;;
    esac
    sleep 2
}

renovar_usuario_v2ray() {
    clear
    seleccionar_usuario_v2 || return
    meta_file="$DB_USERS/v2ray/$USER_V2"
    source "$meta_file"
    if [[ -z "$DURATION" ]]; then
        echo -n " Ingrese días a renovar (Ej: 30): "
        read DURATION
        echo "DURATION=$DURATION" >> "$meta_file"
    fi
    today_sec=$(date +%s)
    if [[ -z "$EXP" ]]; then 
        base_sec=$today_sec
    else
        exp_sec=$(date -d "$EXP" +%s)
        if [[ $today_sec -gt $exp_sec ]]; then 
            base_sec=$today_sec
        else 
            base_sec=$exp_sec
        fi
    fi
    base_date_str=$(date -d "@$base_sec" +%Y-%m-%d)
    final_date=$(date -d "$base_date_str + $DURATION days" +%Y-%m-%d)
    sed -i "/EXP=/d" "$meta_file"
    echo "EXP=$final_date" >> "$meta_file"
    echo -e "${C_VERDE}Renovado (+$DURATION dias).${C_RESET}"
    echo -e " Nuevo Vencimiento: $final_date"
    sleep 3
}

# --- NUEVA FUNCIÓN: CAMBIAR PUERTO XRAY (SOPORTE DUAL) ---
cambiar_puerto_v2ray() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} CAMBIAR PUERTO XRAY (MODO DUAL) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if [[ ! -f "$V2RAY_CONF" ]]; then
        echo -e " ${C_ROJO}[X] Error: Configuración no encontrada.${C_RESET}"
        sleep 2; return
    fi

    # 1. Detectar cuántos inbounds (servicios) hay
    NUM_INB=$(jq '.inbounds | length' "$V2RAY_CONF")
    INDEX=0

    if [[ "$NUM_INB" -gt 1 ]]; then
        echo -e " Se detectaron ${C_VERDE}$NUM_INB${C_RESET} servicios configurados:"
        for ((i=0; i<NUM_INB; i++)); do
            P=$(jq -r ".inbounds[$i].port" "$V2RAY_CONF")
            PR=$(jq -r ".inbounds[$i].protocol" "$V2RAY_CONF")
            echo -e " [ $((i+1)) ] -> Puerto: ${C_DATO}$P${C_RESET} | Protocolo: ${C_DATO}$PR${C_RESET}"
        done
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -n " ¿Cuál puerto desea cambiar? (1 o 2): "
        read OP_SEL
        
        # Validar selección
        if [[ "$OP_SEL" == "1" ]]; then INDEX=0; elif [[ "$OP_SEL" == "2" ]]; then INDEX=1; else
            echo -e "${C_ROJO}[!] Opción inválida.${C_RESET}"; sleep 2; return
        fi
    fi

    # 2. Obtener datos del puerto seleccionado
    OLD_PORT=$(jq -r ".inbounds[$INDEX].port" "$V2RAY_CONF")
    PROTO_SEL=$(jq -r ".inbounds[$INDEX].protocol" "$V2RAY_CONF")
    
    echo -e "\n Modificando servicio: ${C_VERDE}$PROTO_SEL${C_RESET} (Actual: $OLD_PORT)"
    echo -n " Ingrese el NUEVO Puerto: "
    read NEW_PORT
    
    if [[ -z "$NEW_PORT" || ! "$NEW_PORT" =~ ^[0-9]+$ ]]; then
        echo -e "${C_ROJO}[!] Puerto inválido.${C_RESET}"; sleep 2; return
    fi

    # Verificar si el puerto nuevo está ocupado
    fun_check_port $NEW_PORT "Xray Dual Fix" || return

    # 3. Aplicar cambio con JQ usando el índice seleccionado
    echo -e " ${C_DATO}[+] Actualizando JSON en la posición $INDEX...${C_RESET}"
    jq --argjson idx "$INDEX" --argjson p "$NEW_PORT" '.inbounds[$idx].port = $p' "$V2RAY_CONF" > "$V2RAY_CONF.tmp" && mv "$V2RAY_CONF.tmp" "$V2RAY_CONF"

    # 4. Actualizar Firewall
    echo -e " ${C_DATO}[+] Ajustando IPTables...${C_RESET}"
    iptables -D INPUT -p tcp --dport $OLD_PORT -j ACCEPT 2>/dev/null
    iptables -I INPUT -p tcp --dport $NEW_PORT -j ACCEPT
    fun_save_iptables >/dev/null 2>&1

    # 5. Reiniciar
    systemctl restart xray
    
    echo -e "${C_VERDE} [OK] Puerto actualizado exitosamente a: $NEW_PORT${C_RESET}"
    sleep 3
}

menu_v2ray() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION DE CUENTAS XRAY / V2RAY ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        get_v2_data
        if [[ "$V2_PORT" == "Error" ]]; then 
            echo -e " ESTADO: ${C_ROJO}NO INSTALADO${C_RESET}"
        else 
            echo -e " ${C_DATO}PROTO: $V2_PROTO | PUERTO: $V2_PORT${C_RESET}"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]  > INSTALAR / RECONFIGURAR (TLS/WS)${C_RESET}"
        echo -e " ${C_TEXTO}[2]  > INSTALAR VLESS REALITY (SIN DOMINIO)${C_RESET}"
        echo -e " ${C_VERDE}[3]  > CAMBIAR PUERTO DEL SERVICIO${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[4]  > CREAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[5]  > ELIMINAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[6]  > EDITAR USUARIO (Dias)${C_RESET}"
        echo -e " ${C_TEXTO}[7]  > RENOVAR USUARIO${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[8]  > DETALLES Y LINK DE USUARIO${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0)   VOLVER AL MENU ANTERIOR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Seleccione una opcion: "
        read op_v2
        case $op_v2 in 
            1) proto_v2ray_manager ;; 
            2) install_xray_reality ;;
            3) cambiar_puerto_v2ray ;;
            4) crear_usuario_v2ray ;; 
            5) eliminar_usuario_v2ray ;; 
            6) editar_usuario_v2ray ;; 
            7) renovar_usuario_v2ray ;; 
            8) detalles_usuario_v2ray ;; 
            0) break ;; 
        esac
    done
}

# ==================================================
# BLOQUE HYSTERIA V2 (FINAL: DB + OBFS FIX)
# ==================================================

# DEFINICION EXPLICITA DE RUTAS PARA EVITAR ERRORES
HY_USERS_DB="/etc/reagens/users/hysteria"
HY_CONF="/etc/hysteria/config.yaml"

regen_hysteria_config() {
    # Asegurar que existe el directorio DB
    mkdir -p "$HY_USERS_DB"

    # Leer puerto actual
    PORT_H=36712
    if [[ -f "$HY_CONF" ]]; then
        P_TMP=$(grep "listen:" "$HY_CONF" | grep -oE ':[0-9]+' | cut -d: -f2)
        [[ ! -z "$P_TMP" ]] && PORT_H=$P_TMP
    fi
    
    # --- GENERAR/LEER CLAVE DE OFUSCACION ---
    if [[ ! -f "/etc/hysteria/obfs_pass" ]]; then
        mkdir -p /etc/hysteria
        head -n 1 /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 16 | head -n 1 > /etc/hysteria/obfs_pass
    fi
    OBFS_PASS=$(cat /etc/hysteria/obfs_pass)
    # ----------------------------------------

    # Cabecera YAML con OFUSCACION
    cat <<EOF > "$HY_CONF"
listen: :$PORT_H
tls:
  cert: /etc/hysteria/server.crt
  key: /etc/hysteria/server.key
obfs:
  type: salamander
  salamander:
    password: "$OBFS_PASS"
auth:
  type: userpass
  userpass:
EOF
    # Loop usuarios
    count=0
    # Chequeo estricto de archivos
    if [ "$(ls -A $HY_USERS_DB 2>/dev/null)" ]; then
        for ufile in "$HY_USERS_DB"/*; do
            if [[ -f "$ufile" ]]; then
                u=$(basename "$ufile")
                source "$ufile"
                echo "    $u: \"$PASS\"" >> "$HY_CONF"
                ((count++))
            fi
        done
    fi
    
    # Usuario admin por defecto si no hay nadie
    if [[ "$count" -eq 0 ]]; then
        echo "    admin: \"admin123\"" >> "$HY_CONF"
    fi
    
    # Masquerade
    cat <<EOF >> "$HY_CONF"
masquerade:
  type: proxy
  proxy:
    url: https://bing.com/
    rewriteHost: true
EOF

    # FIX PERMISOS Y REINICIO
    chmod 644 "$HY_CONF"
    systemctl restart hysteria-server
}

install_hysteria() {
    clear
    echo -e " ${C_DATO}[+] Instalando Hysteria V2...${C_RESET}"
    
    # Instalamos el binario oficial
    curl -fsSL https://get.hy2.sh/ | bash
    
    # Creamos directorios
    mkdir -p /etc/hysteria /etc/reagens/users/hysteria
    
    # Certificado
    openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout /etc/hysteria/server.key -out /etc/hysteria/server.crt -days 3650 -subj "/CN=ReagensVPN" &>/dev/null
    
    # Generar config base si no existe
    if [[ ! -f "/etc/hysteria/config.yaml" ]]; then
        cat <<EOF > /etc/hysteria/config.yaml
listen: :36712
tls:
  cert: /etc/hysteria/server.crt
  key: /etc/hysteria/server.key
auth:
  type: userpass
  userpass:
    admin: "admin123"
EOF
    fi

    # --- FORZAR CREACION DE SERVICIO PROPIO ---
    cat <<EOF > /etc/systemd/system/hysteria-server.service
[Unit]
Description=Hysteria V2 Server Reagens
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/etc/hysteria
ExecStart=/usr/local/bin/hysteria server -c /etc/hysteria/config.yaml
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable hysteria-server
    systemctl restart hysteria-server
    
    # Abrir puerto
    iptables -I INPUT -p udp --dport 36712 -j ACCEPT
    
    echo -e "${C_VERDE} Hysteria instalado y servicio forzado como 'hysteria-server'.${C_RESET}"
    sleep 2
}

add_hysteria_user() {
    clear
    # SEGURIDAD: Crear carpeta si no existe
    if [[ ! -d "$HY_USERS_DB" ]]; then
        mkdir -p "$HY_USERS_DB"
    fi

    echo -e "${C_BARRA} AGREGAR USUARIO HYSTERIA ${C_BARRA}"
    echo -n " Usuario: "
    read u
    [[ -z "$u" ]] && return
    if [[ -f "$HY_USERS_DB/$u" ]]; then echo "Existe"; sleep 1; return; fi
    
    echo -n " Contraseña: "
    read p
    [[ -z "$p" ]] && return
    
    echo -n " Dias: "
    read d
    [[ -z "$d" ]] && d=30
    
    fd=$(date -d "+$d days" +%Y-%m-%d)
    
    # GUARDADO EXPLICITO
    echo "PASS=\"$p\"" > "$HY_USERS_DB/$u"
    echo "EXP=\"$fd\"" >> "$HY_USERS_DB/$u"
    
    # VERIFICACION
    if [[ -f "$HY_USERS_DB/$u" ]]; then
        regen_hysteria_config
        echo -e "${C_VERDE} Usuario Agregado y Guardado.${C_RESET}"
    else
        echo -e "${C_ROJO} Error: No se pudo escribir en la base de datos.${C_RESET}"
    fi
    sleep 2
}

del_hysteria_user() {
    clear
    echo -e "${C_BARRA} ELIMINAR USUARIO HYSTERIA ${C_BARRA}"
    i=1
    declare -a h_users
    
    if [[ ! -d "$HY_USERS_DB" ]]; then echo "No hay DB"; sleep 2; return; fi
    
    # Fix para globbing vacio
    shopt -s nullglob
    for f in "$HY_USERS_DB"/*; do
        if [[ -f "$f" ]]; then
            u=$(basename "$f")
            echo " [$i] $u"
            h_users[$i]=$u
            let i++
        fi
    done
    shopt -u nullglob
    
    if [[ $i -eq 1 ]]; then echo "Vacio"; sleep 1; return; fi
    echo -n " Numero: "
    read op
    SEL=${h_users[$op]}
    if [[ ! -z "$SEL" ]]; then
        rm -f "$HY_USERS_DB/$SEL"
        regen_hysteria_config
        echo "Eliminado."
        sleep 1
    fi
}

show_hysteria_link() {
    clear
    echo -e "${C_BARRA} LINK HYSTERIA V2 (OBFS) ${C_BARRA}"
    i=1
    declare -a h_users
    
    if [[ ! -d "$HY_USERS_DB" ]]; then echo "No hay usuarios creados."; sleep 2; return; fi

    # Fix para globbing vacio
    shopt -s nullglob
    for f in "$HY_USERS_DB"/*; do
        if [[ -f "$f" ]]; then
            u=$(basename "$f")
            echo " [$i] $u"
            h_users[$i]=$u
            let i++
        fi
    done
    shopt -u nullglob
    
    if [[ $i -eq 1 ]]; then echo "Vacio"; sleep 1; return; fi
    echo -n " Numero: "
    read op
    SEL=${h_users[$op]}
    if [[ ! -z "$SEL" ]]; then
        source "$HY_USERS_DB/$SEL"
        IP=$(curl -s ipv4.icanhazip.com)
        PORT=$(grep "listen:" "$HY_CONF" | grep -oE ':[0-9]+' | cut -d: -f2)
        
        # Recuperar clave ofuscacion
        if [[ -f "/etc/hysteria/obfs_pass" ]]; then
             OBFS_PASS=$(cat /etc/hysteria/obfs_pass)
        else
             OBFS_PASS=""
        fi

        # Link con OFUSCACION
        LINK="hysteria2://$SEL:$PASS@$IP:$PORT/?insecure=1&sni=bing.com&obfs=salamander&obfs-password=$OBFS_PASS#$SEL"
        
        echo -e "${C_TEXTO} Vence: $EXP ${C_RESET}"
        echo -e "${C_DATO} Clave Obfs: $OBFS_PASS ${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e "${C_DATO}$LINK${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        read -p "Enter..."
    fi
}

menu_hysteria() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION HYSTERIA V2 (UDP) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # --- DETECCION MEJORADA (Garantiza el ON) ---
        if pgrep -x "hysteria" > /dev/null || [ -f "/usr/local/bin/hysteria" ] && { systemctl is-active --quiet hysteria-server || systemctl is-active --quiet hysteria; }; then
            ESTADO_HY="${C_VERDE}? INSTALADO / ON${C_RESET}"
        else
            ESTADO_HY="${C_ROJO}? NO INSTALADO / OFF${C_RESET}"
        fi
        
        echo -e " ESTADO: $ESTADO_HY"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1] > INSTALAR / REINSTALAR HYSTERIA${C_RESET}"
        echo -e " ${C_TEXTO}[2] > CREAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[3] > ELIMINAR USUARIO${C_RESET}"
        echo -e " ${C_TEXTO}[4] > VER LINK DE CONEXION${C_RESET}"
        echo -e " ${C_TEXTO}[5] > DESINSTALAR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1) install_hysteria ;;
            2) add_hysteria_user ;;
            3) del_hysteria_user ;;
            4) show_hysteria_link ;;
            5) 
               systemctl stop hysteria-server hysteria 2>/dev/null
               rm -f /etc/systemd/system/hysteria*
               rm -rf /etc/hysteria
               echo "Desinstalado."
               sleep 2
               ;;
            0) break ;;
        esac
    done
}

# ==================================================
# GESTION PROTOCOLOS Y PUERTOS (SMART FORCE)
# ==================================================

# --- NUEVO SISTEMA SMART FORCE UNIVERSAL (REEMPLAZO) ---
fun_force_smart() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} PROTOCOLO DE EMERGENCIA UNIVERSAL REAGENS ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"

    # 1. DETECCIÓN DE ENTORNO
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_ID=$ID
    else
        echo -e "${C_ROJO} [X] No se pudo detectar el SO. Abortando.${C_RESET}"
        sleep 2 && return
    fi

    echo -e " ${C_DATO}[1] Detectado: $NAME ($VERSION_ID)${C_RESET}"
    echo -e " ${C_DATO}[2] Instalando herramientas necesarias...${C_RESET}"

    # 2. INSTALACIÓN DE DEPENDENCIAS SEGÚN SO
    case "$OS_ID" in
        ubuntu|debian)
            apt-get update -y >/dev/null 2>&1
            apt-get install -y python3 lsof net-tools psmisc iptables-persistent >/dev/null 2>&1
            ;;
        centos|almalinux|rocky)
            yum install -y python3 lsof net-tools psmisc iptables-services >/dev/null 2>&1
            ;;
    esac

    # 3. ESCANEO Y LIMPIEZA TOTAL (EXCEPTO PUERTO 22)
    echo -e " ${C_DATO}[3] Identificando y liberando puertos (Backup en /tmp/reagens_ports.log)${C_RESET}"
    netstat -tulpn | grep -v ":22 " > /tmp/reagens_ports.log

    # Obtenemos todos los PIDs que NO sean del SSH (puerto 22)
    PIDS_A_MATAR=$(lsof -i -P -n | grep LISTEN | grep -v ":22" | awk '{print $2}' | sort -u)

    if [ ! -z "$PIDS_A_MATAR" ]; then
        for pid in $PIDS_A_MATAR; do
            PROCNAME=$(ps -p $pid -o comm=)
            echo -e "     Liberando puerto ocupado por: ${C_ROJO}$PROCNAME${C_RESET} (PID: $pid)"
            kill -9 $pid 2>/dev/null
        done
    else
        echo -e "     No se encontraron procesos bloqueando otros puertos."
    fi

    # 4. CREACIÓN DEL PROXY PYTHON (WS-FIX)
    echo -e " ${C_DATO}[4] Configurando Websocket Proxy (Puerto 80 -> 22)...${C_RESET}"
    mkdir -p /etc/reagens/bin

cat <<'EOF' > /etc/reagens/bin/ws-fix.py
import socket, threading, select, sys
BIND = ('0.0.0.0', 80)
DEST = ('127.0.0.1', 22)
def handler(client_sock):
    target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try: target_sock.connect(DEST)
    except: client_sock.close(); return
    try:
        request = client_sock.recv(4096)
        response = (b'HTTP/1.1 101 REAGENS VPN PRO\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ReagensFix\r\n\r\n')
        client_sock.send(response)
        while True:
            r, w, x = select.select([client_sock, target_sock], [], [])
            if client_sock in r:
                data = client_sock.recv(4096)
                if not data: break
                target_sock.send(data)
            if target_sock in r:
                data = target_sock.recv(4096)
                if not data: break
                client_sock.send(data)
    except: pass
    finally: client_sock.close(); target_sock.close()
def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: server.bind(BIND); server.listen(5)
    except: sys.exit(1)
    while True:
        try: client, addr = server.accept(); threading.Thread(target=handler, args=(client,)).start()
        except: pass
if __name__ == '__main__': main()
EOF

    # 5. GESTIÓN DEL SERVICIO SYSTEMD
    echo -e " ${C_DATO}[5] Desplegando servicio systemd...${C_RESET}"
cat <<EOF > /etc/systemd/system/ws-reagens.service
[Unit]
Description=Reagens Universal Emergency WS
After=network.target
[Service]
Type=simple
ExecStart=/usr/bin/python3 /etc/reagens/bin/ws-fix.py
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable ws-reagens >/dev/null 2>&1
    systemctl restart ws-reagens

    # 6. FIREWALL MULTI-SO
    echo -e " ${C_DATO}[6] Configurando Firewall Nativo...${C_RESET}"
    if command -v firewall-cmd >/dev/null 2>&1; then
        firewall-cmd --permanent --add-port=80/tcp >/dev/null 2>&1
        firewall-cmd --permanent --add-port=22/tcp >/dev/null 2>&1
        firewall-cmd --reload >/dev/null 2>&1
    fi
    if command -v ufw >/dev/null 2>&1; then
        ufw allow 80/tcp >/dev/null 2>&1
        ufw allow 22/tcp >/dev/null 2>&1
    fi
    iptables -I INPUT -p tcp --dport 80 -j ACCEPT
    iptables -I INPUT -p tcp --dport 22 -j ACCEPT

    # 7. DIAGNÓSTICO FINAL
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    if netstat -tuln | grep -q ":80 "; then
        echo -e " ${C_VERDE}[OK] Reagens Proxy activo en puerto 80.${C_RESET}"
    else
        echo -e " ${C_ROJO}[!] Error: El puerto 80 no levantó.${C_RESET}"
    fi
    echo -e " Registro guardado en: /tmp/reagens_ports.log"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Presione Enter para continuar..."
}

# --- GESTOR PYTHON SOCKET CON VERIFICADOR DE PUERTOS ---
fun_python_sock() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} AJUSTES PYTHON WEBSOCKET ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if systemctl is-active --quiet ws-reagens; then
        STATUS="${C_VERDE}ACTIVO${C_RESET}"
        PID=$(pgrep -f "ws-fix.py")
        PORT_ACT=$(netstat -tlpn | grep "$PID/python3" | awk '{print $4}' | awk -F: '{print $NF}')
        echo -e " Estado: $STATUS (Puerto: $PORT_ACT)"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Desactivar Python Socket"
        echo -e " [2] Cambiar Puerto / Reiniciar"
    else
        STATUS="${C_ROJO}DESACTIVADO${C_RESET}"
        echo -e " Estado: $STATUS"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Activar Python Socket"
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " 0) Volver"
    echo -n " Opcion: "
    read op
    
    if [[ "$op" == "0" ]]; then return; fi
    
    if systemctl is-active --quiet ws-reagens; then
        if [[ "$op" == "1" ]]; then
            systemctl stop ws-reagens
            systemctl disable ws-reagens
            echo -e "${C_ROJO} Servicio Detenido.${C_RESET}"
            sleep 2
            return
        fi
    fi
    
    echo -n " Ingrese Puerto para Python (Default 80): "
    read p_py
    [[ -z "$p_py" ]] && p_py=80

    # === MEJORA INTEGRADA: VALIDACION DE PUERTO ===
    # Si el puerto está en uso, mostrará error y cancelará la instalación
    fun_check_port $p_py "Python WebSocket" || return
    # ==============================================
    
    # Liberar puerto por seguridad
    fuser -k $p_py/tcp >/dev/null 2>&1
    
    mkdir -p /etc/reagens/bin
    cat <<EOF > /etc/reagens/bin/ws-fix.py
import socket, threading, select, sys
BIND = ('0.0.0.0', $p_py)
DEST = ('127.0.0.1', 22)
def handler(client_sock):
    target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try: target_sock.connect(DEST)
    except: client_sock.close(); return
    try:
        request = client_sock.recv(4096)
        response = (b'HTTP/1.1 101 REAGENS VPN PRO\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ReagensFix\r\n\r\n')
        client_sock.send(response)
        while True:
            r, w, x = select.select([client_sock, target_sock], [], [])
            if client_sock in r:
                data = client_sock.recv(4096)
                if not data: break
                target_sock.send(data)
            if target_sock in r:
                data = target_sock.recv(4096)
                if not data: break
                client_sock.send(data)
    except: pass
    finally: client_sock.close(); target_sock.close()
def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: server.bind(BIND); server.listen(0)
    except Exception as e: sys.exit(1)
    while True:
        try: client, addr = server.accept(); threading.Thread(target=handler, args=(client,)).start()
        except: pass
if __name__ == '__main__': main()
EOF

    cat <<EOF > /etc/systemd/system/ws-reagens.service
[Unit]
Description=Reagens Python WS
After=network.target
[Service]
ExecStart=/usr/bin/python3 /etc/reagens/bin/ws-fix.py
Restart=always
RestartSec=2
[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable ws-reagens >/dev/null 2>&1
    systemctl restart ws-reagens
    
    iptables -I INPUT -p tcp --dport $p_py -j ACCEPT
    fun_save_iptables    
    echo -e "${C_VERDE} Python Activado en puerto $p_py.${C_RESET}"
    sleep 2
}

# ==================================================
# WS-EPRO: WEBSOCKET PRO (CUSTOM PORTS) - AGREGADO
# ==================================================

fun_instalar_ws_epro() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} INSTALADOR WS-EPRO (MULTI-PORT) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    # 1. DEFINIR PUERTO DE ESCUCHA (ENTRADA)
    echo -e " ${C_DATO}[1] Puerto de ENTRADA (Donde conectan las Apps)${C_RESET}"
    echo -n " Ingrese Puerto (Default 8080): "
    read P_LOCAL
    if [[ -z "$P_LOCAL" ]]; then P_LOCAL=8080; fi

    # 2. DEFINIR PUERTO DE SALIDA (DESTINO)
    echo -e "\n ${C_DATO}[2] Puerto de SALIDA (A donde redirige el tráfico)${C_RESET}"
    echo -e " Ejemplos: 22 (SSH), 443 (SSL), 1194 (OVPN)"
    echo -n " Ingrese Puerto (Default 22): "
    read P_TARGET
    if [[ -z "$P_TARGET" ]]; then P_TARGET=22; fi

    echo -e "\n ${C_TEXTO}Configurando: Entrada ${C_VERDE}$P_LOCAL${C_RESET} -> Salida ${C_VERDE}$P_TARGET${C_RESET}..."
    sleep 1

    # Matar procesos previos en ese puerto para evitar choques
    fuser -k $P_LOCAL/tcp >/dev/null 2>&1

    mkdir -p /etc/reagens/bin
    
    # --- GENERACION DEL SCRIPT PYTHON OPTIMIZADO (WS-EPRO) ---
    cat <<EOF > /etc/reagens/bin/ws-epro.py
import socket, threading, select, sys

# CONFIGURACION DINAMICA
BIND_IP = '0.0.0.0'
BIND_PORT = $P_LOCAL
TARGET_IP = '127.0.0.1'
TARGET_PORT = $P_TARGET
BUFFER_SIZE = 8192

class Server(threading.Thread):
    def __init__(self, conn, addr):
        threading.Thread.__init__(self)
        self.client_socket = conn
        self.addr = addr
        self.running = True

    def run(self):
        target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            target_socket.connect((TARGET_IP, TARGET_PORT))
        except:
            self.client_socket.close()
            return

        try:
            request = self.client_socket.recv(BUFFER_SIZE)
            if request:
                # Handshake Universal
                response = (
                    b'HTTP/1.1 101 REAGENS VPN PRO\r\n'
                    b'Upgrade: websocket\r\n'
                    b'Connection: Upgrade\r\n'
                    b'Sec-WebSocket-Accept: ReagensEpro\r\n\r\n'
                )
                self.client_socket.send(response)
                
                while self.running:
                    r, w, x = select.select([self.client_socket, target_socket], [], [], 30)
                    if self.client_socket in r:
                        data = self.client_socket.recv(BUFFER_SIZE)
                        if not data: break
                        target_socket.send(data)
                    if target_socket in r:
                        data = target_socket.recv(BUFFER_SIZE)
                        if not data: break
                        self.client_socket.send(data)
        except:
            pass
        finally:
            self.client_socket.close()
            target_socket.close()

def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_socket.bind((BIND_IP, BIND_PORT))
        server_socket.listen(100)
    except:
        sys.exit(1)

    while True:
        try:
            client_socket, addr = server_socket.accept()
            Server(client_socket, addr).start()
        except:
            pass

if __name__ == '__main__':
    main()
EOF

    # --- CREAR SERVICIO SYSTEMD ---
    cat <<EOF > /etc/systemd/system/ws-epro.service
[Unit]
Description=Reagens WS-EPRO (Port $P_LOCAL to $P_TARGET)
After=network.target

[Service]
ExecStart=/usr/bin/python3 /etc/reagens/bin/ws-epro.py
Restart=always
RestartSec=2
User=root

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable ws-epro >/dev/null 2>&1
    systemctl restart ws-epro
    
    iptables -I INPUT -p tcp --dport $P_LOCAL -j ACCEPT
    fun_save_iptables >/dev/null 2>&1
    
    echo -e "${C_VERDE} WS-EPRO INSTALADO.${C_RESET}"
    echo -e " Puerto Activo: ${C_DATO}$P_LOCAL${C_RESET} -> Destino: ${C_DATO}$P_TARGET${C_RESET}"
    sleep 3
}

fun_ws_epro_menu() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION WS-EPRO (AVANZADO) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if systemctl is-active --quiet ws-epro; then
            STATUS="${C_VERDE}ACTIVO${C_RESET}"
            if [[ -f "/etc/reagens/bin/ws-epro.py" ]]; then
                IN_P=$(grep "BIND_PORT =" /etc/reagens/bin/ws-epro.py | awk '{print $3}')
                OUT_P=$(grep "TARGET_PORT =" /etc/reagens/bin/ws-epro.py | awk '{print $3}')
                INFO_PORTS="Entrada: ${C_DATO}$IN_P${C_RESET} -> Salida: ${C_DATO}$OUT_P${C_RESET}"
            else
                INFO_PORTS="Puertos: Desconocido"
            fi
            echo -e " ESTADO: $STATUS"
            echo -e " $INFO_PORTS"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > DETENER Y ELIMINAR${C_RESET}"
            echo -e " ${C_TEXTO}[2] > REINICIAR SERVICIO${C_RESET}"
            echo -e " ${C_TEXTO}[3] > CAMBIAR PUERTOS (REINSTALAR)${C_RESET}"
        else
            STATUS="${C_ROJO}DETENIDO${C_RESET}"
            echo -e " ESTADO: $STATUS"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > INSTALAR WS-EPRO${C_RESET}"
        fi
        
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1)
                if systemctl is-active --quiet ws-epro; then
                    systemctl stop ws-epro
                    systemctl disable ws-epro
                    rm -f /etc/systemd/system/ws-epro.service
                    rm -f /etc/reagens/bin/ws-epro.py
                    systemctl daemon-reload
                    echo -e "${C_ROJO} Eliminado.${C_RESET}"; sleep 2
                else
                    fun_instalar_ws_epro
                fi
                ;;
            2) systemctl restart ws-epro; echo "Reiniciado."; sleep 2 ;;
            3) systemctl stop ws-epro; fun_instalar_ws_epro ;;
            0) break ;;
        esac
    done
}

# --- GESTOR BADVPN INTELLIGENTE INFALIBLE ---
fun_badvpn_menu() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} AJUSTES BADVPN UDP (INFALIBLE) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if systemctl is-active --quiet badvpn; then
            STATUS="${C_VERDE}[ON] ACTIVO${C_RESET}"
            PID_BAD=$(pgrep -f "badvpn-udpgw")
            echo -e " ESTADO: $STATUS (PID: $PID_BAD)"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > DESACTIVAR BADVPN${C_RESET}"
            echo -e " ${C_TEXTO}[2] > REINICIAR SERVICIO${C_RESET}"
        else
            STATUS="${C_ROJO}[OFF] DETENIDO${C_RESET}"
            echo -e " ESTADO: $STATUS"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > ACTIVAR BADVPN UDP${C_RESET}"
        fi
        
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op
        
        case $op in
            0) return ;;
            1) 
                if systemctl is-active --quiet badvpn; then
                    systemctl stop badvpn
                    systemctl disable badvpn
                    rm -f /etc/systemd/system/badvpn.service
                    echo -e "${C_ROJO} BadVPN Detenido.${C_RESET}"
                    sleep 2
                else
                    echo -n " Puerto UDP BadVPN (Default 7300): "
                    read port
                    if [[ -z "$port" ]]; then port=7300; fi
                    
                    # LOGICA INFALIBLE (BINARIOS ESTATICOS)
                    ARCH=$(uname -m)
                    echo -e " ${C_DATO}Arquitectura detectada: $ARCH${C_RESET}"
                    rm -f /usr/bin/badvpn-udpgw
                    
                    echo -e " ${C_DATO}Descargando binario estatico...${C_RESET}"
                    
                    if [[ "$ARCH" == "x86_64" ]]; then
                        wget -q --no-check-certificate -O /usr/bin/badvpn-udpgw "https://raw.githubusercontent.com/daybreakersx/prem/master/badvpn-udpgw64"
                    elif [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]]; then
                         wget -q --no-check-certificate -O /usr/bin/badvpn-udpgw "https://raw.githubusercontent.com/shadoowg/vps-mx/master/archivos/badvpn-udpgw"
                    else
                         # Fallback generico
                         wget -q --no-check-certificate -O /usr/bin/badvpn-udpgw "https://raw.githubusercontent.com/daybreakersx/prem/master/badvpn-udpgw64"
                    fi
                    
                    chmod +x /usr/bin/badvpn-udpgw
                    chmod 777 /usr/bin/badvpn-udpgw
                    
                    cat <<EOF > /etc/systemd/system/badvpn.service
[Unit]
Description=BadVPN UDP Gateway
After=network.target

[Service]
ExecStart=/usr/bin/badvpn-udpgw --listen-addr 127.0.0.1:$port --max-clients 1000 --loglevel none
User=root
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF
                    systemctl daemon-reload
                    systemctl enable badvpn >/dev/null 2>&1
                    systemctl restart badvpn
                    
                    iptables -I INPUT -p udp --dport $port -j ACCEPT
    iptables -I INPUT -i lo -j ACCEPT
    fun_save_iptables                    
                    if systemctl is-active --quiet badvpn; then
                        echo -e "${C_VERDE} BadVPN Activado con EXITO en puerto $port.${C_RESET}"
                    else
                         echo -e "${C_ROJO} Error al iniciar. Verificando...${C_RESET}"
                         # Intento de compilacion como ultimo recurso si falla el binario estatico
                         echo "Compilando fallback..."
if [[ -f /etc/redhat-release ]]; then
    yum install -y cmake make gcc unzip wget >/dev/null 2>&1
else
    apt-get install -y cmake make gcc unzip wget >/dev/null 2>&1
fi
                         apt-get install cmake make gcc -y >/dev/null 2>&1
                         mkdir -p /tmp/badvpn_build; cd /tmp/badvpn_build
                         wget -q https://github.com/ambrop72/badvpn/archive/refs/heads/master.zip
                         unzip -q master.zip; cd badvpn-master; mkdir build; cd build
                         cmake -DBUILD_NOTHING_BY_DEFAULT=1 -DBUILD_UDPGW=1 .. >/dev/null 2>&1
                         make >/dev/null 2>&1
                         cp udpgw/badvpn-udpgw /usr/bin/badvpn-udpgw
                         chmod +x /usr/bin/badvpn-udpgw
                         cd /root; rm -rf /tmp/badvpn_build
                         systemctl restart badvpn
                    fi
                    sleep 2
                fi
                ;;
            2)
                systemctl restart badvpn
                echo -e "${C_VERDE} Servicio Reiniciado.${C_RESET}"
                sleep 2
                ;;
        esac
    done
}

# --- GESTOR SSL STUNNEL ---
fun_ssl_menu() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} AJUSTES SSL STUNNEL ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    # Definir nombres de paquete y servicio segun sistema
    if [[ -f /etc/redhat-release ]]; then
        SSL_PKG="stunnel"
        SSL_SVC="stunnel"
    else
        SSL_PKG="stunnel4"
        SSL_SVC="stunnel4"
    fi

    if command -v stunnel >/dev/null 2>&1 || command -v stunnel4 >/dev/null 2>&1; then
        echo -e " Estado: ${C_VERDE}INSTALADO${C_RESET}"
        # Buscamos config en ambas ubicaciones posibles
        if [[ -f /etc/stunnel/stunnel.conf ]]; then
            PORTS=$(grep "accept" /etc/stunnel/stunnel.conf | cut -d= -f2 | tr '\n' ' ')
        else
            PORTS="Desconocido"
        fi
        echo -e " Puertos activos: $PORTS"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Agregar Nuevo Puerto"
        echo -e " [2] Eliminar todos los puertos y desinstalar"
    else
        echo -e " Estado: ${C_ROJO}NO INSTALADO${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " [1] Instalar y Agregar Puerto"
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " 0) Volver"
    echo -n " Opcion: "
    read op
    
    case $op in
        1) 
           # Instalacion Universal
           if ! command -v stunnel >/dev/null 2>&1 && ! command -v stunnel4 >/dev/null 2>&1; then 
               if [[ -f /etc/redhat-release ]]; then
                   yum install -y $SSL_PKG openssl
               else
                   apt-get install -y $SSL_PKG openssl
               fi
               
               # Generar certificado self-signed
               openssl req -new -newkey rsa:2048 -days 3650 -nodes -x509 -sha256 -subj "/CN=Reagens" -keyout /etc/stunnel/stunnel.pem -out /etc/stunnel/stunnel.pem >/dev/null 2>&1
               
               # Habilitar en Debian/Ubuntu
               if [[ -f /etc/default/stunnel4 ]]; then sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4; fi
           fi
           
           echo -n " Puerto SSL: "
           read p
           if [[ ! -z "$p" ]]; then
               mkdir -p /etc/stunnel
               echo "[ssh-ssl-$p]" >> /etc/stunnel/stunnel.conf
               echo "cert=/etc/stunnel/stunnel.pem" >> /etc/stunnel/stunnel.conf
               echo "accept=$p" >> /etc/stunnel/stunnel.conf
               echo "connect=127.0.0.1:22" >> /etc/stunnel/stunnel.conf
               
               # Reiniciar servicio universal
               systemctl restart $SSL_SVC
               
               iptables -I INPUT -p tcp --dport $p -j ACCEPT
    fun_save_iptables
               
               echo -e "${C_VERDE}Puerto $p agregado.${C_RESET}"
               sleep 2
           fi
           ;;
        2)
           if [[ -f /etc/redhat-release ]]; then
               yum remove -y $SSL_PKG
           else
               apt-get purge -y $SSL_PKG
           fi
           rm -rf /etc/stunnel
           echo "Eliminado"
           sleep 2 
           ;;
        0) return ;;
    esac
}

# --- GESTOR DROPBEAR FLEXIBLE (CON PERSISTENCIA) ---
fun_dropbear_menu() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTOR DROPBEAR SSH (PUERTO PERSONALIZADO) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        if systemctl is-active --quiet dropbear-custom; then
            PORT_ACTUAL=$(grep "ExecStart" /etc/systemd/system/dropbear-custom.service | grep -oE "\-p [0-9]+" | awk '{print $2}')
            echo -e " ESTADO: ${C_VERDE}ACTIVO${C_RESET} | PUERTO: ${C_DATO}$PORT_ACTUAL${C_RESET}"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > CAMBIAR PUERTO / REINSTALAR${C_RESET}"
            echo -e " ${C_TEXTO}[2] > DETENER Y DESINSTALAR${C_RESET}"
        else
            echo -e " ESTADO: ${C_ROJO}NO INSTALADO${C_RESET}"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > INSTALAR DROPBEAR${C_RESET}"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1)
                echo -n " Ingresa el Puerto [Default 9090]: "
                read DB_PORT
                [[ -z "$DB_PORT" ]] && DB_PORT="9090"
                fuser -k $DB_PORT/tcp >/dev/null 2>&1
                systemctl stop dropbear-custom >/dev/null 2>&1
                if ! command -v dropbear >/dev/null 2>&1; then
                    [[ -f /etc/redhat-release ]] && yum install dropbear -y || apt-get install dropbear -y; fi
                BIN_DB=$(command -v dropbear)
cat <<EOF > /etc/systemd/system/dropbear-custom.service
[Unit]
Description=Dropbear Custom Port $DB_PORT
After=network.target
[Service]
Type=simple
ExecStart=$BIN_DB -F -p $DB_PORT -w -g
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
EOF
                systemctl daemon-reload
                systemctl enable dropbear-custom
                systemctl restart dropbear-custom
                iptables -I INPUT -p tcp --dport $DB_PORT -j ACCEPT
                fun_save_iptables
                echo -e "${C_VERDE} DROPBEAR ACTIVO EN PUERTO $DB_PORT.${C_RESET}"; sleep 2 ;;
            2)
                systemctl stop dropbear-custom; systemctl disable dropbear-custom
                rm -f /etc/systemd/system/dropbear-custom.service
                fun_save_iptables
                echo "Servicio detenido y eliminado."; sleep 2 ;;
            0) return ;;
        esac
    done
}

# --- SLOWDNS FIX: VERSION FISABILIYUSRI (SOLICITADO) ---
fun_slowdns_menu() {
    SLOWDNS_DIR="/etc/slowdns"
    mkdir -p $SLOWDNS_DIR

    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} SLOWDNS MANAGER (FIX REAGENS) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # Verificar estado real
        if systemctl is-active --quiet slowdns-server; then
            STATUS_SD="${C_VERDE}ACTIVO${C_RESET}"
            # Leer configuración actual del servicio
            SVC_FILE="/etc/systemd/system/slowdns-server.service"
            # Extraer el dominio (penúltimo argumento)
            CURR_NS=$(grep "ExecStart" $SVC_FILE 2>/dev/null | awk '{print $(NF-1)}')
            # Extraer el target (último argumento)
            CURR_TARGET=$(grep "ExecStart" $SVC_FILE 2>/dev/null | awk '{print $NF}')
        else
            STATUS_SD="${C_ROJO}DETENIDO${C_RESET}"
            CURR_NS="No configurado"
            CURR_TARGET="???"
        fi

        echo -e " ESTADO      : $STATUS_SD"
        echo -e " NS DOMINIO  : ${C_DATO}$CURR_NS${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " PTO ENTRADA : ${C_VERDE}53 (UDP)${C_RESET} [Fijo/Internet]"
        echo -e " PTO SALIDA  : ${C_DATO}$CURR_TARGET${C_RESET} [Interno]"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        
        if systemctl is-active --quiet slowdns-server; then
            echo -e " ${C_TEXTO}[1] > VER LLAVE (SERVER.PUB)${C_RESET}"
            echo -e " ${C_TEXTO}[2] > REINICIAR SERVICIO${C_RESET}"
            echo -e " ${C_TEXTO}[3] > DESINSTALAR${C_RESET}"
            echo -e " ${C_DATO}[4] > CAMBIAR PUERTO DE SALIDA (Interno)${C_RESET}"
        else
            echo -e " ${C_TEXTO}[1] > INSTALAR Y ARREGLAR (AUTO-KEY)${C_RESET}"
        fi
        
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        
        case $op in
            1)
                if systemctl is-active --quiet slowdns-server; then
                    clear
                    echo -e "${C_BARRA}=====================================================${C_RESET}"
                    echo -e " NS DOMAIN  : ${C_VERDE}$CURR_NS${C_RESET}"
                    if [[ -f "$SLOWDNS_DIR/server.pub" ]]; then
                        echo -e " PUBLIC KEY : ${C_DATO}$(cat $SLOWDNS_DIR/server.pub)${C_RESET}"
                    else
                        echo -e "${C_ROJO} Error: Archivo server.pub no encontrado.${C_RESET}"
                    fi
                    echo -e "${C_BARRA}=====================================================${C_RESET}"
                    read -p " Enter para volver..."
                else
                    # --- INSTALACION REPARADA ---
                    clear
                    echo -e "${C_BARRA}=====================================================${C_RESET}"
                    msg_center "${C_TITULO} INSTALANDO RECURSOS... ${C_RESET}"
                    echo -e "${C_BARRA}=====================================================${C_RESET}"
                    
                    echo -n " Ingrese su DOMINIO NS (Ej: ns.midominio.com): "
                    read NS_DOMAIN
                    if [[ -z "$NS_DOMAIN" ]]; then echo -e "${C_ROJO}Dominio vacio.${C_RESET}"; sleep 2; continue; fi

                    # --- NUEVO: PREGUNTAR PUERTO SALIDA ---
                    echo -e "\n ${C_DATO}Seleccione el servicio destino (Salida):${C_RESET}"
                    echo -e " [SSH]    -> Escriba 22"
                    echo -e " [V2RAY] -> Escriba su puerto (Ej: 8080)"
                    echo -e " [SSL]    -> Escriba su puerto (Ej: 443)"
                    echo -n " Puerto de Salida [Default 22]: "
                    read TARGET_PORT
                    [[ -z "$TARGET_PORT" ]] && TARGET_PORT=22
                    # --------------------------------------

                    # 1. LIMPIEZA TOTAL
                    echo -e "${C_DATO}[!] Deteniendo servicios conflictivos...${C_RESET}"
                    systemctl stop slowdns-server >/dev/null 2>&1
                    systemctl stop systemd-resolved >/dev/null 2>&1
                    systemctl disable systemd-resolved >/dev/null 2>&1
                    fuser -k 53/udp >/dev/null 2>&1
                    fuser -k 53/tcp >/dev/null 2>&1
                    
                    # Fix DNS temporal
                    rm -f /etc/resolv.conf
                    echo "nameserver 8.8.8.8" > /etc/resolv.conf

                    # 2. DESCARGA DE BINARIOS
                    echo -e "${C_DATO}[+] Detectando Arquitectura...${C_RESET}"
                    rm -rf $SLOWDNS_DIR/* wget -q -O $SLOWDNS_DIR/sldns-client "https://raw.githubusercontent.com/fisabiliyusri/SLDNS/main/slowdns/sldns-client"

                    case $(uname -m) in
                        x86_64) wget -q -O $SLOWDNS_DIR/sldns-server "https://raw.githubusercontent.com/fisabiliyusri/SLDNS/main/slowdns/sldns-server" ;;
                        aarch64|arm64) wget -q -O $SLOWDNS_DIR/sldns-server "https://github.com/vernesong/OpenClash/raw/core/master/core-backup/dnstt-server-linux-arm64" ;;
                        *) wget -q -O $SLOWDNS_DIR/sldns-server "https://raw.githubusercontent.com/fisabiliyusri/SLDNS/main/slowdns/sldns-server" ;;
                    esac
                    
                    chmod +x $SLOWDNS_DIR/*
                    
                    # 3. GENERAR LLAVES
                    echo -e "${C_DATO}[+] Generando llaves nativas...${C_RESET}"
                    cd $SLOWDNS_DIR
                    ./sldns-server -gen-key -privkey-file server.key -pubkey-file server.pub
                    
                    if [[ ! -s "$SLOWDNS_DIR/server.pub" ]]; then
                         echo -e "${C_ROJO} Error fatal: No se pudieron generar las llaves.${C_RESET}"
                         read -p "Enter..."
                         continue
                    fi

                    # 4. CREAR SERVICIO (AQUI SE DEFINE LA ENTRADA 53 FIJA)
                    echo -e "${C_DATO}[+] Creando servicio Systemd...${C_RESET}"
                    cat <<EOF > /etc/systemd/system/slowdns-server.service
[Unit]
Description=SlowDNS Server Fixed
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=$SLOWDNS_DIR
ExecStart=$SLOWDNS_DIR/sldns-server -udp :53 -mtu 1200 -privkey-file $SLOWDNS_DIR/server.key $NS_DOMAIN 127.0.0.1:$TARGET_PORT
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF
                    # 5. FIREWALL
                    iptables -I INPUT -p udp --dport 53 -j ACCEPT
                    iptables -I INPUT -p tcp --dport 53 -j ACCEPT
                    fun_save_iptables >/dev/null 2>&1
                    
                    # 6. INICIAR
                    systemctl daemon-reload
                    systemctl enable slowdns-server >/dev/null 2>&1
                    systemctl restart slowdns-server
                    
                    sleep 2
                    
                    if systemctl is-active --quiet slowdns-server; then
                        echo -e "\n${C_VERDE} ¡INSTALADO CORRECTAMENTE!${C_RESET}"
                        echo -e " Escuchando en: Puerto 53 (UDP)"
                        echo -e " Redirigiendo a: 127.0.0.1:$TARGET_PORT"
                        echo -e " Tu llave pública es: "
                        echo -e "${C_DATO}$(cat $SLOWDNS_DIR/server.pub)${C_RESET}"
                    else
                        echo -e "\n${C_ROJO} ERROR CRÍTICO: El servicio sigue sin arrancar.${C_RESET}"
                        journalctl -u slowdns-server -n 5 --no-pager
                    fi
                    read -p " Enter para continuar..."
                fi
                ;;
            2)
                systemctl restart slowdns-server
                echo -e "${C_VERDE} Reiniciado.${C_RESET}"; sleep 1
                ;;
            3)
                systemctl stop slowdns-server
                systemctl disable slowdns-server
                rm -f /etc/systemd/system/slowdns-server.service
                rm -rf $SLOWDNS_DIR
                echo -e "${C_VERDE} Eliminado.${C_RESET}"; sleep 1
                ;;
            4)
                # CAMBIAR PUERTO SIN REINSTALAR
                echo -n " Nuevo puerto de SALIDA (Target) [Ej: 22, 8080]: "
                read NEW_PORT
                if [[ ! -z "$NEW_PORT" ]]; then
                    SVC_FILE="/etc/systemd/system/slowdns-server.service"
                    # Reemplaza SOLO la parte final (Target) manteniendo el resto
                    sed -i "s|127.0.0.1:[0-9]*|127.0.0.1:$NEW_PORT|g" $SVC_FILE
                    systemctl daemon-reload
                    systemctl restart slowdns-server
                    echo -e "${C_VERDE} Salida cambiada a $NEW_PORT. Reiniciando...${C_RESET}"
                    sleep 2
                else
                    echo "Cancelado."
                fi
                ;;
            0) break ;;
        esac
    done
}

fun_udp_custom_menu() {
    local R='\033[1;31m' G='\033[1;32m' Y='\033[1;33m' B='\033[1;34m' C='\033[1;36m' NC='\033[0m'
    clear
    
    # Verificación de Estado Real (No solo systemd)
    if pgrep -x "udp-custom" > /dev/null; then
        estado_udp="${G}? ACTIVADO Y CORRIENDO${NC}"
    else
        estado_udp="${R}? CAÍDO / ERROR DE MOTOR${NC}"
    fi

    local p_actual=$(grep -Po '(?<="listen": ":)[^"]*' /etc/udp-custom/config.json 2>/dev/null || echo "56666")

    echo -e "${B}=====================================================${NC}"
    echo -e "      ${Y}UDP CUSTOM PRO - ACTIVACIÓN FORZADA${NC}"
    echo -e "${B}=====================================================${NC}"
    echo -e "  ESTADO      : $estado_udp"
    echo -e "  PUERTO      : ${C}$p_actual${NC}"
    echo -e "${B}-----------------------------------------------------${NC}"
    echo -e "  [1] > ${G}FORZAR INSTALACIÓN Y LIMPIEZA TOTAL${NC}"
    echo -e "  [2] > DETENER Y LIBERAR PROCESOS${NC}"
    echo -e "  [3] > LOGS CRÍTICOS (DEPURACIÓN)${NC}"
    echo -e "  [4] > CAMBIAR PUERTO Y REINICIAR${NC}"
    echo -e "${B}=====================================================${NC}"
    echo -e "  0) VOLVER"
    echo -ne "  Opcion: "
    read opt_udp

    case $opt_udp in
        1)
            echo -e "\n${Y}[!] PASO 1: Matando procesos fantasma...${NC}"
            systemctl stop reagens-udp >/dev/null 2>&1
            pkill -9 udp-custom >/dev/null 2>&1
            fuser -k $p_actual/udp >/dev/null 2>&1
            
            echo -e "${Y}[!] PASO 2: Verificando Arquitectura...${NC}"
            mkdir -p /etc/udp-custom
            local arch=$(uname -m)
            [[ "$arch" == "x86_64" ]] && local url="${REPO_URL}/binarios/udp-custom-x86" || local url="${REPO_URL}/binarios/udp-custom-arm"

            echo -e "${Y}[!] PASO 3: Descargando Motor...${NC}"
            wget -q -O /etc/udp-custom/udp-custom "$url"
            
            # --- VALIDACIÓN CRÍTICA ---
            if [[ ! -s /etc/udp-custom/udp-custom ]]; then
                echo -e "${R}[ERROR] El archivo bajó vacío. Revisa tus links en GitLab!${NC}"
                sleep 3 && fun_udp_custom_menu && return
            fi
            chmod +x /etc/udp-custom/udp-custom

            echo -e "${Y}[!] PASO 4: Reconfigurando IPtables...${NC}"
            iptables -D INPUT -p udp --dport $p_actual -j ACCEPT >/dev/null 2>&1
            iptables -I INPUT -p udp --dport $p_actual -j ACCEPT
            
            echo -e "${Y}[!] PASO 5: Lanzando Servicio...${NC}"
            # Recreamos el servicio para asegurar limpieza
            cat <<EOF > /etc/systemd/system/reagens-udp.service
[Unit]
Description=Reagens UDP PRO
After=network.target
[Service]
Type=simple
User=root
WorkingDirectory=/etc/udp-custom
ExecStart=/etc/udp-custom/udp-custom server -exclude 22,80,443 -config /etc/udp-custom/config.json
Restart=always
RestartSec=2
[Install]
WantedBy=multi-user.target
EOF
            systemctl daemon-reload
            systemctl enable reagens-udp >/dev/null 2>&1
            systemctl start reagens-udp

            sleep 2
            if pgrep -x "udp-custom" > /dev/null; then
                echo -e "${G}[ÉXITO] MOTOR NATIVO ACTIVADO CORRECTAMENTE.${NC}"
            else
                echo -e "${R}[FALLO] El motor se cerró. Revisa los logs (Opcion 3).${NC}"
            fi
            sleep 2 && fun_udp_custom_menu
            ;;
        2)
            systemctl stop reagens-udp && pkill -9 udp-custom
            echo -e "${R}[!] Procesos aniquilados.${NC}"
            sleep 2 && fun_udp_custom_menu
            ;;
        3)
            echo -e "${Y}[!] Mostrando errores del sistema (Ctrl+C para salir)...${NC}"
            journalctl -u reagens-udp -n 20 --no-pager
            echo -e "${B}-----------------------------------------------------${NC}"
            echo -ne "${Y}Presione Enter para continuar...${NC}"
            read
            fun_udp_custom_menu
            ;;
        0) menu ;;
        *) fun_udp_custom_menu ;;
    esac
}

# --- FUNCION AUXILIAR PARA GENERAR BLOQUES JSON (MODO WIZARD) ---
generar_json_inbound() {
    local NUM_PERFIL=$1
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_VERDE}CONFIGURANDO PERFIL #$NUM_PERFIL${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"

    # 1. PROTOCOLO
    echo -e " ${C_TEXTO}Protocolo:${C_RESET}"
    echo -e " [1] VLESS  [2] VMESS  [3] TROJAN"
    echo -n " Opcion: "; read op_p
    case $op_p in
        1) P_NOM="vless";;
        2) P_NOM="vmess";;
        3) P_NOM="trojan";;
        *) P_NOM="vless";;
    esac

    # 2. PUERTO
    echo -n " Puerto de Apertura (Ej: 8080, 443): "; read P_PORT
    [[ -z "$P_PORT" ]] && P_PORT=8080
    fun_check_port $P_PORT "Perfil Xray" || return

    # 3. TRANSPORTE Y HOST
    echo -e " ${C_TEXTO}Transporte / Red:${C_RESET}"
    echo -e " [1] TCP (Directo)"
    echo -e " [2] WS (WebSocket - CDN)"
    echo -e " [3] gRPC"
    echo -e " [4] HTTPUpgrade"
    echo -e " [5] mKCP"
    echo -n " Opcion: "; read op_n
    
    # --- VARIABLES POR DEFECTO ---
    LNET="tcp"
    STREAM_S=""
    DEFAULT_PATH="/REAGENS VPN PRO/"
    P_HOST_HEADER=""

    case $op_n in
        2) # WebSocket
            LNET="ws"
            echo -e "\n ${C_DATO}--- CONFIGURACION WEBSOCKET ---${C_RESET}"
            echo -n " Host (Header/Payload) [Ej: midominio.com]: "; read P_HOST_HEADER
            echo -n " Ruta/Path [Enter para '$DEFAULT_PATH']: "; read P_PATH
            [[ -z "$P_PATH" ]] && P_PATH="$DEFAULT_PATH"
            
            # Construccion Settings WS
            STREAM_S="\"wsSettings\": { \"path\": \"$P_PATH\", \"headers\": { \"Host\": \"$P_HOST_HEADER\" } },"
            ;;
            
        3) # gRPC
            LNET="grpc"
            echo -n " ServiceName (Host) [Ej: grpc]: "; read P_SERV
            [[ -z "$P_SERV" ]] && P_SERV="grpc"
            STREAM_S="\"grpcSettings\": { \"serviceName\": \"$P_SERV\" },"
            ;;
            
        4) # HTTPUpgrade
            LNET="httpupgrade"
            echo -n " Host (Header) [Ej: midominio.com]: "; read P_HOST_HEADER
            echo -n " Ruta/Path [Enter para '$DEFAULT_PATH']: "; read P_PATH
            [[ -z "$P_PATH" ]] && P_PATH="$DEFAULT_PATH"
            STREAM_S="\"httpupgradeSettings\": { \"path\": \"$P_PATH\", \"host\": \"$P_HOST_HEADER\" },"
            ;;
            
        5) # mKCP
            LNET="kcp"
            STREAM_S="\"kcpSettings\": { \"header\": { \"type\": \"none\" }, \"seed\": \"reagens\" },"
            ;;
            
        *) # TCP
            LNET="tcp"
            STREAM_S="\"tcpSettings\": {},"
            ;;
    esac

    # 4. SEGURIDAD TLS Y DOMINIO VPS
    echo -e "\n ${C_TEXTO}Seguridad:${C_RESET}"
    echo -e " [1] NONE (Sin cifrado / HTTP)"
    echo -e " [2] TLS (Certificado / HTTPS)"
    if [[ "$P_NOM" == "vless" && "$LNET" == "tcp" ]]; then echo -e " [3] REALITY (Vision)"; fi
    echo -n " Opcion: "; read op_sec

    SEC="none"
    TLS_S=""
    P_DOMAIN_VPS=""
    
    if [[ "$op_sec" == "2" ]]; then
        SEC="tls"
        echo -e "\n ${C_DATO}--- CONFIGURACION DOMINIO (TLS) ---${C_RESET}"
        echo -e " Ingrese el DOMINIO que apunta a esta VPS (Para el certificado)."
        echo -n " Dominio VPS: "; read P_DOMAIN_VPS
        
        # Validacion de certificados
        if [[ -f "/etc/reagens/cert/public.crt" ]]; then
             # Inyectamos el dominio del VPS como serverName para el certificado
             TLS_S="\"tlsSettings\": { \"serverName\": \"$P_DOMAIN_VPS\", \"certificates\": [ { \"certificateFile\": \"/etc/reagens/cert/public.crt\", \"keyFile\": \"/etc/reagens/cert/private.key\" } ] },"
        else
             echo -e " ${C_ROJO}Alerta: No hay certificados en /etc/reagens/cert.${C_RESET}"
             echo -e " Se configurará, pero Xray podría fallar si no los generas."
             TLS_S="\"tlsSettings\": { \"serverName\": \"$P_DOMAIN_VPS\" },"
        fi

    elif [[ "$op_sec" == "3" && "$P_NOM" == "vless" ]]; then
        SEC="reality"
        echo -n " SNI Destino (Ej: www.microsoft.com): "; read SNI_REAL
        [[ -z "$SNI_REAL" ]] && SNI_REAL="www.microsoft.com"
        
        KEYS=$(xray x25519)
        PK=$(echo "$KEYS" | grep "Private" | awk '{print $3}')
        PUB=$(echo "$KEYS" | grep "Public" | awk '{print $3}')
        SID=$(openssl rand -hex 4)
        
        mkdir -p /etc/reagens
        echo "$PUB" > /etc/reagens/reality_pub
        
        TLS_S="\"realitySettings\": { \"show\": false, \"dest\": \"$SNI_REAL:443\", \"xver\": 0, \"serverNames\": [ \"$SNI_REAL\" ], \"privateKey\": \"$PK\", \"shortIds\": [ \"$SID\" ], \"fingerprint\": \"chrome\" },"
    fi

    # GENERAR CLIENTE BASE
    UUID_INIT=$(uuidgen)
    if [[ "$P_NOM" == "vmess" ]]; then CL_STR="{ \"id\": \"$UUID_INIT\", \"alterId\": 0, \"email\": \"admin\" }"
    elif [[ "$P_NOM" == "trojan" ]]; then CL_STR="{ \"password\": \"$UUID_INIT\", \"email\": \"admin\" }"
    else 
        if [[ "$SEC" == "reality" ]]; then CL_STR="{ \"id\": \"$UUID_INIT\", \"email\": \"admin\", \"flow\": \"xtls-rprx-vision\" }"
        else CL_STR="{ \"id\": \"$UUID_INIT\", \"email\": \"admin\" }"
        fi
    fi
    
    # RETORNAR EL BLOQUE JSON EN VARIABLE GLOBAL
    JSON_OUT="{
      \"port\": $P_PORT,
      \"protocol\": \"$P_NOM\",
      \"settings\": { \"clients\": [ $CL_STR ], \"decryption\": \"none\" },
      \"streamSettings\": {
        \"network\": \"$LNET\",
        \"security\": \"$SEC\",
        $TLS_S
        $STREAM_S
        \"sockopt\": { \"mark\": 0 }
      }
    }"
    
    # Guardar datos para el usuario por defecto
    mkdir -p /etc/reagens/users/v2ray
    echo "EXP=$(date -d '+30 days' +%Y-%m-%d)" > "/etc/reagens/users/v2ray/admin"
    echo "UUID=$UUID_INIT" >> "/etc/reagens/users/v2ray/admin"
}

# --- MANAGER PRINCIPAL (CON SOPORTE DUAL Y PREGUNTAS COMPLETAS) ---
proto_v2ray_manager() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} INSTALADOR XRAY DUAL (FULL WIZARD) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if [[ ! -f "/usr/local/bin/xray" ]]; then
        echo -e " ${C_DATO}Instalando Nucleo...${C_RESET}"
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install --force
        sleep 2; clear
    fi

    # --- PERFIL 1 ---
    generar_json_inbound 1
    INBOUND_1="$JSON_OUT"
    
    # --- PREGUNTA PERFIL 2 ---
    INBOUND_FINAL="$INBOUND_1"
    
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_DATO}¿Desea agregar un Segundo Puerto/Protocolo? (Dual)${C_RESET}"
    echo -n " [s/n]: "
    read op_dual
    
    if [[ "$op_dual" == "s" ]]; then
        generar_json_inbound 2
        INBOUND_2="$JSON_OUT"
        INBOUND_FINAL="$INBOUND_1, $INBOUND_2"
        TXT_INFO="SISTEMA DUAL (2 Puertos)"
    else
        TXT_INFO="SISTEMA SIMPLE (1 Puerto)"
    fi

    # --- ESCRIBIR ARCHIVO ---
    echo -e "\n ${C_DATO}Generando config.json...${C_RESET}"
    mkdir -p /usr/local/etc/xray
    
    cat > /usr/local/etc/xray/config.json <<EOF
{
  "log": { "loglevel": "warning" },
  "inbounds": [ $INBOUND_FINAL ],
  "outbounds": [ 
    { "protocol": "freedom", "tag": "direct" }, 
    { "protocol": "blackhole", "tag": "block" } 
  ]
}
EOF

    # --- APLICAR ---
    # Limpiar puertos usados en el config
    PORTS=$(grep "\"port\":" /usr/local/etc/xray/config.json | awk '{print $2}' | tr -d ',')
    for P in $PORTS; do
        fuser -k $P/tcp >/dev/null 2>&1
        fuser -k $P/udp >/dev/null 2>&1
        # Matar servicios web si se usa el 80 o 443
        if [[ "$P" == "80" || "$P" == "443" ]]; then
            systemctl stop nginx >/dev/null 2>&1
            systemctl stop apache2 >/dev/null 2>&1
        fi
        iptables -I INPUT -p tcp --dport $P -j ACCEPT
        iptables -I INPUT -p udp --dport $P -j ACCEPT
    done
    fun_save_iptables >/dev/null 2>&1
    
    systemctl restart xray
    systemctl enable xray >/dev/null 2>&1

    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e "${C_VERDE} ¡INSTALACION COMPLETADA!${C_RESET}"
    echo -e " Modo: $TXT_INFO"
    echo -e " Puertos Activos: ${C_DATO}$PORTS${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    sleep 4
}

# --- NUEVA FUNCION: CLONADOR DE PUERTOS (SOCAT) ---
# --- NUEVA FUNCION: CLONADOR DE PUERTOS V3 (SOCAT + SYSTEMD) ---
fun_puerto_espejo() {
    MIRROR_SVC="/etc/systemd/system/socat-mirror.service"
    
    # Intenta leer la configuración actual del servicio
    P_OPEN="?"
    P_TARGET="?"
    if systemctl is-active --quiet socat-mirror; then
        STATUS_MIRROR="${C_VERDE}ACTIVO (Systemd)${C_RESET}"
        ACT_CODE=2
        # Intentar obtener los puertos desde el archivo de servicio
        EXEC_LINE=$(grep "ExecStart=" $MIRROR_SVC 2>/dev/null)
        P_OPEN=$(echo "$EXEC_LINE" | grep -oE "LISTEN:[0-9]+" | cut -d: -f2)
        P_TARGET=$(echo "$EXEC_LINE" | grep -oE "TCP:127.0.0.1:[0-9]+" | cut -d: -f3)
        OPT_TXT="DETENER Y ELIMINAR SERVICIO"
    elif [[ -f "$MIRROR_SVC" ]]; then
        STATUS_MIRROR="${C_ROJO}DETENIDO (Servicio Existe)${C_RESET}"
        ACT_CODE=2
        OPT_TXT="ELIMINAR SERVICIO EXISTENTE"
    else
        STATUS_MIRROR="${C_ROJO}DESACTIVADO${C_RESET}"
        ACT_CODE=1
        OPT_TXT="CREAR E INICIAR PUERTO CLON (Systemd)"
    fi

    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CLONADOR DE PUERTOS (SOCAT SYSTEMD) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if [[ "$ACT_CODE" == "2" ]]; then
            echo -e " ESTADO: $STATUS_MIRROR"
            echo -e " CLON: ${C_DATO}Puerto $P_OPEN imita al $P_TARGET${C_RESET}"
        else
             echo -e " ESTADO: $STATUS_MIRROR"
             echo -e " NOTA: Asegúrate que el Puerto $P_TARGET esté activo (ej: Python Socket en 80)."
        fi
        
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > $OPT_TXT${C_RESET}"
        if systemctl is-active --quiet socat-mirror; then
             echo -e " ${C_DATO}[2] > REINICIAR SERVICIO CLON${C_RESET}"
        fi
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op

        case $op in
            1)
                if [[ "$ACT_CODE" == "2" ]]; then
                    # DETENER Y ELIMINAR
                    systemctl stop socat-mirror
                    systemctl disable socat-mirror 2>/dev/null
                    rm -f "$MIRROR_SVC"
                    systemctl daemon-reload
                    iptables -D INPUT -p tcp --dport $P_OPEN -j ACCEPT 2>/dev/null
                    fun_save_iptables >/dev/null 2>&1
                    echo -e "${C_ROJO} Servicio de Clonación Eliminado.${C_RESET}"
                    sleep 2
                else
                    # CREAR E INICIAR
                    if ! command -v socat &> /dev/null; then
                        echo -e " ${C_DATO}Instalando socat...${C_RESET}"
                        apt-get install socat -y > /dev/null 2>&1
                    fi

                    echo -e "\n ${C_DATO}--- CONFIGURACION ---${C_RESET}"
                    echo -n " Puerto ORIGINAL (El que da el 101) [Default 80]: "
                    read P_ORIG
                    [[ -z "$P_ORIG" ]] && P_ORIG=80
                    
                    echo -n " Puerto NUEVO (El que usará tu App) [Default 90]: "
                    read P_NEW
                    [[ -z "$P_NEW" ]] && P_NEW=90

                    # 1. Crear el archivo de servicio
                    cat <<EOF > "$MIRROR_SVC"
[Unit]
Description=Socat Port Mirror $P_NEW -> $P_ORIG
After=network.target

[Service]
Type=simple
# El puerto de entrada escucha y reenvía al puerto original (loopback 127.0.0.1)
ExecStart=/usr/bin/socat TCP-LISTEN:$P_NEW,fork,reuseaddr TCP:127.0.0.1:$P_ORIG
Restart=always
RestartSec=3
User=root

[Install]
WantedBy=multi-user.target
EOF

                    # 2. Abrir Firewall
                    iptables -I INPUT -p tcp --dport $P_NEW -j ACCEPT
                    fun_save_iptables >/dev/null 2>&1
                    
                    # 3. Iniciar Servicio
                    systemctl daemon-reload
                    systemctl enable socat-mirror >/dev/null 2>&1
                    systemctl restart socat-mirror
                    
                    echo -e "${C_VERDE} ¡CLON CREADO CON ÉXITO!${C_RESET}"
                    echo -e " El Puerto $P_NEW (TCP) ahora imita al Puerto $P_ORIG."
                    echo -e " RECUERDA: Abre el puerto $P_NEW en el Firewall Externo (Nube)."
                    sleep 3
                fi
                ;;
            2)
                if systemctl is-active --quiet socat-mirror; then
                    systemctl restart socat-mirror
                    echo -e "${C_VERDE} Servicio Reiniciado.${C_RESET}"
                    sleep 1
                fi
                ;;
            0) break ;;
        esac
    done
}

# --- NUEVA FUNCIÓN DE VERIFICACIÓN UNIVERSAL ---
is_installed() {
    local pkg=$1
    if command -v dpkg &> /dev/null; then
        dpkg -s "$pkg" &> /dev/null
    elif command -v rpm &> /dev/null; then
        rpm -q "$pkg" &> /dev/null
    else
        command -v "$pkg" &> /dev/null
    fi
}

# --- INSTALADOR VLESS REALITY (REPARADO POR REAGENS PRO) ---
install_xray_reality() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} INSTALADOR VLESS REALITY (SIN DOMINIO) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"

    # 1. Verificar si Xray está instalado
    if [[ ! -f "/usr/local/bin/xray" ]]; then
        echo -e " ${C_DATO}[+] Instalando Xray Core...${C_RESET}"
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install --force > /dev/null 2>&1
    fi

    # 2. Datos de Configuración
    echo -n " Puerto para Reality [Default 443]: "
    read R_PORT
    [[ -z "$R_PORT" ]] && R_PORT=443
    fun_check_port $R_PORT "VLESS Reality" || return

    echo -n " SNI de Destino [Default www.microsoft.com]: "
    read R_SNI
    [[ -z "$R_SNI" ]] && R_SNI="www.microsoft.com"

    # 3. Generación de Seguridad
    echo -e " ${C_DATO}[+] Generando llaves de cifrado X25519...${C_RESET}"
    KEYS=$(/usr/local/bin/xray x25519)
    PRIV=$(echo "$KEYS" | grep "Private" | awk '{print $3}')
    PUB=$(echo "$KEYS" | grep "Public" | awk '{print $3}')
    SID=$(openssl rand -hex 4)
    UUID_R=$(uuidgen)

    # Guardar llave pública para el Panel Web
    mkdir -p /etc/reagens
    echo "$PUB" > /etc/reagens/reality_pub

    # 4. Construcción del JSON
    cat <<EOF > /usr/local/etc/xray/config.json
{
  "log": { "loglevel": "warning" },
  "inbounds": [
    {
      "port": $R_PORT,
      "protocol": "vless",
      "settings": {
        "clients": [
          {
            "id": "$UUID_R",
            "flow": "xtls-rprx-vision",
            "email": "admin"
          }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "$R_SNI:443",
          "xver": 0,
          "serverNames": ["$R_SNI"],
          "privateKey": "$PRIV",
          "shortIds": ["$SID"]
        }
      }
    }
  ],
  "outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "blackhole", "tag": "blocked" }
  ]
}
EOF

    # 5. Reinicio y Firewall
    fuser -k $R_PORT/tcp >/dev/null 2>&1
    iptables -I INPUT -p tcp --dport $R_PORT -j ACCEPT
    fun_save_iptables >/dev/null 2>&1
    
    systemctl restart xray
    systemctl enable xray >/dev/null 2>&1

    # 6. Registro para el Panel
    mkdir -p /etc/reagens/users/v2ray
    echo "EXP=$(date -d '+30 days' +%Y-%m-%d)" > "/etc/reagens/users/v2ray/admin"
    echo "UUID=$UUID_R" >> "/etc/reagens/users/v2ray/admin"

    # 7. Mostrar Resultados
    IP=$(curl -s ipv4.icanhazip.com)
    LINK_R="vless://$UUID_R@$IP:$R_PORT?security=reality&encryption=none&pbk=$PUB&headerType=none&fp=chrome&type=tcp&sni=$R_SNI&sid=$SID&flow=xtls-rprx-vision#REAGENS-REALITY"

    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e "${C_VERDE} ¡REALITY INSTALADO CORRECTAMENTE!${C_RESET}"
    echo -e " ${C_TEXTO}Puerto: ${C_DATO}$R_PORT${C_RESET}"
    echo -e " ${C_TEXTO}Public Key: ${C_DATO}$PUB${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " ${C_VERDE}LINK DE CONEXION:${C_RESET}"
    echo -e "$LINK_R"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    read -p " Presione Enter para volver..."
}

menu_ajustes_puertos() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} AJUSTES DE PUERTOS Y PROTOCOLOS ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # --- CHEQUEOS DE ESTADO UNIVERSALES ---
        s_py=$(systemctl is-active --quiet ws-reagens && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        s_epro=$(systemctl is-active --quiet ws-epro && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        
        # Chequeo SSL (Stunnel)
        if is_installed stunnel4 || is_installed stunnel; then s_ssl="${C_VERDE}ON${C_RESET}"; else s_ssl="${C_ROJO}OFF${C_RESET}"; fi
        
        s_bad=$(systemctl is-active --quiet badvpn && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        s_v2=$(systemctl is-active --quiet xray && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        
        # Chequeo Dropbear
        if is_installed dropbear; then s_db="${C_VERDE}ON${C_RESET}"; else s_db="${C_ROJO}OFF${C_RESET}"; fi
        
        s_dns=$(systemctl is-active --quiet slowdns-server && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        
        # FIX CRÍTICO: El botón UDP ahora chequea el servicio 'reagens-udp'
        s_udp=$(systemctl is-active --quiet reagens-udp && echo -e "${C_VERDE}ON${C_RESET}" || echo -e "${C_ROJO}OFF${C_RESET}")
        
        # --- DISEÑO DEL MENÚ ---
        echo -e " ${C_TEXTO}[1] > PYTHON SOCKET (Simple 80->22) [$s_py]${C_RESET}"
        echo -e " ${C_DATO}[2] > WS-EPRO (Avanzado Multi-Port) [$s_epro]${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[3] > SSL / STUNNEL4                 [$s_ssl]${C_RESET}"
        echo -e " ${C_TEXTO}[4] > BADVPN UDP GATEWAY             [$s_bad]${C_RESET}"
        echo -e " ${C_TEXTO}[5] > DROPBEAR SSH                    [$s_db]${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[6] > INSTALADOR XRAY / V2RAY        [$s_v2]${C_RESET}"
        echo -e " ${C_DATO}[7] > FORCE EMERGENCIA (Smart Recovery)${C_RESET}"
        echo -e " ${C_VERDE}[8] > SLOWDNS (DNS TUNNEL)            [$s_dns]${C_RESET}"
        echo -e " ${C_VERDE}[9] > UDP CUSTOM (UDP TUNNEL)         [$s_udp]${C_RESET}"
        echo -e " ${C_DATO}[10]> VLESS REALITY (UNIVERSAL)      [$s_v2]${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU ANTERIOR${C_RESET}"
        
        # Leemos 2 caracteres para que la opción "10" funcione correctamente
        read -n 2 op_proto
        
        case $op_proto in 
            1) fun_python_sock ;; 
            2) fun_ws_epro_menu ;; 
            3) fun_ssl_menu ;; 
            4) fun_badvpn_menu ;; 
            5) fun_dropbear_menu ;; 
            6) proto_v2ray_manager ;; 
            7) fun_force_smart ;;
            8) fun_slowdns_menu ;;
            9) fun_udp_custom_menu ;;
            10) install_xray_reality ;;
            0) break ;;
        esac
    done
}

fun_limpiar_ram_exec() { 
    sync
    echo 3 > /proc/sys/vm/drop_caches
    echo -e "${C_VERDE} Memoria RAM Liberada.${C_RESET}"
    sleep 1
}

# --- NUEVA FUNCION ZRAM (COMPRESION DE MEMORIA) ---
fun_activar_zram() {
    clear
    msg_center " OPTIMIZADOR DE MEMORIA (ZRAM UNIFICADO) "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    
    if [[ -f /etc/redhat-release ]]; then
        echo -e " ${C_DATO}Configurando ZRAM para RHEL/CentOS/Alma...${C_RESET}"
        yum install -y zram-generator >/dev/null 2>&1
        cat <<EOF > /etc/systemd/zram-generator.conf
[zram0]
zram-size = ram / 2
compression-algorithm = lz4
EOF
        systemctl daemon-reload
        systemctl start /dev/zram0
    else
        echo -e " ${C_DATO}Configurando ZRAM para Debian/Ubuntu...${C_RESET}"
        apt-get install zram-tools -y >/dev/null 2>&1
        echo -e "ALGO=lz4\nPERCENT=50" > /etc/default/zramswap
        service zramswap reload || systemctl restart zramswap
    fi
    echo -e "${C_VERDE} ZRAM ACTIVADO (50% de tu RAM comprimida).${C_RESET}"
    sleep 3
}

fun_auto_ram_config() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LIMPIEZA AUTOMATICA DE RAM (CRON) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] Cada 1 Hora"
    echo -e " [2] Cada 6 Horas"
    echo -e " [3] Cada 12 Horas"
    echo -e " [4] Todos los dias a las 00:00"
    echo -e " [5] Desactivar limpieza automática"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read tr
    
    # Definir comando de limpieza
    CMD_CLEAN="sync; echo 3 > /proc/sys/vm/drop_caches"
    
    # Eliminar tareas previas de limpieza
    (crontab -l 2>/dev/null | grep -v "drop_caches") | crontab -
    
    case $tr in
        1)
            (crontab -l 2>/dev/null; echo "0 * * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Cada 1 Hora.${C_RESET}"
            ;;
        2)
            (crontab -l 2>/dev/null; echo "0 */6 * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Cada 6 Horas.${C_RESET}"
            ;;
        3)
            (crontab -l 2>/dev/null; echo "0 */12 * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Cada 12 Horas.${C_RESET}"
            ;;
        4)
            (crontab -l 2>/dev/null; echo "0 0 * * * $CMD_CLEAN") | crontab -
            echo -e "${C_VERDE} Activado: Diario a las 00:00.${C_RESET}"
            ;;
        5)
            echo -e "${C_ROJO} Limpieza automática desactivada.${C_RESET}"
            ;;
        *) echo "Invalido" ;;
    esac
    sleep 2
}

# --- MENU GESTION RAM ACTUALIZADO ---
menu_gestion_ram() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION DE MEMORIA RAM ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1] > LIMPIAR RAM AHORA (MANUAL)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > CONFIGURAR LIMPIEZA AUTOMATICA${C_RESET}"
        echo -e " ${C_DATO}[3] > INSTALAR ZRAM (MEMORIA COMPRIMIDA)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU ANTERIOR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op_r
        case $op_r in
            1) fun_limpiar_ram_exec ;;
            2) fun_auto_ram_config ;;
            3) fun_activar_zram ;;
            0) break ;;
        esac
    done
}

fun_acelerador() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} ACELERADOR DE RED (BBR + SYSCTL) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Aplicando configuraciones de optimización TCP..."
    cp /etc/sysctl.conf /etc/sysctl.conf.bak
    sed -i '/net.core.default_qdisc/d' /etc/sysctl.conf
    sed -i '/net.ipv4.tcp_congestion_control/d' /etc/sysctl.conf
    echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf
    echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf
    sysctl -p > /dev/null 2>&1
    echo -e "${C_VERDE} ¡Sistema Optimizado Exitosamente!${C_RESET}"
    sleep 2
}

fun_activar_root() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} ACTIVAR ACCESO ROOT Y CAMBIAR CLAVE ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Esto habilitará el acceso directo por SSH al usuario 'root'"
    echo -e " y te pedirá una nueva contraseña."
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Ingrese NUEVA CONTRASEÑA para ROOT: "
    read pass
    if [[ -z "$pass" ]]; then 
        echo -e "${C_ROJO} Contraseña vacia. Cancelado.${C_RESET}"
        sleep 2
        return
    fi
    
    echo "root:$pass" | chpasswd
    sed -i 's/#PermitRootLogin/PermitRootLogin/g' /etc/ssh/sshd_config
    sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/g' /etc/ssh/sshd_config
    sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/g' /etc/ssh/sshd_config
    sed -i 's/PermitRootLogin no/PermitRootLogin yes/g' /etc/ssh/sshd_config
    sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_config
    
    service ssh restart > /dev/null 2>&1
    service sshd restart > /dev/null 2>&1
    
    echo -e "${C_VERDE} ¡Acceso Root Activado y Clave Cambiada!${C_RESET}"
    sleep 2
}

menu_guardian() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MONITOR DE SEGURIDAD (GUARDIAN) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        if systemctl is-active --quiet reagens-guard; then G_ST="${C_VERDE}ACTIVO${C_RESET}"; else G_ST="${C_ROJO}DETENIDO${C_RESET}"; fi
        echo -e " ESTADO ACTUAL: $G_ST"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > ACTIVAR / REINICIAR GUARDIAN${C_RESET}"
        echo -e " ${C_TEXTO}[2] > DETENER Y DESACTIVAR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op_g
        case $op_g in
            1)
                echo "Instalando servicio..."
cat << 'EOF' > "$GUARD_BIN"
#!/bin/bash
DB="/etc/reagens/users"; V2="/usr/local/etc/xray/config.json"
while true; do
    # CHECK SSH
    for u in $(awk -F: '$3>=1000 {print $1}' /etc/passwd | grep -vE "ubuntu|admin|nobody"); do
        er=$(LC_ALL=C chage -l "$u" | grep Exp | cut -d: -f2)
        if [[ "$er" != *"never"* && ! -z "$er" ]]; then 
            exp_date_num=$(date -d "$er" +%Y%m%d); today_date_num=$(date +%Y%m%d)
            if [[ "$today_date_num" -gt "$exp_date_num" ]]; then passwd -l "$u"; pkill -u "$u"; fi
        fi
        if [[ -f "$DB/$u" ]]; then source "$DB/$u"; 
            if [[ "$LIMIT_CONN" -gt 0 ]]; then
                c=$(ps -u "$u" | grep -E 'sshd|dropbear' | grep -v grep | wc -l)
                if [[ "$c" -gt "$LIMIT_CONN" ]]; then 
                    kill -9 $(ps -u "$u" --sort=-start_time | grep -E 'sshd|dropbear' | head -n $((c-LIMIT_CONN)) | awk '{print $1}')
                fi
            fi
        fi
    done
    # CHECK XRAY
    if [[ -d "$DB/v2ray" ]]; then
        today_date_num=$(date +%Y%m%d)
        for f in "$DB/v2ray"/*; do 
            if [[ -f "$f" ]]; then 
                u=$(basename "$f"); source "$f"
                if [[ ! -z "$EXP" ]]; then 
                    exp_date_num=$(date -d "$EXP" +%Y%m%d)
                    if [[ "$today_date_num" -gt "$exp_date_num" ]]; then 
                        jq --arg e "$u" 'del(.inbounds[0].settings.clients[]|select(.email==$e))' "$V2" > "$V2.t"; mv "$V2.t" "$V2"; rm "$f"; systemctl restart xray
                        continue
                    fi
                fi
            fi
        done
    fi
    sleep 30
done
EOF
                chmod +x "$GUARD_BIN"
cat <<EOF > /etc/systemd/system/reagens-guard.service
[Unit]
Description=Guard Reagens
After=network.target
[Service]
ExecStart=$GUARD_BIN
Restart=always
[Install]
WantedBy=multi-user.target
EOF
                systemctl daemon-reload
                systemctl enable reagens-guard
                systemctl restart reagens-guard
                echo -e "${C_VERDE}Activado.${C_RESET}"
                sleep 2
                ;;
            2)
                systemctl stop reagens-guard
                systemctl disable reagens-guard
                rm -f /etc/systemd/system/reagens-guard.service
                systemctl daemon-reload
                echo -e "${C_ROJO}Desactivado.${C_RESET}"
                sleep 2
                ;;
            0) break ;;
        esac
    done
}

# --- MENU CHECKUSER UNIVERSAL TODOTERRENO (CON PERSISTENCIA) ---
menu_checkuser() {
    while true; do
        clear
        if [[ -f "$CHECKUSER_SERVICE" ]]; then
            CURR_PORT=$(grep -iE "PORT\s*=\s*[0-9]+" "$CHECKUSER_BIN" | grep -oE "[0-9]+" | head -n1)
            IP=$(curl -s ipv4.icanhazip.com)
            
            echo -e "${C_BARRA}=====================================================${C_RESET}"
            msg_center "${C_TITULO} CHECKUSER UNIVERSAL TODOTERRENO ${C_RESET}"
            echo -e "${C_BARRA}=====================================================${C_RESET}"
            echo -e " ESTADO: ${C_VERDE}ONLINE (MODO MULTI-TAG)${C_RESET}"
            echo -e " PUERTO: ${C_DATO}${CURR_PORT:-5432}${C_RESET}"
            echo -e " URL APP: ${C_TEXTO}http://${IP}:${CURR_PORT:-5432}/${C_RESET}"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " Este sistema es compatible con:"
            echo -e " HTTP Custom, NetMod, ePro, SSH Plus, DTunnel y más."
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
            echo -e " ${C_TEXTO}[1] > DESINSTALAR${C_RESET}"
            echo -e " ${C_TEXTO}[2] > REINICIAR SERVICIO${C_RESET}"
            echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
            echo -n " Opcion: "
            read op
            case $op in
                1) systemctl stop checkuser-reagens; rm -f "$CHECKUSER_SERVICE" "$CHECKUSER_BIN"; echo "Eliminado."; sleep 2 ;;
                2) systemctl restart checkuser-reagens; echo "Reiniciado."; sleep 2 ;;
                0) break ;;
            esac
        else
            echo -e "${C_BARRA}=====================================================${C_RESET}"
            msg_center "${C_TITULO} INSTALADOR CHECKUSER MULTI-APP ${C_RESET}"
            echo -e "${C_BARRA}=====================================================${C_RESET}"
            echo -n " Puerto para el CheckUser [Default 5432]: "
            read p
            [[ -z "$p" ]] && p=5432

            fuser -k $p/tcp >/dev/null 2>&1
            mkdir -p /etc/reagens/bin

cat <<EOF > "$CHECKUSER_BIN"
import os, subprocess, sys, json
from datetime import datetime
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse, parse_qs

PORT = $p
DB_SSH = "/etc/adm-lite/usuarios_ssh.db"
DB_TOKENS = "/etc/adm-lite/usuarios_token.db"

class MyHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        query = parse_qs(urlparse(self.path).query)
        user = query.get('user', query.get('username', ['']))[0]
        response_data = {"status": "error", "message": "user_not_found"}
        if user:
            valid_user = False
            limit_conn = "1"
            exp_date_db = ""
            for db_path in [DB_SSH, DB_TOKENS]:
                if os.path.exists(db_path):
                    with open(db_path, 'r', errors='ignore') as f:
                        for line in f:
                            p_list = line.strip().split('|')
                            if p_list[0] == user:
                                valid_user = True
                                exp_date_db = p_list[2]
                                limit_conn = p_list[3] if len(p_list) > 4 else "1"
                                break
            if valid_user:
                try:
                    today = datetime.now()
                    exp_dt = datetime.strptime(exp_date_db, "%Y-%m-%d")
                    days_left = (exp_dt - today).days + 1
                    if days_left < 0: days_left = 0
                    count = subprocess.check_output(f"ps -u {user} | grep -E 'sshd|dropbear' | grep -v grep | wc -l", shell=True).decode('utf-8').strip()
                    response_data = {
                        "username": user,
                        "count_connection": count,
                        "limit_connection": limit_conn,
                        "expiration_date": exp_dt.strftime("%d/%m/%Y"),
                        "expiration_days": str(days_left),
                        "days": str(days_left),
                        "days_left": str(days_left),
                        "valid": True,
                        "status": "active",
                        "is_active": True,
                        "count": count,
                        "limit": limit_conn,
                        "expiration": exp_dt.strftime("%d/%m/%Y")
                    }
                except: pass
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(response_data).encode('utf-8'))
if __name__ == '__main__':
    try:
        httpd = HTTPServer(('0.0.0.0', PORT), MyHandler)
        httpd.serve_forever()
    except: sys.exit(1)
EOF

cat <<EOF > "$CHECKUSER_SERVICE"
[Unit]
Description=CheckUser Universal Todoterreno
After=network.target
[Service]
ExecStart=/usr/bin/python3 $CHECKUSER_BIN
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
EOF
            systemctl daemon-reload
            systemctl enable checkuser-reagens >/dev/null 2>&1
            systemctl restart checkuser-reagens
            iptables -I INPUT -p tcp --dport $p -j ACCEPT
            fun_save_iptables
            echo -e "${C_VERDE} CheckUser Universal instalado correctamente.${C_RESET}"
            sleep 2
        fi
    done
}

submenu_fecha_hora() {
    while true; do 
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CONFIGURAR ZONA HORARIA MUNDIAL ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_DATO}Escriba parte del nombre de su Continente o Ciudad.${C_RESET}"
        echo -e " ${C_TEXTO}Ejemplos: America, Madrid, Mexico, Tokyo, Paris${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > BUSCAR Y SELECCIONAR${C_RESET}"
        echo -e " ${C_TEXTO}[2] > MOSTRAR TODAS LAS ZONAS (Larga lista)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1)
                echo -n " Busqueda (Ej: America): "
                read query
                if [[ -z "$query" ]]; then continue; fi
                
                # Crear array con resultados
                mapfile -t zonas < <(timedatectl list-timezones | grep -i "$query")
                
                if [[ ${#zonas[@]} -eq 0 ]]; then
                    echo -e "${C_ROJO}No se encontraron resultados.${C_RESET}"
                    sleep 2
                else
                    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
                    i=1
                    for z in "${zonas[@]}"; do
                        echo -e " [$i] $z"
                        ((i++))
                    done
                    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
                    echo -n " Seleccione Numero: "
                    read num
                    if [[ "$num" -gt 0 && "$num" -le "${#zonas[@]}" ]]; then
                        sel_zone="${zonas[$((num-1))]}"
                        timedatectl set-timezone "$sel_zone"
                        echo -e "${C_VERDE}Zona cambiada a: $sel_zone${C_RESET}"
                        echo -e "Hora actual: $(date)"
                        sleep 3
                        break
                    else
                        echo -e "${C_ROJO}Numero invalido.${C_RESET}"
                        sleep 1
                    fi
                fi
                ;;
            2)
                timedatectl list-timezones | less
                ;;
            0) break ;;
        esac
    done
}

# ==================================================
# GESTOR SSL REPARADO (REEMPLAZA TU FUNCIÓN ANTIGUA)
# ==================================================
# ==================================================
# GESTOR SSL MULTIVERSAL (UBUNTU/DEBIAN/CENTOS/ALMA/ROCKY)
# ==================================================
# ==================================================
# GESTOR SSL MULTIVERSAL - VERSIÓN ULTRA-COMPATIBLE
# ==================================================
fun_cert_manager() {
    clear
    CERT_DIR="/etc/reagens/cert"
    mkdir -p "$CERT_DIR"

    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTOR SSL PRO (ACME.SH + FIREWALL FIX) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if [[ -f "$CERT_DIR/public.crt" ]]; then
            echo -e " ${C_VERDE}[CERTIFICADO ACTIVO]${C_RESET}"
            echo -e " Dominio: $(openssl x509 -noout -subject -in $CERT_DIR/public.crt 2>/dev/null | sed 's/.*CN = //')"
            echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        fi
        
        echo -e " ${C_TEXTO}[1] > GENERAR CERTIFICADO (AUTO-FIX FIREWALL)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > VER CONTENIDO DE LLAVES${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op_ssl

        case $op_ssl in
            1)
                clear
                echo -e " ${C_DATO}[+] Preparando entorno de validación...${C_RESET}"
                
                # 1. INSTALAR DEPENDENCIAS Y ACTIVAR CRON
                if [[ -f /etc/redhat-release ]]; then
                    yum install socat tar gzip cronie psmisc -y &>/dev/null
                    systemctl enable cronie &>/dev/null
                    systemctl start cronie &>/dev/null
                    # DESACTIVAR SELINUX TEMPORALMENTE (Solo en RHEL/Alma)
                    setenforce 0 &>/dev/null
                else
                    apt-get update &>/dev/null
                    apt-get install socat tar gzip cron psmisc -y &>/dev/null
                    systemctl start cron &>/dev/null
                fi

                # 2. ABRIR PUERTO 80 EN EL FIREWALL DEL SISTEMA (ESENCIAL PARA ALMA/CENTOS)
                if command -v firewall-cmd &>/dev/null; then
                    firewall-cmd --add-port=80/tcp --permanent &>/dev/null
                    firewall-cmd --add-port=443/tcp --permanent &>/dev/null
                    firewall-cmd --reload &>/dev/null
                fi
                if command -v ufw &>/dev/null; then
                    ufw allow 80/tcp &>/dev/null
                    ufw allow 443/tcp &>/dev/null
                fi

                echo -n " Ingrese su Dominio: "
                read DOMINIO
                [[ -z "$DOMINIO" ]] && continue

                # 3. LIMPIEZA AGRESIVA DEL PUERTO 80
                echo -e " ${C_DATO}[!] Forzando liberación del puerto 80...${C_RESET}"
                systemctl stop xray v2ray nginx apache2 httpd rvp-panel stunnel4 &>/dev/null
                fuser -k 80/tcp &>/dev/null
                fuser -k 80/tcp &>/dev/null # Doble limpieza
                sleep 2

                # 4. MOTOR ACME
                ACME_BIN="$HOME/.acme.sh/acme.sh"
                if [[ ! -f "$ACME_BIN" ]]; then
                    curl https://get.acme.sh | sh -s email=admin@$DOMINIO &>/dev/null
                fi
                
                # 5. VALIDACIÓN (FORZANDO IPV4 PARA EVITAR ERRORES DE RED)
                echo -e " ${C_VERDE}[+] Solicitando a Let's Encrypt...${C_RESET}"
                "$ACME_BIN" --set-default-ca --server letsencrypt &>/dev/null
                # Añadimos --listen-v4 para evitar problemas con IPv6 mal configurados
                "$ACME_BIN" --issue -d "$DOMINIO" --standalone --keylength ec-256 --force --listen-v4

                # REINTENTO CON ZEROSSL SI FALLA
                if [[ ! -f "$HOME/.acme.sh/${DOMINIO}_ecc/${DOMINIO}.cer" ]]; then
                    echo -e "${C_DATO}[!] Reintentando con ZeroSSL...${C_RESET}"
                    "$ACME_BIN" --register-account -m admin@$DOMINIO --server zerossl &>/dev/null
                    "$ACME_BIN" --issue -d "$DOMINIO" --standalone --server zerossl --keylength ec-256 --force --listen-v4
                fi

                # 6. INSTALACIÓN FINAL
                if [[ -f "$HOME/.acme.sh/${DOMINIO}_ecc/${DOMINIO}.cer" ]]; then
                    mkdir -p "$CERT_DIR"
                    "$ACME_BIN" --installcert -d "$DOMINIO" --ecc \
                        --fullchain-file "$CERT_DIR/public.crt" \
                        --key-file "$CERT_DIR/private.key" &>/dev/null
                    chmod 644 "$CERT_DIR"/*
                    echo -e "${C_VERDE} ¡CERTIFICADO GENERADO EXITOSAMENTE!${C_RESET}"
                else
                    echo -e "${C_ROJO} [X] ERROR CRITICO: La validación falló.${C_RESET}"
                    echo -e " ${C_DATO}CAUSA PROBABLE:${C_RESET} Si usas Google Cloud, AWS, Azure u Oracle,"
                    echo -e " debes abrir el PUERTO 80 en el panel de tu proveedor (Security Groups)."
                fi
                
                # Restaurar SELinux y reiniciar Xray
                [[ -f /etc/redhat-release ]] && setenforce 1 &>/dev/null
                systemctl start xray &>/dev/null
                read -p " Enter para continuar..."
                ;;
            2)
                # (Mantener igual que antes para ver las llaves)
                if [[ -f "$CERT_DIR/public.crt" ]]; then
                    clear
                    echo -e "--- CRT PUBLICO ---"
                    cat "$CERT_DIR/public.crt"
                    echo -e "\n--- KEY PRIVADA ---"
                    cat "$CERT_DIR/private.key"
                    read -p "Enter..."
                fi
                ;;
            0) break ;;
        esac
    done
}

# ==================================================
# MODULO ADBLOCK (DNSMASQ) - LIMPIEZA PUBLICIDAD
# ==================================================

fun_adblock_manager() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} ADBLOCK PRO (DNSMASQ) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # Verificar estado
        if pgrep "dnsmasq" > /dev/null; then
            STATUS_ADB="${C_VERDE}ACTIVO (Protegiendo)${C_RESET}"
            # Contar dominios bloqueados
            if [[ -f "/etc/reagens/adblock.hosts" ]]; then
                CNT=$(wc -l < /etc/reagens/adblock.hosts)
                INFO_L="Dominios en Blacklist: ${C_DATO}$CNT${C_RESET}"
            else
                INFO_L="Lista vacía."
            fi
        else
            STATUS_ADB="${C_ROJO}DETENIDO / NO INSTALADO${C_RESET}"
            INFO_L=""
        fi

        echo -e " ESTADO: $STATUS_ADB"
        echo -e " $INFO_L"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[1] > INSTALAR Y ACTIVAR ADBLOCK${C_RESET}"
        echo -e " ${C_DATO}[2] > ACTUALIZAR LISTA DE BLOQUEO (Anti-Ads)${C_RESET}"
        echo -e " ${C_DATO}[3] > DESACTIVAR Y ELIMINAR${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op

        case $op in
            1)
                echo -e " ${C_DATO}Instalando DNSMasq...${C_RESET}"
                apt-get update >/dev/null 2>&1
                apt-get install dnsmasq -y >/dev/null 2>&1

                echo -e " ${C_DATO}Descargando Lista Negra (100k+ dominios)...${C_RESET}"
                mkdir -p /etc/reagens
                # Usamos la lista de StevenBlack unificada (Ads + Malware)
                wget -q https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts -O /etc/reagens/adblock.hosts
                
                # Configurar DNSMasq
                echo -e " ${C_DATO}Configurando Rutas DNS...${C_RESET}"
                mv /etc/dnsmasq.conf /etc/dnsmasq.conf.bak 2>/dev/null
                
                cat <<EOF > /etc/dnsmasq.conf
port=5353
listen-address=127.0.0.1
bind-interfaces
server=8.8.8.8
server=1.1.1.1
domain-needed
bogus-priv
no-resolv
no-poll
cache-size=10000
addn-hosts=/etc/reagens/adblock.hosts
EOF
                # NOTA: Usamos puerto 5353 para evitar conflicto con SlowDNS/Systemd
                # Pero forzamos al sistema a usarlo mediante iptables o resolv personalizado
                
                # Modificar resolv.conf para que el VPS use nuestro DNS local
                # Primero hacemos backup
                cp /etc/resolv.conf /etc/resolv.conf.bak
                echo "nameserver 127.0.0.1" > /etc/resolv.conf
                
                # Reiniciar servicio
                service dnsmasq restart
                
                # --- TRUCO MAGICO: Redirigir consultas locales al 5353 ---
                # Esto evita choque con SlowDNS que usa el 53
                iptables -t nat -I OUTPUT -p udp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353
                iptables -t nat -I OUTPUT -p tcp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353
                fun_save_iptables >/dev/null 2>&1

                echo -e "${C_VERDE} ADBLOCK ACTIVADO.${C_RESET}"
                echo -e " La publicidad web será eliminada a nivel de servidor."
                sleep 3
                ;;
            2)
                if [[ -f "/etc/reagens/adblock.hosts" ]]; then
                    echo -e " ${C_DATO}Actualizando base de datos...${C_RESET}"
                    wget -q https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts -O /etc/reagens/adblock.hosts
                    service dnsmasq restart
                    echo -e "${C_VERDE} Lista actualizada.${C_RESET}"
                else
                    echo -e "${C_ROJO} Instale primero.${C_RESET}"
                fi
                sleep 2
                ;;
            3)
                echo -e " ${C_DATO}Restaurando DNS originales...${C_RESET}"
                # Restaurar resolv.conf a Google
                echo "nameserver 8.8.8.8" > /etc/resolv.conf
                
                # Limpiar iptables
                iptables -t nat -D OUTPUT -p udp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353 2>/dev/null
                iptables -t nat -D OUTPUT -p tcp --dport 53 -d 127.0.0.1 -j REDIRECT --to-ports 5353 2>/dev/null
                fun_save_iptables >/dev/null 2>&1

                apt-get purge dnsmasq -y >/dev/null 2>&1
                rm -f /etc/reagens/adblock.hosts
                
                echo -e "${C_ROJO} AdBlock Eliminado. Internet restaurado.${C_RESET}"
                sleep 2
                ;;
            0) break ;;
        esac
    done
}

menu_ajustes() { 
    while true; do 
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} AJUSTES DEL SISTEMA PRO ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        # CHEQUEOS VISUALES
        is_cu_sys=$(systemctl is-active --quiet checkuser-reagens.service && echo -e "${C_VERDE}[ON]${C_RESET}" || echo -e "${C_ROJO}[OFF]${C_RESET}")
        is_guard=$(systemctl is-active --quiet reagens-guard && echo -e "${C_VERDE}[ON]${C_RESET}" || echo -e "${C_ROJO}[OFF]${C_RESET}")
        
        echo -e " ${C_DATO}[1]  > AJUSTES DE PUERTOS (Protocolos)${C_RESET}"
        echo -e " ${C_VERDE}[2]  > OPTIMIZADOR GAMING (PING BAJO)${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[3]  > AJUSTES DE FECHA Y HORA (MUNDIAL)${C_RESET}"
        echo -e " ${C_TEXTO}[4]  > MENU CHECKUSER $is_cu_sys"
        echo -e " ${C_TEXTO}[5]  > MENU GUARDIAN (SEGURIDAD) $is_guard"
        echo -e " ${C_TEXTO}[6]  > ACELERADOR DE RED (BBR)${C_RESET}"
        echo -e " ${C_TEXTO}[7]  > ACTIVAR ACCESO ROOT / CAMBIAR CLAVE${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[8]  > SPEEDTEST OOKLA (VELOCIDAD)${C_RESET}"
        echo -e " ${C_DATO}[9]  > CENTRO DE SEGURIDAD PRO (ANTI-TORRENT)${C_RESET}"
        echo -e " ${C_DATO}[10] > ADBLOCK PRO (BLOQUEO ANUNCIOS)${C_RESET}"
        echo -e " ${C_VERDE}[11] > INSTALAR PANEL WEB (R-VP - PRO)${C_RESET}"
        echo -e " ${C_VERDE}[12] > GENERAR CERTIFICADO SSL (DOMINIO)${C_RESET}"
        echo -e " ${C_DATO}[13] > MANTENIMIENTO Y RESPALDO 1A${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU PRINCIPAL${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in 
            1) menu_ajustes_puertos ;;
            2) fun_gaming_pro ;;
            3) submenu_fecha_hora ;;
            4) menu_checkuser ;;
            5) menu_guardian ;;
            6) fun_acelerador ;;
            7) fun_activar_root ;;
            8) fun_speedtest ;;
            9) menu_seguridad_pro ;;
            10) fun_adblock_manager ;;
            11) fun_instalar_panel_web ;;
            12) fun_cert_manager ;;
            13) menu_mantenimiento ;;
            0) break ;;
        esac
    done 
}

# ==================================================
# MODULO DE SEGURIDAD PRO (NUEVO)
# ==================================================

# 1. ANTI-TORRENT
fun_seguridad_antitorrent() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} ANTI-TORRENT & P2P BLOCKER ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] ACTIVAR PROTECCION (Recomendado)"
    echo -e " [2] DESACTIVAR PROTECCION"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            # Limpiar primero
            iptables -D FORWARD -m string --algo bm --string "BitTorrent" -j DROP 2>/dev/null
            iptables -D OUTPUT -p tcp --dport 6881:6889 -j DROP 2>/dev/null
            
            # Aplicar reglas nuevas
            iptables -I FORWARD -m string --algo bm --string "BitTorrent" -j DROP
            iptables -I FORWARD -m string --algo bm --string "torrent" -j DROP
            iptables -I FORWARD -m string --algo bm --string "announce" -j DROP
            iptables -I FORWARD -m string --algo bm --string "info_hash" -j DROP
            iptables -I FORWARD -m string --algo bm --string "get_peers" -j DROP
            iptables -I FORWARD -m string --algo bm --string "find_node" -j DROP
            iptables -I FORWARD -m string --algo bm --string "peer_id=" -j DROP
            iptables -I OUTPUT -p tcp --dport 6881:6889 -j DROP
            iptables -I OUTPUT -p udp --dport 6881:6889 -j DROP
            
            fun_save_iptables >/dev/null 2>&1
            echo -e "${C_VERDE} PROTECCION ACTIVADA.${C_RESET}"; sleep 2 ;;
        2)
            iptables -D FORWARD -m string --algo bm --string "BitTorrent" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "torrent" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "announce" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "info_hash" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "get_peers" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "find_node" -j DROP 2>/dev/null
            iptables -D FORWARD -m string --algo bm --string "peer_id=" -j DROP 2>/dev/null
            iptables -D OUTPUT -p tcp --dport 6881:6889 -j DROP 2>/dev/null
            iptables -D OUTPUT -p udp --dport 6881:6889 -j DROP 2>/dev/null
            
            fun_save_iptables >/dev/null 2>&1
            echo -e "${C_ROJO} PROTECCION DESACTIVADA.${C_RESET}"; sleep 2 ;;
    esac
}

# 2. FAIL2BAN
fun_seguridad_fail2ban() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} PROTECCION FAIL2BAN (ANTI-HACK) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    if dpkg -s fail2ban >/dev/null 2>&1; then
        echo -e " ESTADO: ${C_VERDE}INSTALADO${C_RESET}"
        echo -e " [1] REINICIAR SERVICIO"
        echo -e " [2] DESINSTALAR"
    else
        echo -e " ESTADO: ${C_ROJO}NO INSTALADO${C_RESET}"
        echo -e " [1] INSTALAR Y CONFIGURAR"
    fi
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            if dpkg -s fail2ban >/dev/null 2>&1; then
                service fail2ban restart
                echo "Reiniciado."
            else
                apt-get install fail2ban -y >/dev/null 2>&1
                cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
                sed -i "/^\[sshd\]/a enabled = true" /etc/fail2ban/jail.local
                service fail2ban restart
                echo -e "${C_VERDE} INSTALADO.${C_RESET}"
            fi
            sleep 2 ;;
        2)
            apt-get remove fail2ban -y
            rm -rf /etc/fail2ban
            echo "Eliminado."; sleep 2 ;;
    esac
}

# 3. LIMITADOR
fun_seguridad_limiter() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} LIMITADOR DE VELOCIDAD GLOBAL ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    NIC=$(ip route get 8.8.8.8 | grep -oP 'dev \K\S+')
    echo -e " Interfaz: ${C_DATO}$NIC${C_RESET}"
    echo -e " [1] ESTABLECER LIMITE (Mbps)"
    echo -e " [2] QUITAR LIMITES"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            if ! command -v wondershaper >/dev/null; then apt-get install wondershaper -y >/dev/null 2>&1; fi
            echo -n " Limite BAJADA (Mbps): "; read down
            echo -n " Limite SUBIDA (Mbps): "; read up
            wondershaper clear $NIC >/dev/null 2>&1
            wondershaper $NIC $(($down * 1024)) $(($up * 1024))
            echo "Limites aplicados."; sleep 2 ;;
        2)
            if command -v wondershaper >/dev/null; then wondershaper clear $NIC; echo "Limites borrados."; fi
            sleep 2 ;;
    esac
}

# 4. BLINDAJE
fun_seguridad_blindaje() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} BLINDAJE DE ARCHIVOS ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " Bloquea acceso a carpetas sensibles para usuarios no-root."
    echo -n " ¿Aplicar? (s/n): "
    read conf
    if [[ "$conf" == "s" ]]; then
        chmod 700 /etc/reagens /etc/reagens/users /etc/reagens/bot /etc/hysteria /etc/slowdns /etc/udp-custom
        chmod 600 /etc/reagens/bot/reagens_bot.py /etc/hysteria/config.yaml /usr/local/etc/xray/config.json
        echo -e "${C_VERDE} ¡Sistema Blindado!${C_RESET}"; sleep 2
    fi
}

menu_seguridad_pro() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CENTRO DE SEGURIDAD PRO ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_DATO}[1] > ANTI-TORRENT (Evitar Ban VPS)${C_RESET}"
        echo -e " ${C_DATO}[2] > FAIL2BAN (Anti Fuerza Bruta)${C_RESET}"
        echo -e " ${C_DATO}[3] > LIMITADOR VELOCIDAD (Global)${C_RESET}"
        echo -e " ${C_DATO}[4] > BLINDAJE ARCHIVOS (Anti Robo)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1) fun_seguridad_antitorrent ;;
            2) fun_seguridad_fail2ban ;;
            3) fun_seguridad_limiter ;;
            4) fun_seguridad_blindaje ;;
            0) break ;;
        esac
    done
}

# ==================================================
# MODULOS DE MANTENIMIENTO 1A (BACKUP - SWAP - LOGS)
# ==================================================

# 1. BACKUP & RESTORE
fun_backup_restore() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} COPIAS DE SEGURIDAD (BACKUP) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_DATO}[1] > CREAR COPIA DE SEGURIDAD (Backup)${C_RESET}"
    echo -e " ${C_DATO}[2] > RESTAURAR COPIA DE SEGURIDAD${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            echo -e " Generando archivo 'backup.tar.gz'..."
            DIR_BKP="/root/backup_reagens"
            mkdir -p $DIR_BKP
            
            # Copiar bases de datos y configs criticas
            cp -r /etc/reagens $DIR_BKP/
            cp -r /etc/hysteria $DIR_BKP/
            cp -r /etc/slowdns $DIR_BKP/
            cp /usr/local/etc/xray/config.json $DIR_BKP/xray_config.json 2>/dev/null
            cp /usr/local/etc/v2ray/config.json $DIR_BKP/v2ray_config.json 2>/dev/null
            cp /etc/shadow $DIR_BKP/shadow_bkp # Passwords de usuarios Linux
            cp /etc/passwd $DIR_BKP/passwd_bkp
            cp /etc/gshadow $DIR_BKP/gshadow_bkp
            cp /etc/group $DIR_BKP/group_bkp
            
            # Comprimir
            cd /root
            tar -czf backup_reagens.tar.gz backup_reagens
            rm -rf $DIR_BKP
            
            echo -e "${C_VERDE} BACKUP CREADO: /root/backup_reagens.tar.gz${C_RESET}"
            echo -e " Descarga ese archivo a tu PC. Para restaurar, subelo a /root en el nuevo VPS."
            sleep 3
            ;;
        2)
            if [[ ! -f "/root/backup_reagens.tar.gz" ]]; then
                echo -e "${C_ROJO} Error: No se encuentra /root/backup_reagens.tar.gz${C_RESET}"
                echo " Sube el archivo primero."
                sleep 2
                return
            fi
            
            echo " Restaurando..."
            tar -xzf /root/backup_reagens.tar.gz -C /root
            
            # Restaurar archivos
            cp -r /root/backup_reagens/reagens /etc/
            cp -r /root/backup_reagens/hysteria /etc/
            cp -r /root/backup_reagens/slowdns /etc/
            
            mkdir -p /usr/local/etc/xray
            cp /root/backup_reagens/xray_config.json /usr/local/etc/xray/config.json 2>/dev/null
            
            # Restaurar Usuarios del Sistema (CUIDADO)
            # Solo restauramos si el usuario confirma, es delicado.
            echo -n " ¿Restaurar usuarios SSH del sistema? (s/n): "
            read rusr
            if [[ "$rusr" == "s" ]]; then
                cp /root/backup_reagens/shadow_bkp /etc/shadow
                cp /root/backup_reagens/passwd_bkp /etc/passwd
                cp /root/backup_reagens/gshadow_bkp /etc/gshadow
                cp /root/backup_reagens/group_bkp /etc/group
            fi
            
            rm -rf /root/backup_reagens
            echo -e "${C_VERDE} RESTAURACION COMPLETADA. REINICIAR RECOMENDADO.${C_RESET}"
            sleep 3
            ;;
    esac
}

# 2. GESTOR SWAP (MEMORIA VIRTUAL)
fun_swap_manager() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} GESTOR MEMORIA SWAP (RAM VIRTUAL) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    # Detectar swap actual
    SWAP_ACT=$(free -h | grep Swap | awk '{print $2}')
    echo -e " SWAP ACTUAL: ${C_DATO}$SWAP_ACT${C_RESET}"
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -e " [1] CREAR SWAP 1GB (Recomendado 512MB RAM)"
    echo -e " [2] CREAR SWAP 2GB (Recomendado 1GB+ RAM)"
    echo -e " [3] ELIMINAR SWAP"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -n " Opcion: "
    read op
    case $op in
        1)
            swapoff -a
            dd if=/dev/zero of=/swapfile bs=1M count=1024
            mkswap /swapfile
            swapon /swapfile
            echo "/swapfile swap swap defaults 0 0" >> /etc/fstab
            echo -e "${C_VERDE} Swap 1GB Creada.${C_RESET}"; sleep 2 ;;
        2)
            swapoff -a
            dd if=/dev/zero of=/swapfile bs=1M count=2048
            mkswap /swapfile
            swapon /swapfile
            echo "/swapfile swap swap defaults 0 0" >> /etc/fstab
            echo -e "${C_VERDE} Swap 2GB Creada.${C_RESET}"; sleep 2 ;;
        3)
            swapoff -a
            sed -i '/swapfile/d' /etc/fstab
            rm -f /swapfile
            echo -e "${C_ROJO} Swap Eliminada.${C_RESET}"; sleep 2 ;;
    esac
}

# 3. VISOR DE LOGS
fun_log_viewer() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} VISOR DE LOGS (DEPURADOR) ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " [1] LOG XRAY / V2RAY"
    echo -e " [2] LOG HYSTERIA"
    echo -e " [3] LOG SLOWDNS"
    echo -e " [4] LOG SSH (AUTH)"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " CTRL + C para salir del log."
    echo -n " Opcion: "
    read op
    echo -e "${C_DATO} MOSTRANDO ULTIMAS 50 LINEAS... (CTRL+C SALIR)${C_RESET}"
    echo ""
    case $op in
        1) journalctl -u xray -n 50 -f ;;
        2) journalctl -u hysteria-server -n 50 -f ;;
        3) journalctl -u slowdns-server -n 50 -f ;;
        4) tail -f /var/log/auth.log ;;
    esac
}

# --- DESINSTALACION COMPLETA Y BORRADO DE HUELLAS (VERSION FINAL) ---
fun_deep_clean() {
    clear
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    msg_center "${C_TITULO} PROTOCOLO DE BORRADO ABSOLUTO ${C_RESET}"
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_ROJO}[!] ADVERTENCIA:${C_RESET} Se eliminarán todos los usuarios,"
    echo -e " servicios, puertos, bases de datos y comandos."
    echo -e " La VPS volverá a su estado original de fábrica."
    echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
    echo -n " Escribe 'BORRAR-SISTEMA' para confirmar: "
    read confirm
    if [[ "$confirm" == "BORRAR-SISTEMA" ]]; then
        echo -e "\n ${C_DATO}[1/5] Deteniendo todos los servicios...${C_RESET}"
        systemctl stop xray v2ray hysteria-server slowdns-server reagens-udp rvp-panel reagens-monitor reagens-guard reagens-bot checkuser-reagens ws-reagens ws-epro badvpn dropbear-custom stunnel4 >/dev/null 2>&1
        
        echo -e " ${C_DATO}[2/5] Eliminando usuarios reales del sistema...${C_RESET}"
        # Borrar usuarios de SSH y Tokens antes de borrar las DBs
        for db in "$DB_SSH" "$DB_TOKENS"; do
            if [[ -f "$db" ]]; then
                while IFS='|' read -r user rest; do
                    # Matamos procesos del usuario y lo eliminamos
                    pkill -u "$user" >/dev/null 2>&1
                    userdel --force "$user" >/dev/null 2>&1
                    rm -rf "/home/$user" >/dev/null 2>&1
                    # Limpiamos su rastro en la DB de tráfico
                    sed -i "/^$user|/d" "$DB_TRAFFIC"
                done < "$db"
            fi
        done

        echo -e " ${C_DATO}[3/5] Limpiando Firewall y Ajustes de Nucleo...${C_RESET}"
        [[ -f /etc/sysctl.conf.bak ]] && mv /etc/sysctl.conf.bak /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        iptables -F && iptables -X && iptables -t nat -F && iptables -t nat -X
        iptables -P INPUT ACCEPT && iptables -P FORWARD ACCEPT && iptables -P OUTPUT ACCEPT
        fun_save_iptables

        echo -e " ${C_DATO}[4/5] Eliminando archivos, binarios y servicios...${C_RESET}"
        rm -rf /etc/reagens /etc/adm-lite /etc/hysteria /etc/slowdns /etc/udp-custom /usr/local/etc/xray /etc/stunnel
        rm -f /etc/systemd/system/xray.service /etc/systemd/system/hysteria-server.service /etc/systemd/system/slowdns-server.service /etc/systemd/system/reagens-*.service /etc/systemd/system/checkuser-reagens.service /etc/systemd/system/ws-*.service /etc/systemd/system/badvpn.service /etc/systemd/system/rvp-panel.service
        rm -f /usr/local/bin/reagens-* /usr/bin/badvpn-udpgw /usr/bin/r-vp /usr/bin/menu /usr/local/bin/xray
        systemctl daemon-reload

        echo -e " ${C_DATO}[5/5] Borrando comandos y banner de inicio...${C_RESET}"
        rm -f /usr/bin/menu >/dev/null 2>&1
        sed -i '/reagens/d' /root/.bashrc >/dev/null 2>&1
        sed -i '/menu/d' /root/.bashrc >/dev/null 2>&1
        echo "" > /etc/issue.net
        echo "" > /etc/motd
        crontab -r >/dev/null 2>&1

        echo -e "\n${C_VERDE} [OK] SISTEMA ELIMINADO AL 100%. NINGÚN RASTRO QUEDÓ.${C_RESET}"
        sleep 3
        exit 0
    else
        echo -e "${C_ROJO} Cancelado.${C_RESET}"
        sleep 2
    fi
}

# --- FUNCION DE LIMPIEZA (Pégala aquí, justo antes del menú) ---
fun_limpiar_logs() {
    clear
    msg_center " LIMPIEZA DE SISTEMA "
    echo -e "${C_BARRA}=====================================================${C_RESET}"
    echo -e " ${C_DATO}Vaciando logs del sistema para liberar espacio...${C_RESET}"
    
    # Vaciar logs sin borrar archivos (Mantiene permisos)
    truncate -s 0 /var/log/syslog 2>/dev/null
    truncate -s 0 /var/log/auth.log 2>/dev/null
    truncate -s 0 /var/log/kern.log 2>/dev/null
    truncate -s 0 /var/log/dpkg.log 2>/dev/null
    
    # Logs de Xray (si existen)
    truncate -s 0 /var/log/xray/access.log 2>/dev/null
    truncate -s 0 /var/log/xray/error.log 2>/dev/null
    
    # Historial de comandos
    rm -f /root/.bash_history
    history -c
    
    # Limpieza de apt
    apt-get clean >/dev/null 2>&1
    apt-get autoremove -y >/dev/null 2>&1
    
    echo -e "${C_VERDE} ¡Logs y Basura Vaciados Exitosamente!${C_RESET}"
    sleep 2
}

# --- MENU MANTENIMIENTO (ACTUALIZADO CON LA OPCION 4) ---
menu_mantenimiento() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} MANTENIMIENTO DEL SERVIDOR ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1] > COPIAS DE SEGURIDAD (MIGRAR)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > MEMORIA SWAP (ANTI-LAG)${C_RESET}"
        echo -e " ${C_TEXTO}[3] > VISOR DE LOGS (ERROR LOGS)${C_RESET}"
        echo -e " ${C_DATO}[4] > LIMPIAR LOGS Y BASURA (ESPACIO)${C_RESET}"  # <--- NUEVO BOTON
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op
        case $op in
            1) fun_backup_restore ;;
            2) fun_swap_manager ;;
            3) fun_log_viewer ;;
            4) fun_limpiar_logs ;;  # <--- NUEVO COMANDO
            0) break ;;
        esac
    done
}

fun_instalar_panel_web() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} GESTION PANEL WEB R-VP (FINAL UI) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        P_WEB_ACTUAL="8888"
        if [[ -f "/etc/reagens/panel_rvp.py" ]]; then
            P_WEB_ACTUAL=$(grep "PORT =" /etc/reagens/panel_rvp.py | awk '{print $3}' | head -n1)
            [[ -z "$P_WEB_ACTUAL" ]] && P_WEB_ACTUAL="8888"
        fi

        if systemctl is-active --quiet rvp-panel; then
            ESTADO_WEB="${C_VERDE}ONLINE (Puerto $P_WEB_ACTUAL)${C_RESET}"
        else
            ESTADO_WEB="${C_ROJO}OFFLINE${C_RESET}"
        fi
        
        echo -e " ESTADO ACTUAL: $ESTADO_WEB"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_DATO}[1] > REINSTALAR (APLICAR NUEVO DISEÑO)${C_RESET}"
        echo -e " ${C_DATO}[2] > DESINSTALAR COMPLETAMENTE${C_RESET}"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[3] > INICIAR SERVICIO${C_RESET}"
        echo -e " ${C_TEXTO}[4] > DETENER SERVICIO${C_RESET}"
        echo -e " ${C_TEXTO}[5] > CAMBIAR CONTRASEÑA ADMIN${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -n " Opcion: "
        read op_web

        case $op_web in
            1)
                echo -e " ${C_DATO}[+] Deteniendo procesos...${C_RESET}"
                systemctl stop rvp-panel >/dev/null 2>&1
                pkill -f panel_rvp.py >/dev/null 2>&1
                
                echo -e "\n ${C_TEXTO}Puerto actual: ${C_DATO}$P_WEB_ACTUAL${C_RESET}"
                echo -n " Ingrese Nuevo Puerto [Default 8888]: "
                read P_WEB_NEW
                [[ -z "$P_WEB_NEW" ]] && P_WEB_NEW="8888"
                fun_check_port $P_WEB_NEW "Panel Web R-VP" || return

                fuser -k $P_WEB_NEW/tcp >/dev/null 2>&1
                if [[ "$P_WEB_NEW" == "80" ]]; then
                    systemctl stop nginx >/dev/null 2>&1
                    systemctl stop apache2 >/dev/null 2>&1
                    systemctl stop ws-reagens >/dev/null 2>&1
                fi

                mkdir -p /etc/adm-lite /etc/reagens
                touch /etc/adm-lite/usuarios_ssh.db /etc/adm-lite/usuarios_token.db /etc/reagens/traffic.db
                chmod 777 /etc/adm-lite
                chmod 666 /etc/adm-lite/*.db
                chmod 666 /etc/reagens/traffic.db

                echo -e " ${C_DATO}[+] Instalando dependencias Python...${C_RESET}"
                if [[ -f /etc/redhat-release ]]; then
                    yum install -y python3-pip
                else
                    apt-get install -y python3-pip
                fi >/dev/null 2>&1
                pip3 install flask requests --break-system-packages >/dev/null 2>&1 || pip3 install flask requests >/dev/null 2>&1

cat <<'EOF' > /etc/reagens/panel_rvp.py
# -*- coding: utf-8 -*-
import os, subprocess, json, uuid, base64, datetime, re, shutil
from flask import Flask, request, redirect, url_for, session, render_template_string, flash
from datetime import timedelta

app = Flask(__name__)
app.secret_key = os.urandom(24)
app.permanent_session_lifetime = timedelta(days=7)

AUTH_FILE = "/etc/reagens/panel_auth"
DB_USERS = "/etc/reagens/users"
DB_V2_USERS = "/etc/reagens/users/v2ray"
V2_CONF = "/usr/local/etc/xray/config.json"
BASE_PASS_FILE = "/etc/reagens_base_pass"
DB_TRAFFIC = "/etc/reagens/traffic.db"
SLOW_KEY = "/etc/slowdns/server.pub"
SLOW_SVC = "/etc/systemd/system/slowdns-server.service"
DB_SSH_FILE = "/etc/adm-lite/usuarios_ssh.db"
DB_TOKEN_FILE = "/etc/adm-lite/usuarios_token.db"
REALITY_PUB = "/etc/reagens/reality_pub"
DEFAULT_SSH_PASS = "/etc/reagens/default_pass"
BANNER_FILE = "/etc/issue.net"

PORT = 8081

if not os.path.exists(DB_V2_USERS): os.makedirs(DB_V2_USERS, exist_ok=True)
if not os.path.exists("/etc/adm-lite"): os.makedirs("/etc/adm-lite", exist_ok=True)

def get_cmd(cmd):
    try: return subprocess.check_output(cmd, shell=True).decode().strip()
    except: return ""

def check_login(): return session.get('logged_in')

def get_base_pass():
    if os.path.exists(BASE_PASS_FILE):
        try: return open(BASE_PASS_FILE).read().strip()
        except: pass
    return "123456"

def db_append(filepath, line):
    try:
        with open(filepath, 'a') as f: 
            f.write(line + "\n")
            f.flush()
            os.fsync(f.fileno())
        return True
    except: return False

def get_user_data(user):
    path = f"{DB_USERS}/{user}"
    data = {}
    if os.path.exists(path):
        try:
            with open(path, 'r', errors='ignore') as f:
                for line in f:
                    if "=" in line: k, v = line.strip().split("=", 1); data[k] = v.strip()
        except: pass
    return data

def get_traffic_data(user):
    if not os.path.exists(DB_TRAFFIC): return (0, 0, 1)
    try:
        with open(DB_TRAFFIC, 'r') as f:
            for line in f:
                p = line.strip().split('|')
                if len(p) < 4: continue
                if p[0] == user:
                    return (int(int(p[1])/1048576), round(int(p[2])/1048576, 2), p[3])
    except: pass
    return (0, 0, 1)

def update_traffic_limit(user, mb_limit):
    if not os.path.exists(DB_TRAFFIC): return
    lines = []
    try:
        nb = int(mb_limit) * 1048576
        found = False
        with open(DB_TRAFFIC, 'r') as f:
            for line in f:
                p = line.strip().split('|')
                if len(p) < 4: lines.append(line); continue
                if p[0] == user:
                    st = "1" if nb == 0 or nb > int(p[2]) else p[3]
                    lines.append(f"{user}|{nb}|{p[2]}|{st}\n"); found = True
                else: lines.append(line)
        if not found: lines.append(f"{user}|{nb}|0|1\n")
        with open(DB_TRAFFIC, 'w') as f: f.writelines(lines)
        os.system(f"iptables -I OUTPUT -m owner --uid-owner {user} -j ACCEPT 2>/dev/null")
    except: pass

def get_users_list(user_type="ssh"):
    data = []
    target_db = DB_SSH_FILE if user_type == "ssh" else DB_TOKEN_FILE
    if os.path.exists(target_db):
        try:
            with open(target_db, 'r', errors='ignore') as f:
                for line in f:
                    line = line.strip()
                    if not line: continue
                    p = line.split('|')
                    u = p[0]
                    if user_type == "ssh" and len(p) >= 5:
                        pw = p[1]; date_raw = p[2]; lim = p[3]; mb_lim = p[4]
                        detail = "SSH" # No se usa en tabla SSH
                    elif user_type == "token" and len(p) >= 4:
                        pw = "---"; detail = p[1]; date_raw = p[2]; mb_lim = p[3]; lim="0"
                    else: continue
                    
                    # Verificacion Sistema
                    sys_check = get_cmd(f"id {u}")
                    if not sys_check: dias_restantes = "NO-SYS"
                    else:
                        try:
                            exp_dt = datetime.datetime.strptime(date_raw, "%Y-%m-%d")
                            delta = exp_dt - datetime.datetime.now()
                            dias_restantes = str(delta.days) if delta.days >= 0 else "EXP"
                        except: dias_restantes = "Err"
                    
                    lock = " L " in get_cmd(f"passwd -S {u}")
                    on = False
                    try:
                        if int(get_cmd(f"ps -u {u} | grep -E 'sshd|dropbear' | grep -v grep | wc -l")) > 0: on = True
                    except: pass
                    
                    # Datos Trafico
                    l_mb_db, u_mb, st = get_traffic_data(u)
                    
                    # Preferir limite de DB texto si el de traffic.db es 0 o defecto
                    traf_limit_show = mb_lim
                    
                    t_blk = (str(st) == "0")
                    
                    data.append({
                        'name': u, 
                        'password': pw, 
                        'detail': detail, # Nombre Cliente para Token
                        'exp': date_raw, 
                        'days': dias_restantes,
                        'limit_conn': lim,
                        'locked': lock, 
                        'online': on, 
                        'traf_limit': traf_limit_show, 
                        'traf_used': u_mb, 
                        'traf_blocked': t_blk
                    })
        except: pass
    return data

def get_v2ray_users():
    if not os.path.exists(V2_CONF): return []
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        users = []
        # Buscamos en el primer inbound para listar
        for x in c['inbounds'][0]['settings']['clients']:
            e = x.get('email', '?'); uid = x.get('id', x.get('password', '?'))
            blk = "BLOCKED_" in e; alias = e.replace("BLOCKED_", "")
            mf = f"{DB_V2_USERS}/{alias}"; exp = "---"
            if os.path.exists(mf):
                try: 
                    with open(mf, 'r') as f_meta:
                        for l in f_meta:
                            l = l.strip()
                            if "EXP=" in l: exp = l.split("=")[1].strip()
                except: pass
            users.append({'alias':alias, 'uuid':uid, 'blocked':blk, 'exp':exp})
        return users
    except: return []

def get_slowdns_info():
    info = {'status': 'OFF', 'ns': '---', 'pub': '---', 'out': '---'}
    if os.system("systemctl is-active --quiet slowdns-server") == 0: info['status'] = 'ON'
    if os.path.exists(SLOW_KEY): info['pub'] = open(SLOW_KEY).read().strip()
    if os.path.exists(SLOW_SVC):
        try:
            with open(SLOW_SVC) as f:
                for l in f:
                    if "ExecStart=" in l:
                        parts = l.strip().split()
                        info['ns'] = parts[-2]
                        info['out'] = parts[-1].split(":")[-1]
        except: pass
    return info

CSS = """
<style>
:root { --bg:#121212; --card:#1e1e1e; --txt:#e0e0e0; --acc:#007bff; --nav:#000; }
body { background:var(--bg); color:var(--txt); font-family:'Segoe UI', sans-serif; margin:0; display:flex; min-height:100vh; }
.sidebar { width:220px; background:var(--nav); border-right:1px solid #333; display:flex; flex-direction:column; padding:20px; }
.content { flex:1; padding:30px; overflow-y:auto; }
a { text-decoration:none; color:#aaa; display:block; padding:12px; margin:5px 0; border-radius:6px; transition:0.2s; }
a:hover, a.active { background:var(--card); color:#fff; border-left:4px solid var(--acc); }
.card { background:var(--card); padding:20px; margin-bottom:20px; border-radius:8px; border:1px solid #333; box-shadow:0 4px 6px rgba(0,0,0,0.3); }
h2, h3 { margin-top:0; color:#fff; }
input, select, textarea { width:100%; padding:10px; margin:8px 0; background:#2c2c2c; border:1px solid #444; color:#fff; border-radius:4px; box-sizing:border-box; }
.btn { display:inline-block; padding:8px 15px; background:var(--acc); color:#fff; border:none; border-radius:4px; cursor:pointer; font-size:0.9rem; }
.btn:hover { opacity:0.9; }
.btn-red { background:#d32f2f; } .btn-green { background:#388e3c; } .btn-org { background:#f57c00; }
table { width:100%; border-collapse:collapse; margin-top:15px; font-size:0.9rem; }
th, td { text-align:left; padding:12px; border-bottom:1px solid #333; }
th { background:#252525; color:#fff; }
.badge { padding:4px 8px; border-radius:4px; font-size:0.75rem; font-weight:bold; }
.bg-on { background:#388e3c; color:#fff; } .bg-off { background:#616161; color:#fff; } .bg-lock { background:#d32f2f; color:#fff; }
.flash { padding:15px; margin-bottom:20px; border-radius:6px; background:#007bff; color:white; text-align:center; font-weight:bold; }
.grid-form { display:grid; grid-template-columns:1fr 1fr; gap:15px; }
.login-box { width:100%; max-width:400px; margin:100px auto; padding:40px; background:#1e1e1e; border-radius:10px; box-shadow:0 0 20px rgba(0,0,0,0.5); text-align:center; }
@media(max-width:768px) { body{flex-direction:column;} .sidebar{width:100%;} .grid-form{grid-template-columns:1fr;} }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
"""

LAYOUT = """
<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>R-VP MANAGER PRO</title>""" + CSS + """</head><body>
<div class="sidebar">
    <h2 style="color:#fff; text-align:center; letter-spacing:2px;">R-VP <span style="color:#007bff;">PRO</span></h2>
    <hr style="border:0; border-top:1px solid #333; margin-bottom:20px;">
    <a href="/"><i class="fas fa-chart-line"></i> Dashboard</a>
    <a href="/ssh"><i class="fas fa-user-shield"></i> Usuarios SSH</a>
    <a href="/tokens"><i class="fas fa-key"></i> Tokens App</a>
    <a href="/v2ray"><i class="fas fa-paper-plane"></i> V2Ray / Xray</a>
    <a href="/protos"><i class="fas fa-network-wired"></i> Protocolos UDP</a>
    <a href="/tools"><i class="fas fa-tools"></i> Centro de Control</a>
    <a href="/settings"><i class="fas fa-cogs"></i> Ajustes Panel</a>
    <a href="/logout" style="margin-top:auto; color:#ef5350;"><i class="fas fa-sign-out-alt"></i> Cerrar Sesion</a>
</div>
<div class="content">
    {% with m=get_flashed_messages() %}{% if m %}<div class="flash"><i class="fas fa-info-circle"></i> {{ m[0] }}</div>{% endif %}{% endwith %}
    {{ body|safe }}
</div>
</body></html>
"""

LOGIN_HTML = """
<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Login R-VP</title>""" + CSS + """</head><body style="display:block;">
<div class="login-box">
    <h2 style="color:#007bff; margin-bottom:30px;">ACCESO SEGURO</h2>
    <form method="post">
        <input name="u" placeholder="Usuario" style="padding:15px; margin-bottom:15px;">
        <input name="p" type="password" placeholder="Password" style="padding:15px; margin-bottom:25px;">
        <button class="btn" style="width:100%; padding:15px; font-size:1.1rem;">INICIAR SESION</button>
    </form>
</div></body></html>
"""

@app.route('/')
def home():
    if not check_login(): return redirect('/login')
    ram = get_cmd("free -h | grep Mem | awk '{print $3 \" / \" $2}'")
    ip = get_cmd("curl -s ipv4.icanhazip.com")
    uptime = get_cmd("uptime -p")
    cpu = get_cmd("top -bn1 | grep 'Cpu(s)' | awk '{print 100 - $8\"%\"}'")
    info = f"""<div class="card"><h2><i class="fas fa-server"></i> Estado del Servidor</h2><div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:20px; margin-top:20px;"><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-memory fa-2x" style="color:#007bff;"></i><br><b>RAM</b><br>{ram}</div><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-microchip fa-2x" style="color:#28a745;"></i><br><b>CPU</b><br>{cpu}</div><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-globe fa-2x" style="color:#ffc107;"></i><br><b>IP</b><br>{ip}</div><div style="background:#252525; padding:15px; border-radius:6px; text-align:center;"><i class="fas fa-clock fa-2x" style="color:#dc3545;"></i><br><b>UPTIME</b><br>{uptime}</div></div></div>"""
    return render_template_string(LAYOUT, body=info)

@app.route('/login', methods=['GET','POST'])
def login():
    if request.method == 'POST':
        u = request.form.get('u'); p = request.form.get('p')
        real_u, real_p = "admin", "admin"
        if os.path.exists(AUTH_FILE):
            try: parts = open(AUTH_FILE).read().strip().split(':'); real_u=parts[0]; real_p=parts[1]
            except: pass
        if u==real_u and p==real_p:
            session.permanent = True
            session['logged_in'] = True; return redirect('/')
    return render_template_string(LOGIN_HTML)

@app.route('/logout')
def logout(): session.clear(); return redirect('/login')

@app.route('/ssh')
def ssh():
    if not check_login(): return redirect('/login')
    users = get_users_list("ssh")
    # TABLA SSH MODIFICADA: User | Pass | Vence | Limit | Consumo | Estado | Acciones
    html = """<div class="card"><h3><i class="fas fa-user-plus"></i> Nuevo SSH</h3>
    <form action="/ssh/add" method="POST" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;">
    <input name="u" placeholder="Usuario" required>
    <input name="p" placeholder="Password" required>
    <input name="d" type="number" value="30" placeholder="Dias">
    <input name="l" type="number" placeholder="Limite Conexiones" required>
    <input name="mb" type="number" placeholder="MB (0=Inf)">
    <button class="btn">Crear</button></form></div>
    <div class="card"><h3>Lista SSH</h3><table>
    <thead><tr><th>Usuario</th><th>Pass</th><th>Vence</th><th>Limit IP</th><th>Consumo</th><th>Estado</th><th>Acciones</th></tr></thead><tbody>"""
    
    for u in users:
        st_c, st_t = ('bg-on', 'ON') if u['online'] else ('bg-off', 'OFF')
        if u['traf_blocked']: st_c, st_t = 'bg-lock', 'FIN MB'
        elif u['locked']: st_c, st_t = 'bg-lock', 'BLOQ'
        if u['days'] == "NO-SYS": st_c = "bg-lock"; st_t = "ERROR"
        l_a, l_c, l_i = ('unlock', 'btn-green', 'unlock') if u['locked'] else ('lock', 'btn-org', 'lock')
        
        html += f"""<tr>
        <td>{u['name']}</td>
        <td>{u['password']}</td>
        <td>{u['exp']} <small>({u['days']}d)</small></td>
        <td>{u['limit_conn']}</td>
        <td><b>{u['traf_used']}</b> / {u['traf_limit']} MB</td>
        <td><span class="badge {st_c}">{st_t}</span></td>
        <td><a href='/ssh/edit/{u['name']}' class='btn'><i class='fas fa-edit'></i></a> <a href='/user/{l_a}/{u['name']}' class='btn {l_c}'><i class='fas fa-{l_i}'></i></a> <a href='/user/del/{u['name']}' class='btn btn-red' onclick="return confirm('?');"><i class='fas fa-trash'></i></a> <a href='/user/renew/{u['name']}' class='btn btn-green'><i class='fas fa-sync'></i></a></td>
        </tr>"""
    return render_template_string(LAYOUT, body=html+"</tbody></table></div>")

@app.route('/ssh/add', methods=['POST'])
def ssh_add():
    if not check_login(): return redirect('/login')
    u = request.form.get('u'); p = request.form.get('p')
    d = request.form.get('d'); l = request.form.get('l'); mb = request.form.get('mb')
    if not mb: mb = "0"
    if not l: l = "1"
    
    safe_u = re.sub(r'[^a-zA-Z0-9]', '', u)
    if safe_u != u: u = safe_u; flash(f"Corregido a: {u}")
    if not u: return redirect('/ssh')
    if get_cmd(f"id {u}"): flash("Existe")
    else:
        fd = get_cmd(f"date -d '+{d} days' +%Y-%m-%d")
        ret1 = os.system(f"useradd -M -s /bin/false {u}")
        os.system(f"echo '{u}:{p}' | chpasswd")
        os.system(f"chage -E '{fd}' {u}")
        exists = get_cmd(f"id {u}")
        if ret1 == 0 and exists:
            os.system(f"iptables -I OUTPUT -m owner --uid-owner {u} -j ACCEPT")
            with open(DB_TRAFFIC, "a") as f: f.write(f"{u}|{int(mb)*1048576}|0|1\n")
            if db_append(DB_SSH_FILE, f"{u}|{p}|{fd}|{l}|{mb}"): flash(f"EXITO: Usuario {u} creado.")
            else: flash("Error DB")
        else: flash("ERROR SISTEMA")
    return redirect('/ssh')

@app.route('/ssh/edit/<uname>', methods=['GET','POST'])
def ssh_edit(uname):
    if not check_login(): return redirect('/login')
    d = get_user_data(uname); l_mb, u_mb, st = get_traffic_data(uname)
    if request.method == 'POST':
        p, dy, l, mb = request.form.get('p'), request.form.get('d'), request.form.get('l'), request.form.get('mb')
        if p: os.system(f"echo '{uname}:{p}' | chpasswd")
        final_date = ""
        if dy: 
            final_date = get_cmd(f"date -d '+{dy} days' +%Y-%m-%d")
            os.system(f"chage -E '{final_date}' {uname}")
        if mb: update_traffic_limit(uname, mb)
        lines = []
        try:
            if os.path.exists(DB_SSH_FILE):
                with open(DB_SSH_FILE, 'r', errors='ignore') as f:
                    for line in f:
                        line = line.strip(); parts = line.split('|')
                        if len(parts) >= 5 and parts[0] == uname:
                            curr_pass = parts[1]; curr_exp = parts[2]; curr_lim = parts[3]; curr_mb = parts[4]
                            new_pass = p if p else curr_pass
                            new_exp = final_date if final_date else curr_exp
                            new_lim = l if l else curr_lim
                            new_mb = mb if mb else curr_mb
                            lines.append(f"{uname}|{new_pass}|{new_exp}|{new_lim}|{new_mb}\n")
                        else: 
                            if line: lines.append(line + "\n")
                if lines:
                    with open(DB_SSH_FILE, 'w') as f:
                        f.writelines(lines); f.flush(); os.fsync(f.fileno())
        except: pass
        flash("Editado"); return redirect('/ssh')
    h = f"""<div class="card"><h3>Editar SSH: {uname}</h3><form method="POST"><div class="grid-form"><div><label>Pass</label><input name="p"></div><div><label>Limit Conn</label><input name="l" value="{d.get('LIMIT_CONN','1')}"></div><div><label>+/- Dias</label><input name="d" type="number"></div><div><label>MB Limit</label><input name="mb" value="{l_mb}"></div></div><br><button class="btn btn-green">Guardar</button></form><br><a href="/ssh" class="btn btn-red">Volver</a></div>"""
    return render_template_string(LAYOUT, body=h)

@app.route('/tokens')
def tokens():
    if not check_login(): return redirect('/login')
    users = get_users_list("token"); def_p = get_base_pass()
    # TABLA TOKEN MODIFICADA: Cliente | TokenID | Vence | Consumo | Estado | Acciones (SIN PASS)
    html = f"""<div class="card" style="border-top:3px solid #8e44ad;"><h3>Crear Token</h3><form action="/token/add" method="POST" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;"><input name="u" placeholder="ID Token" required><input name="client" placeholder="Cliente" required><input name="d" type="number" value="30" placeholder="Dias"><input name="mb" type="number" placeholder="MB"><input name="p" value="{def_p}" readonly style="background:#333;"><button class="btn" style="background:#8e44ad;">Crear</button></form></div>
    <div class="card"><h3>Tokens</h3><table>
    <thead><tr><th>Cliente</th><th>Token ID</th><th>Vence</th><th>Consumo</th><th>Estado</th><th>Acciones</th></tr></thead><tbody>"""
    
    for u in users:
        st_c, st_t = ('bg-on', 'ON') if u['online'] else ('bg-off', 'OFF')
        if u['traf_blocked']: st_c, st_t = 'bg-lock', 'FIN MB'
        elif u['locked']: st_c, st_t = 'bg-lock', 'BLOQ'
        if u['days'] == "NO-SYS": st_c = "bg-lock"; st_t = "ERROR"
        l_a, l_c, l_i = ('unlock', 'btn-green', 'unlock') if u['locked'] else ('lock', 'btn-org', 'lock')
        
        html += f"""<tr>
        <td>{u['detail']}</td>
        <td><b>{u['name']}</b></td>
        <td>{u['exp']} <small>({u['days']}d)</small></td>
        <td><b>{u['traf_used']}</b> / {u['traf_limit']} MB</td>
        <td><span class="badge {st_c}">{st_t}</span></td>
        <td><a href='/token/edit/{u['name']}' class='btn'><i class='fas fa-edit'></i></a> <a href='/user/{l_a}/{u['name']}' class='btn {l_c}'><i class='fas fa-{l_i}'></i></a> <a href='/user/del/{u['name']}' class='btn btn-red' onclick="return confirm('?');"><i class='fas fa-trash'></i></a> <a href='/user/renew/{u['name']}' class='btn btn-green'><i class='fas fa-sync'></i></a></td>
        </tr>"""
    return render_template_string(LAYOUT, body=html+"</tbody></table></div>")

@app.route('/token/add', methods=['POST'])
def token_add():
    if not check_login(): return redirect('/login')
    u, c, d, p, mb = request.form.get('u'), request.form.get('client'), request.form.get('d'), request.form.get('p'), request.form.get('mb')
    if not mb: mb = "0"
    safe_u = re.sub(r'[^a-zA-Z0-9]', '', u)
    if safe_u != u: u = safe_u; flash(f"Corregido a: {u}")
    if get_cmd(f"id {u}"): flash("Existe")
    else:
        fd = get_cmd(f"date -d '+{d} days' +%Y-%m-%d")
        ret1 = os.system(f"useradd -M -s /bin/false -c '{c}' {u}")
        os.system(f"echo '{u}:{p}' | chpasswd")
        os.system(f"chage -E '{fd}' {u}")
        exists = get_cmd(f"id {u}")
        if ret1 == 0 and exists:
            os.system(f"iptables -I OUTPUT -m owner --uid-owner {u} -j ACCEPT")
            with open(DB_TRAFFIC, "a") as f: f.write(f"{u}|{int(mb)*1048576}|0|1\n")
            db_append(DB_TOKEN_FILE, f"{u}|{c}|{fd}|{mb}")
            flash("Token Creado")
        else: flash("Error sistema")
    return redirect('/tokens')

@app.route('/token/edit/<uname>', methods=['GET','POST'])
def token_edit(uname):
    if not check_login(): return redirect('/login')
    d = get_user_data(uname); l_mb, u_mb, st = get_traffic_data(uname)
    if request.method == 'POST':
        c, dy, mb = request.form.get('client'), request.form.get('d'), request.form.get('mb')
        final_date = ""
        if dy: 
            final_date = get_cmd(f"date -d '+{dy} days' +%Y-%m-%d")
            os.system(f"chage -E '{final_date}' {uname}")
        os.system(f"usermod -c '{c}' {uname}")
        if mb: update_traffic_limit(uname, mb)
        lines = []
        try:
            if os.path.exists(DB_TOKEN_FILE):
                with open(DB_TOKEN_FILE, 'r', errors='ignore') as f:
                    for line in f:
                        line = line.strip(); parts = line.split('|')
                        if len(parts) >= 4 and parts[0] == uname:
                            curr_c = parts[1]; curr_e = parts[2]; curr_mb = parts[3]
                            new_client = c if c else curr_c
                            new_exp = final_date if final_date else curr_e
                            new_mb = mb if mb else curr_mb
                            lines.append(f"{uname}|{new_client}|{new_exp}|{new_mb}\n")
                        else: 
                            if line: lines.append(line + "\n")
                if lines:
                    with open(DB_TOKEN_FILE, 'w') as f:
                        f.writelines(lines); f.flush(); os.fsync(f.fileno())
        except: pass
        flash("Editado"); return redirect('/tokens')
    h = f"""<div class="card"><h3>Edit Token: {uname}</h3><form method="POST"><div class="grid-form"><div><label>Cliente</label><input name="client" value="{d.get('CLIENT_REF','')}"></div><div><label>MB Limit</label><input name="mb" value="{l_mb}"></div><div><label>+/- Dias</label><input name="d" type="number"></div></div><br><button class="btn btn-green">Guardar</button></form><br><a href="/tokens" class="btn btn-red">Volver</a></div>"""
    return render_template_string(LAYOUT, body=h)

@app.route('/v2ray')
def v2ray():
    if not check_login(): return redirect('/login')
    if not os.path.exists(V2_CONF): return render_template_string(LAYOUT, body="<div class='card'><h3>Xray no instalado</h3></div>")
    users = get_v2ray_users()
    html = """<div class="card" style="border-top:3px solid #27ae60;"><h3>Crear Usuario Xray</h3><form action="/v2ray/add" method="POST" style="display:flex; gap:10px;"><input name="u" placeholder="Alias" required><input name="d" type="number" value="30" placeholder="Dias" style="width:80px;"><button class="btn btn-green">Crear</button></form></div><div class="card"><h3>Lista V2Ray</h3><table><thead><tr><th>Alias</th><th>UUID</th><th>Vence</th><th>Estado</th><th>Accion</th></tr></thead><tbody>"""
    for u in users:
        st = "<span class='badge bg-lock'>BLOQ</span>" if u['blocked'] else "<span class='badge bg-on'>OK</span>"
        act = f"<a href='/v2ray/unblock/{u['alias']}' class='btn btn-green'><i class='fas fa-check'></i></a>" if u['blocked'] else f"<a href='/v2ray/block/{u['alias']}' class='btn btn-red'><i class='fas fa-ban'></i></a>"
        html += f"<tr><td>{u['alias']}</td><td><small>{u['uuid'][:8]}...</small></td><td>{u['exp']}</td><td>{st}</td><td><div style='display:flex; gap:5px;'><a href='/v2ray/link/{u['alias']}' class='btn btn-org'><i class='fas fa-qrcode'></i></a><a href='/v2ray/edit/{u['alias']}' class='btn'><i class='fas fa-edit'></i></a>{act}<a href='/v2ray/del/{u['alias']}' class='btn btn-red'><i class='fas fa-trash'></i></a></div></td></tr>"
    return render_template_string(LAYOUT, body=html+"</tbody></table></div>")

@app.route('/v2ray/add', methods=['POST'])
def v2ray_add():
    try:
        u = request.form.get('u'); d = int(request.form.get('d', 30)); uuid_val = str(uuid.uuid4())
        u = re.sub(r'[^a-zA-Z0-9]', '', u)
        with open(V2_CONF, 'r') as f: c = json.load(f)
        for inb in c['inbounds']:
            proto = inb['protocol']; client = {"email": u}
            if proto in ["vmess", "vless"]: client["id"] = uuid_val; 
            if proto == "vmess": client["alterId"] = 0
            if proto == "trojan": client["password"] = uuid_val
            try:
                if inb['streamSettings']['security'] == 'reality' and proto == 'vless':
                    client['flow'] = 'xtls-rprx-vision'
            except: pass
            inb['settings']['clients'].append(client)
        tmp_conf = V2_CONF + ".tmp"
        with open(tmp_conf, 'w') as f: json.dump(c, f, indent=2)
        os.rename(tmp_conf, V2_CONF)
        os.system("systemctl restart xray")
        ed = (datetime.datetime.now() + datetime.timedelta(days=d)).strftime("%Y-%m-%d")
        mf = f"{DB_V2_USERS}/{u}"
        with open(mf, "w") as f: f.write(f"EXP={ed}\nUUID={uuid_val}\nDURATION={d}\n"); f.flush(); os.fsync(f.fileno())
        flash("V2Ray Creado")
    except Exception as e: flash(f"Error: {e}")
    return redirect('/v2ray')

@app.route('/v2ray/edit/<u>', methods=['GET','POST'])
def v2ray_edit(u):
    if not check_login(): return redirect('/login')
    mf = f"{DB_V2_USERS}/{u}"; cur_exp = "---"
    metadata = {}
    if os.path.exists(mf):
        try:
            with open(mf, 'r') as f:
                for line in f:
                    if "=" in line: k, v = line.strip().split("=", 1); metadata[k] = v
        except: pass
    cur_exp = metadata.get("EXP", "---")
    if request.method == 'POST':
        d = request.form.get('d')
        if d:
            try:
                new_days = int(d)
                try: dt = datetime.datetime.strptime(cur_exp, "%Y-%m-%d")
                except: dt = datetime.datetime.now()
                if dt < datetime.datetime.now(): dt = datetime.datetime.now()
                new_date = (dt + datetime.timedelta(days=new_days)).strftime("%Y-%m-%d")
                uuid_val = metadata.get("UUID", "unknown")
                with open(mf, 'w') as f:
                    f.write(f"EXP={new_date}\n"); f.write(f"UUID={uuid_val}\n"); f.write(f"DURATION={new_days}\n")
                    f.flush(); os.fsync(f.fileno())
                flash(f"Renovado. Nueva fecha: {new_date}")
            except: flash("Error en fecha")
        return redirect('/v2ray')
    h = f"""<div class="card" style="max-width:500px; margin:auto;"><h3>Editar V2Ray: {u}</h3><p>Vence: <b>{cur_exp}</b></p><form method="POST"><label>Sumar Dias</label><input name="d" type="number" placeholder="Ej: 30"><button class="btn btn-green" style="width:100%;">Renovar</button></form><br><a href="/v2ray" class="btn btn-red">Cancelar</a></div>"""
    return render_template_string(LAYOUT, body=h)

@app.route('/v2ray/del/<u>')
def v2ray_del(u):
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        for inb in c['inbounds']: inb['settings']['clients'] = [x for x in inb['settings']['clients'] if x.get('email') not in [u, f"BLOCKED_{u}"]]
        tmp_conf = V2_CONF + ".tmp"
        with open(tmp_conf, 'w') as f: json.dump(c, f, indent=2)
        os.rename(tmp_conf, V2_CONF)
        os.system("systemctl restart xray")
        if os.path.exists(f"{DB_V2_USERS}/{u}"): os.remove(f"{DB_V2_USERS}/{u}")
    except: pass
    return redirect('/v2ray')

@app.route('/v2ray/block/<u>')
def v2ray_block(u):
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        for inb in c['inbounds']:
            for x in inb['settings']['clients']:
                if x.get('email') == u: x['email'] = f"BLOCKED_{u}"
        with open(V2_CONF, 'w') as f: json.dump(c, f, indent=2)
        os.system("systemctl restart xray")
    except: pass
    return redirect('/v2ray')

@app.route('/v2ray/unblock/<u>')
def v2ray_unblock(u):
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        for inb in c['inbounds']:
            for x in inb['settings']['clients']:
                if x.get('email') == f"BLOCKED_{u}": x['email'] = u
        with open(V2_CONF, 'w') as f: json.dump(c, f, indent=2)
        os.system("systemctl restart xray")
    except: pass
    return redirect('/v2ray')

@app.route('/v2ray/link/<u>')
def v2ray_link(u):
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        ip = get_cmd("curl -s ipv4.icanhazip.com")
        html = ""; js = ""
        uuid_val = ""
        for cl in c['inbounds'][0]['settings']['clients']:
             if cl.get('email') == u:
                  uuid_val = cl.get('id', cl.get('password'))
                  break
        
        if not uuid_val: return redirect('/v2ray')

        for idx, inb in enumerate(c['inbounds']):
            p = inb['port']; proto = inb['protocol']
            s = inb['streamSettings']; net = s.get('network','tcp'); tls = s.get('security','none')
            path = s.get('wsSettings',{}).get('path','/'); host = s.get('wsSettings',{}).get('headers',{}).get('Host','')
            serviceName = s.get('grpcSettings',{}).get('serviceName','')
            type_header = s.get('kcpSettings',{}).get('header',{}).get('type','none')
            seed = s.get('kcpSettings',{}).get('seed','')
            sni = s.get('realitySettings',{}).get('serverNames',[''])[0]
            pbk = open("/etc/reagens/reality_pub").read().strip() if os.path.exists("/etc/reagens/reality_pub") else ""
            sid = s.get('realitySettings',{}).get('shortIds',[''])[0]
            fp = s.get('realitySettings',{}).get('fingerprint','chrome')
            nm = f"{u}-{proto}-{net}"
            lnk = ""
            if proto == "vmess":
                ps_obj = { "v": "2", "ps": nm, "add": ip, "port": p, "id": uuid_val, "aid": "0", "scy": "auto", "net": net, "type": "none", "host": host, "path": path, "tls": tls, "sni": host }
                if net == "grpc": ps_obj.update({"path": serviceName, "type": "multi"})
                if net == "kcp": ps_obj.update({"path": seed, "type": type_header})
                lnk = "vmess://" + base64.b64encode(json.dumps(ps_obj).encode()).decode()
            elif proto == "vless":
                lnk = f"vless://{uuid_val}@{ip}:{p}?security={tls}&encryption=none&type={net}&headerType={type_header}"
                if tls == "reality": lnk += f"&sni={sni}&pbk={pbk}&sid={sid}&fp={fp}&flow=xtls-rprx-vision"
                elif tls == "tls": lnk += f"&sni={host}"
                if net == "ws": lnk += f"&path={path}&host={host}"
                elif net == "grpc": lnk += f"&serviceName={serviceName}&mode=multi"
                elif net == "kcp": lnk += f"&seed={seed}"
                lnk += f"#{nm}"
            elif proto == "trojan":
                lnk = f"trojan://{uuid_val}@{ip}:{p}?security={tls}&type={net}&headerType={type_header}"
                if tls == "tls": lnk += f"&sni={host}"
                if net == "ws": lnk += f"&path={path}&host={host}"
                elif net == "grpc": lnk += f"&serviceName={serviceName}&mode=multi"
                lnk += f"#{nm}"
                
            html += f"<div style='background:#222; padding:10px; margin:10px 0;'><b>{proto.upper()} ({net})</b><br><textarea style='width:100%; color:#ccc; background:#000;'>{lnk}</textarea><div id='qr_{idx}' style='background:white; padding:5px; display:inline-block; margin-top:5px;'></div></div>"
            js += f"new QRCode(document.getElementById('qr_{idx}'), {{ text: '{lnk}', width: 300, height: 300 }});"
            
        return render_template_string(LAYOUT + f"<script>{js}</script>", body=f"<div class='card'><h3>Links: {u}</h3>{html}<br><a href='/v2ray' class='btn'>Volver</a></div>")
    except Exception as e: return f"Error: {e} <a href='/v2ray'>Volver</a>"

@app.route('/protos')
def protos():
    if not check_login(): return redirect('/login')
    sd = get_slowdns_info()
    st_sd = f"<span class='badge bg-on'>ON</span>" if sd['status'] == 'ON' else "<span class='badge bg-off'>OFF</span>"
    html = f"""
    <div class="card" style="border-top:3px solid #d35400;">
        <h3><i class="fas fa-network-wired"></i> SlowDNS Manager</h3>
        <div class="grid-form">
            <div style="background:#222; padding:10px; border-radius:4px;"><small style="color:#aaa;">ESTADO</small><br>{st_sd}</div>
            <div style="background:#222; padding:10px; border-radius:4px;"><small style="color:#aaa;">DOMINIO NS</small><br><b style="color:#d35400;">{sd['ns']}</b></div>
            <div style="background:#222; padding:10px; border-radius:4px;"><small style="color:#aaa;">PUERTO ENTRADA</small><br><b>53 (UDP)</b></div>
            <div style="background:#222; padding:10px; border-radius:4px;"><small style="color:#aaa;">PUERTO SALIDA (TARGET)</small><br><b style="color:#27ae60;">{sd['out']}</b></div>
        </div>
        <div style="margin-top:15px; background:#222; padding:10px; word-break:break-all;"><small>LLAVE PUBLICA (SERVER.PUB)</small><br><code style="color:#f1c40f;">{sd['pub']}</code></div>
        <hr style="border:0; border-top:1px solid #333;">
        <form action="/slow/conf" method="POST" style="display:flex; gap:10px; align-items:center;">
            <label>Cambiar Salida:</label><input name="p" type="number" placeholder="Ej: 22" style="width:100px;"><button class="btn btn-org">Update</button>
        </form>
        <div style="margin-top:15px;"><a href="/svc/slow/start" class="btn btn-green">INICIAR</a> <a href="/svc/slow/stop" class="btn btn-red">DETENER</a></div>
    </div>
    """
    return render_template_string(LAYOUT, body=html)

@app.route('/slow/conf', methods=['POST'])
def slow_conf():
    p = request.form.get('p')
    if p:
        os.system(f"sed -i 's|127.0.0.1:[0-9]*|127.0.0.1:{p}|g' /etc/systemd/system/slowdns-server.service")
        os.system("systemctl daemon-reload && systemctl restart slowdns-server")
        flash(f"Salida cambiada a: {p}")
    return redirect('/protos')

@app.route('/svc/<srv>/<act>')
def svc_act(srv, act):
    s = "slowdns-server" if srv=="slow" else "udp-custom"
    os.system(f"systemctl {act} {s}")
    return redirect('/protos')

@app.route('/settings', methods=['GET','POST'])
def settings():
    if not check_login(): return redirect('/login')
    
    # 1. LEER PUERTOS ACTUALES DE V2RAY
    p1_act, p2_act = "---", "---"
    if os.path.exists(V2_CONF):
        try:
            with open(V2_CONF, 'r') as f:
                c = json.load(f)
                p1_act = c['inbounds'][0]['port']
                if len(c['inbounds']) > 1: p2_act = c['inbounds'][1]['port']
        except: pass

    if request.method == 'POST':
        t = request.form.get('type')
        if t == "admin":
            u = request.form.get('u'); p = request.form.get('p')
            if u and p: open(AUTH_FILE, 'w').write(f"{u}:{p}"); flash("Admin Actualizado")
        elif t == "token":
            p = request.form.get('p')
            if p: open(BASE_PASS_FILE, 'w').write(p); flash("Pass Token Actualizada")
        elif t == "def_ssh":
            p = request.form.get('p')
            if p: open(DEFAULT_SSH_PASS, 'w').write(p); flash("Pass SSH Default Actualizada")
        elif t == "banner":
            b = request.form.get('content')
            if b:
                open(BANNER_FILE, 'w').write(b)
                os.system("service ssh restart >/dev/null 2>&1; service dropbear restart >/dev/null 2>&1")
                flash("Banner Actualizado")
        return redirect('/settings')
    
    bp = get_base_pass()
    def_ssh_p = open(DEFAULT_SSH_PASS).read().strip() if os.path.exists(DEFAULT_SSH_PASS) else ""
    banner_c = open(BANNER_FILE).read() if os.path.exists(BANNER_FILE) else ""
    
    # 2. DISEÑO UNIFICADO
    h = f"""
    <div class="grid-form">
        <div class="card"><h3>Admin Panel</h3><form method="POST"><input type="hidden" name="type" value="admin"><label>Usuario</label><input name="u"><label>Password</label><input name="p"><button class="btn btn-org">Actualizar</button></form></div>
        <div class="card"><h3>Token Pass Base</h3><form method="POST"><input type="hidden" name="type" value="token"><label>Actual</label><input name="p" value="{bp}"><button class="btn btn-green">Guardar</button></form></div>
        <div class="card"><h3>Default SSH Pass</h3><form method="POST"><input type="hidden" name="type" value="def_ssh"><label>Actual</label><input name="p" value="{def_ssh_p}"><button class="btn btn-green">Guardar</button></form></div>
    </div>

    <div class="card" style="border-top: 3px solid #f1c40f;">
        <h3><i class="fas fa-plug"></i> Gestion de Puertos V2Ray</h3>
        <p>Puerto Actual Perfil 1: <b style="color:#007bff;">{p1_act}</b> | Perfil 2: <b style="color:#007bff;">{p2_act}</b></p>
        <form action="/settings/update_v2_ports" method="POST" class="grid-form">
            <div><label>Nuevo Puerto 1</label><input name="np1" type="number" placeholder="Ej: 8080"></div>
            <div><label>Nuevo Puerto 2</label><input name="np2" type="number" placeholder="Ej: 443"></div>
            <button class="btn btn-org" style="grid-column: span 2;">APLICAR CAMBIO DE PUERTOS</button>
        </form>
    </div>

    <div class="card">
        <h3>SSH Banner Editor (/etc/issue.net)</h3>
        <form method="POST">
            <input type="hidden" name="type" value="banner">
            <textarea name="content" rows="8" style="width:100%; background:#2c2c2c; color:#fff; border:1px solid #444; padding:10px;">{banner_c}</textarea>
            <br><br><button class="btn btn-org">Guardar Banner</button>
        </form>
    </div>
    """
    return render_template_string(LAYOUT, body=h)

@app.route('/settings/update_v2_ports', methods=['POST'])
def update_v2_ports():
    if not check_login(): return redirect('/login')
    try:
        np1 = request.form.get('np1')
        np2 = request.form.get('np2')
        
        if not os.path.exists(V2_CONF): 
            flash("Error: Xray no instalado")
            return redirect('/settings')

        with open(V2_CONF, 'r') as f: config = json.load(f)

        # Cambiar Puerto 1
        if np1:
            old1 = config['inbounds'][0]['port']
            config['inbounds'][0]['port'] = int(np1)
            os.system(f"iptables -D INPUT -p tcp --dport {old1} -j ACCEPT 2>/dev/null")
            os.system(f"iptables -I INPUT -p tcp --dport {np1} -j ACCEPT")

        # Cambiar Puerto 2 (Si existe en el JSON)
        if np2 and len(config['inbounds']) > 1:
            old2 = config['inbounds'][1]['port']
            config['inbounds'][1]['port'] = int(np2)
            os.system(f"iptables -D INPUT -p tcp --dport {old2} -j ACCEPT 2>/dev/null")
            os.system(f"iptables -I INPUT -p tcp --dport {np2} -j ACCEPT")

        # Guardar y Reiniciar
        with open(V2_CONF, 'w') as f: json.dump(config, f, indent=2)
        os.system("systemctl restart xray && netfilter-persistent save 2>/dev/null")
        flash(f"Puertos Actualizados: P1={np1 if np1 else 'Sin cambio'} | P2={np2 if np2 else 'Sin cambio'}")
        
    except Exception as e:
        flash(f"Error: {str(e)}")
    return redirect('/settings')

@app.route('/user/del/<u>')
def u_del(u):
    os.system(f"userdel --force {u}")
    if os.path.exists(f"{DB_USERS}/{u}"): os.remove(f"{DB_USERS}/{u}")
    os.system(f"sed -i '/^{u}|/d' {DB_TRAFFIC}")
    os.system(f"sed -i '/^{u}|/d' {DB_SSH_FILE}")
    os.system(f"sed -i '/^{u}|/d' {DB_TOKEN_FILE}")
    return redirect(request.referrer)
@app.route('/user/lock/<u>')
def u_lock(u): os.system(f"passwd -l {u}"); return redirect(request.referrer)
@app.route('/user/unlock/<u>')
def u_unlock(u): os.system(f"passwd -u {u}"); return redirect(request.referrer)
@app.route('/user/renew/<u>')
def u_renew(u):
    if not check_login(): return redirect('/login')
    try:
        # --- CONFIGURACION BASE DE LA RECARGA ---
        base_days = 30
        base_mb_limit = 0 # Se obtendrá de la base de datos
        
        # 1. OBTENER DATOS ACTUALES (MB y FECHA)
        current_used_mb = 0
        current_limit_mb = 0
        current_expiry = ""
        
        # Leer limite y fecha de las DBs de SSH o Tokens
        found = False
        for db_file in [DB_SSH_FILE, DB_TOKEN_FILE]:
            if os.path.exists(db_file):
                res = get_cmd(f"grep -w '^{u}' {db_file}")
                if res:
                    parts = res.split('|')
                    # Formato SSH: user|pass|exp|limit_conn|limit_mb
                    # Formato Token: user|client|exp|limit_mb
                    current_expiry = parts[2]
                    current_limit_mb = int(parts[-1])
                    base_mb_limit = current_limit_mb # Guardamos el paquete original
                    found = True
                    break
        
        if not found:
            flash(f"Error: Usuario {u} no encontrado en base de datos.")
            return redirect(request.referrer)

        # Leer consumo actual desde traffic.db
        if os.path.exists(DB_TRAFFIC):
            t_res = get_cmd(f"grep -w '^{u}' {DB_TRAFFIC}")
            if t_res:
                t_parts = t_res.split('|')
                current_used_mb = int(int(t_parts[2]) / 1048576)

        # 2. CALCULAR ACUMULACION DE MB
        remaining_mb = current_limit_mb - current_used_mb
        if remaining_mb < 0: remaining_mb = 0 # Si ya se paso, no resta nada
        
        new_limit_mb = base_mb_limit + remaining_mb
        new_limit_bytes = new_limit_mb * 1048576

        # 3. CALCULAR ACUMULACION DE DIAS
        today = datetime.datetime.now()
        try:
            exp_dt = datetime.datetime.strptime(current_expiry, "%Y-%m-%d")
            remaining_days = (exp_dt - today).days
            if remaining_days < 0: remaining_days = 0
        except:
            remaining_days = 0
            
        total_days = base_days + remaining_days
        new_expiry_date = (today + datetime.timedelta(days=total_days)).strftime("%Y-%m-%d")

        # 4. APLICAR CAMBIOS EN EL SISTEMA LINUX
        os.system(f"chage -E '{new_expiry_date}' {u}")
        os.system(f"passwd -u {u} 2>/dev/null")
        os.system(f"pkill -u {u}") # Desconectar para refrescar
        os.system("iptables -Z FORWARD")

        # 5. ACTUALIZAR BASE DE DATOS DE TRAFICO (Reset a 0 usado)
        os.system(f"sed -i '/^{u}|/d' {DB_TRAFFIC}")
        with open(DB_TRAFFIC, "a") as f:
            f.write(f"{u}|{new_limit_bytes}|0|1\n")

        # 6. ACTUALIZAR BASE DE DATOS DE USUARIO (SSH o TOKEN)
        for db_file in [DB_SSH_FILE, DB_TOKEN_FILE]:
            if os.path.exists(db_file):
                # Reemplazamos la linea vieja por la nueva con los valores acumulados
                if db_file == DB_SSH_FILE:
                    # Buscamos la linea vieja para mantener pass y limit_conn
                    old_line = get_cmd(f"grep -w '^{u}' {DB_SSH_FILE}")
                    if old_line:
                        p = old_line.split('|')
                        new_line = f"{u}|{p[1]}|{new_expiry_date}|{p[3]}|{new_limit_mb}"
                        os.system(f"sed -i 's|^{old_line}|{new_line}|' {DB_SSH_FILE}")
                else:
                    # Para tokens
                    old_line = get_cmd(f"grep -w '^{u}' {DB_TOKEN_FILE}")
                    if old_line:
                        p = old_line.split('|')
                        new_line = f"{u}|{p[1]}|{new_expiry_date}|{new_limit_mb}"
                        os.system(f"sed -i 's|^{old_line}|{new_line}|' {DB_TOKEN_FILE}")

        flash(f"Usuario {u} RECARGADO: +{base_days} dias y +{base_mb_limit} MB acumulados.")
        
    except Exception as e:
        flash(f"Error en acumulacion: {str(e)}")
    return redirect(request.referrer)

# ==================================================
# CENTRO DE CONTROL PRO (PUNTOS 1 AL 4)
# ==================================================

@app.route('/tools')
def tools():
    if not check_login(): return redirect('/login')
    
    # 1. DETECCION DE ESTADOS (BBR, BADVPN, TORRENT)
    st_bbr = "ACTIVO" if "bbr" in get_cmd("sysctl net.ipv4.tcp_congestion_control") else "INACTIVO"
    st_bad = "ON" if os.system("pgrep -x badvpn-udpgw > /dev/null") == 0 else "OFF"
    st_tor = "BLOQUEADO" if "BitTorrent" in get_cmd("iptables -L FORWARD -n") else "PERMITIDO"
    
    # 2. CONTADOR FAIL2BAN
    f2b_count = get_cmd("fail2ban-client status sshd 2>/dev/null | grep 'Currently banned' | awk '{print $4}'")
    if not f2b_count: f2b_count = "0"

    h = f"""
    <div class="card" style="border-top: 3px solid #007bff;">
        <h2><i class="fas fa-rocket"></i> Optimizacion y Gaming</h2>
        <div class="grid-form">
            <div style="background:#222; padding:15px; border-radius:6px; text-align:center;">
                <b>LIMPIAR RAM</b><br><br>
                <a href="/action/clear_ram" class="btn btn-green" style="width:100%;">EJECUTAR</a>
            </div>
            <div style="background:#222; padding:15px; border-radius:6px; text-align:center;">
                <b>ACELERADOR BBR</b><br>
                Estado: <span style="color:{'#28a745' if st_bbr == 'ACTIVO' else '#dc3545'}">{st_bbr}</span><br><br>
                <a href="/action/toggle_bbr" class="btn">CAMBIAR</a>
            </div>
            <div style="background:#222; padding:15px; border-radius:6px; text-align:center;">
                <b>BADVPN (7300)</b><br>
                Estado: <span style="color:{'#28a745' if st_bad == 'ON' else '#dc3545'}">{st_bad}</span><br><br>
                <a href="/action/toggle_badvpn" class="btn btn-org">ON / OFF</a>
            </div>
        </div>
    </div>

    <div class="card" style="border-top: 3px solid #d32f2f;">
        <h2><i class="fas fa-shield-alt"></i> Seguridad y Anti-Ban</h2>
        <div class="grid-form">
            <div style="background:#222; padding:15px; border-radius:6px; text-align:center;">
                <b>ANTI-TORRENT</b><br>
                Estado: <b style="color:{'#28a745' if st_tor == 'BLOQUEADO' else '#ffc107'}">{st_tor}</b><br><br>
                <a href="/action/toggle_torrent" class="btn btn-org">CAMBIAR</a>
            </div>
            <div style="background:#222; padding:15px; border-radius:6px; text-align:center;">
                <b>FAIL2BAN</b><br>
                Baneados: <b style="color:#ef5350;">{f2b_count} IPs</b><br><br>
                <a href="/action/clear_fail2ban" class="btn btn-red">LIMPIAR BANEOS</a>
            </div>
        </div>
    </div>

    <div class="card" style="border-top: 3px solid #27ae60;">
        <h2><i class="fas fa-download"></i> Gestion de Backups</h2>
        <p>Descarga un respaldo completo de usuarios y configuraciones a tu PC.</p>
        <div style="display:flex; gap:10px;">
            <a href="/backup/download" class="btn btn-green" style="flex:1; text-align:center;"><i class="fas fa-file-download"></i> DESCARGAR BACKUP (.TAR.GZ)</a>
        </div>
    </div>
    """
    return render_template_string(LAYOUT, body=h)

# RUTA DE ACCIONES DE SISTEMA
@app.route('/action/<cmd>')
def system_actions(cmd):
    if not check_login(): return redirect('/login')
    if cmd == "clear_ram":
        os.system("sync; echo 3 > /proc/sys/vm/drop_caches")
        flash("Memoria RAM optimizada.")
    elif cmd == "toggle_bbr":
        if "bbr" in get_cmd("sysctl net.ipv4.tcp_congestion_control"):
            os.system("sed -i '/bbr/d' /etc/sysctl.conf; sysctl -p > /dev/null")
            flash("BBR Desactivado.")
        else:
            os.system("echo 'net.core.default_qdisc=fq' >> /etc/sysctl.conf; echo 'net.ipv4.tcp_congestion_control=bbr' >> /etc/sysctl.conf; sysctl -p > /dev/null")
            flash("BBR Activado.")
    elif cmd == "toggle_badvpn":
        if os.system("pgrep -x badvpn-udpgw > /dev/null") == 0:
            os.system("systemctl stop badvpn")
            flash("BadVPN Detenido.")
        else:
            os.system("systemctl start badvpn")
            flash("BadVPN Iniciado en puerto 7300.")
    elif cmd == "toggle_torrent":
        if "BitTorrent" in get_cmd("iptables -L FORWARD -n"):
            os.system("iptables -D FORWARD -m string --algo bm --string 'BitTorrent' -j DROP 2>/dev/null")
            flash("Torrent Permitido.")
        else:
            os.system("iptables -I FORWARD -m string --algo bm --string 'BitTorrent' -j DROP")
            flash("Torrent Bloqueado.")
    elif cmd == "clear_fail2ban":
        os.system("fail2ban-client unban --all")
        flash("Ips liberadas.")
    return redirect('/tools')

# RUTA PARA DESCARGAR BACKUP
from flask import send_file
@app.route('/backup/download')
def backup_download():
    if not check_login(): return redirect('/login')
    try:
        b_name = f"backup_reagens_{datetime.datetime.now().strftime('%Y%m%d')}"
        os.system(f"rm -rf /tmp/{b_name}*; mkdir -p /tmp/{b_name}")
        os.system(f"cp -r /etc/reagens /etc/adm-lite /tmp/{b_name}/")
        os.system(f"tar -czf /tmp/{b_name}.tar.gz -C /tmp {b_name}")
        return send_file(f"/tmp/{b_name}.tar.gz", as_attachment=True)
    except Exception as e:
        flash(f"Error: {str(e)}")
        return redirect('/tools')

if __name__ == '__main__': app.run(host='0.0.0.0', port=PORT)
EOF

                sed -i "s/PORT = 8081/PORT = $P_WEB_NEW/" /etc/reagens/panel_rvp.py

                echo -e " ${C_DATO}[+] Activando Servicio Systemd...${C_RESET}"
                cat <<'END_SERVICE' > /etc/systemd/system/rvp-panel.service
[Unit]
Description=Reagens Web Panel PRO
After=network.target

[Service]
ExecStart=/usr/bin/python3 /etc/reagens/panel_rvp.py
Restart=always
RestartSec=5
User=root
WorkingDirectory=/etc/reagens

[Install]
WantedBy=multi-user.target
END_SERVICE
                
                if [[ ! -f "/etc/reagens/panel_auth" ]]; then echo "admin:admin" > /etc/reagens/panel_auth; fi

                if [[ "$P_WEB_ACTUAL" != "$P_WEB_NEW" ]]; then
                    systemctl stop rvp-panel >/dev/null 2>&1
                    iptables -D INPUT -p tcp --dport $P_WEB_ACTUAL -j ACCEPT 2>/dev/null
                fi

                systemctl daemon-reload
                systemctl enable rvp-panel >/dev/null 2>&1
                systemctl restart rvp-panel
                iptables -I INPUT -p tcp --dport $P_WEB_NEW -j ACCEPT
                fun_save_iptables >/dev/null 2>&1
                
                sleep 2
                if ! systemctl is-active --quiet rvp-panel; then
                    echo -e "${C_ROJO} ERROR AL INICIAR. MOSTRANDO LOG:${C_RESET}"
                    journalctl -u rvp-panel -n 10 --no-pager
                else
                    IP=$(curl -s ipv4.icanhazip.com)
                    echo ""
                    echo -e "${C_VERDE} PANEL PRO INSTALADO CORRECTAMENTE.${C_RESET}"
                    echo -e " URL: http://$IP:$P_WEB_NEW"
                    echo -e " USER: admin  |  PASS: admin"
                    echo -e " (El script de Python ahora usa el puerto $P_WEB_NEW)"
                    echo ""
                fi
                
                cat <<CMD_EOF > /usr/bin/r-vp
#!/bin/bash
IP=\$(curl -s ipv4.icanhazip.com)
PORT=$P_WEB_NEW
echo -e "\033[1;32m R-VP ONLINE: \033[1;37mhttp://\$IP:\$PORT\033[0m"
CMD_EOF
                chmod +x /usr/bin/r-vp
                echo -e " ${C_DATO}Comando 'r-vp' instalado.${C_RESET}"
                
                read -p " Enter para continuar..."
                ;;
                
            2)
                echo -e "${C_ROJO} [!] ELIMINANDO PANEL...${C_RESET}"
                systemctl stop rvp-panel
                systemctl disable rvp-panel
                rm -f /etc/systemd/system/rvp-panel.service
                rm -f /etc/reagens/panel_rvp.py
                rm -f /usr/bin/r-vp
                iptables -D INPUT -p tcp --dport $P_WEB_ACTUAL -j ACCEPT 2>/dev/null
                fun_save_iptables >/dev/null 2>&1
                systemctl daemon-reload
                echo -e "${C_VERDE} Panel Eliminado.${C_RESET}"
                sleep 2
                ;;
                
            3) systemctl start rvp-panel; echo "Iniciado."; sleep 2 ;;
            4) systemctl stop rvp-panel; echo "Detenido."; sleep 2 ;;
            5)
                echo -e "\n ${C_DATO}--- CAMBIO DE CREDENCIALES ---${C_RESET}"
                echo -n " Nuevo User: "; read u
                echo -n " Nueva Pass: "; read p
                if [[ ! -z "$u" && ! -z "$p" ]]; then
                    echo "$u:$p" > /etc/reagens/panel_auth
                    echo -e "${C_VERDE}Actualizado.${C_RESET}"
                fi
                sleep 2
                ;;
            0) break ;;
        esac
    done
}

menu_bot_telegram() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} CREADOR DE BOTS DE TELEGRAM (AUDITED) ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        
        if systemctl is-active --quiet reagens-bot; then 
            BOT_ST="${C_VERDE}ACTIVO${C_RESET}"
        else 
            BOT_ST="${C_ROJO}DETENIDO${C_RESET}"
        fi
        
        echo -e " ESTADO ACTUAL: $BOT_ST"
        echo -e "${C_BARRA}-----------------------------------------------------${C_RESET}"
        echo -e " ${C_TEXTO}[1] > CREAR Y ACTIVAR BOT (SISTEMA COMPLETO)${C_RESET}"
        echo -e " ${C_TEXTO}[2] > DETENER BOT${C_RESET}"
        echo -e " ${C_TEXTO}[3] > ELIMINAR BOT${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -ne " Opcion: "
        read op

        case $op in
            1)
                echo -e " ${C_DATO}Verificando librerias Python...${C_RESET}"
                pip3 install pyTelegramBotAPI requests --break-system-packages > /dev/null 2>&1 || pip3 install pyTelegramBotAPI requests > /dev/null 2>&1
                
                echo -e "\n ${C_TEXTO}Ingresa tu ${C_DATO}API TOKEN${C_TEXTO}:${C_RESET}"
                read -p "> " TOKEN
                echo -e " ${C_TEXTO}Ingresa tu ${C_DATO}ID de Telegram${C_TEXTO}:${C_RESET}"
                read -p "> " ADMIN_ID
                
                if [[ -z "$TOKEN" || -z "$ADMIN_ID" ]]; then 
                    echo -e "${C_ROJO}Error: Datos vacios.${C_RESET}"; sleep 2; continue
                fi
                
                echo "Generando Script del Bot..."

# USAMOS 'EOF' CON COMILLAS PARA PROTEGER EL CODIGO PYTHON DE BASH
cat <<'EOF' > "$BOT_SCRIPT"
import telebot, subprocess, os, json, datetime, time, uuid, base64, re
import requests
from telebot import types
from datetime import datetime, timedelta

TOKEN = "TOKEN_PLACEHOLDER"
ADMIN_ID = ADMIN_PLACEHOLDER

DB_SSH = "/etc/adm-lite/usuarios_ssh.db"
DB_TOKENS = "/etc/adm-lite/usuarios_token.db"
DB_TRAFFIC = "/etc/reagens/traffic.db"
V2_CONF = "/usr/local/etc/xray/config.json"
TOKEN_PASS_FILE = "/etc/reagens_base_pass"
DB_V2_USERS = "/etc/reagens/users/v2ray"
REALITY_PUB = "/etc/reagens/reality_pub"

bot = telebot.TeleBot(TOKEN)

def is_admin(m):
    return str(m.from_user.id) == str(ADMIN_ID)

def shell(cmd):
    try: return subprocess.check_output(cmd, shell=True).decode().strip()
    except: return ""

def get_ip():
    try: return requests.get('http://ipv4.icanhazip.com', timeout=3).text.strip()
    except: return "127.0.0.1"

def get_base_pass():
    if os.path.exists(TOKEN_PASS_FILE): return open(TOKEN_PASS_FILE).read().strip()
    return "123456"

def add_traffic_user(user, mb):
    b_val = int(mb) * 1048576
    os.system(f"sed -i '/^{user}|/d' {DB_TRAFFIC}")
    with open(DB_TRAFFIC, "a") as f: f.write(f"{user}|{b_val}|0|1\n")
    os.system(f"iptables -I OUTPUT -m owner --uid-owner {user} -j ACCEPT 2>/dev/null")

def gen_v2ray_link(user, uuid_val):
    try:
        with open(V2_CONF, 'r') as f: c = json.load(f)
        ip = get_ip(); links_acc = "" 
        for inb in c['inbounds']:
            p_p = inb['port']; p_proto = inb['protocol']; p_net = inb['streamSettings'].get('network','tcp')
            nm = f"{user}-{p_proto}-{p_net}"
            if p_proto == "vmess":
                js = {"v":"2","ps":nm,"add":ip,"port":p_p,"id":uuid_val,"aid":"0","scy":"auto","net":p_net,"type":"none","tls":"none"}
                links_acc += f"vmess://{base64.b64encode(json.dumps(js).encode()).decode()}\n\n"
            elif p_proto == "vless":
                links_acc += f"vless://{uuid_val}@{ip}:{p_p}?type={p_net}&security=none#{nm}\n\n"
        return links_acc
    except: return "Error"

@bot.message_handler(commands=['start', 'menu', 'ayuda'])
def main_menu(m):
    if not is_admin(m): return
    txt = (
        "??? **REAGENS VPN PRO - COMANDOS**\n\n"
        "?? **SSH / DROPBEAR**\n"
        "/addssh - Crear\n"
        "/renewssh - Recarga Acumulativa\n"
        "/editssh - Editar Manual\n"
        "/blockssh | /unblockssh\n"
        "/delssh | /listssh1 | /listssh2\n\n"
        "?? **TOKEN ID (APPS)**\n"
        "/addtoken - Crear\n"
        "/renewtoken - Recarga Acumulativa\n"
        "/edittoken - Editar Manual\n"
        "/deltoken | /listtoken1 | /listtoken2\n\n"
        "?? **V2RAY / XRAY**\n"
        "/addv2 | /editv2 | /delv2 | /listv2"
    )
    bot.reply_to(m, txt, parse_mode="Markdown")

# --- RENOVACION INTERACTIVA ---

@bot.message_handler(commands=['renewssh'])
def r_ssh_start(m):
    if not is_admin(m): return
    msg = bot.reply_to(m, "?? Ingrese el **NOMBRE** del usuario SSH a recargar:")
    bot.register_next_step_handler(msg, p_ssh_r)

def p_ssh_r(m):
    try:
        u = m.text.strip(); d_a = 30
        old = shell(f"grep -w '^{u}' {DB_SSH}")
        if not old: return bot.send_message(m.chat.id, "? No encontrado.")
        p = old.split('|'); c_e = p[2]; b_m = int(p[4])
        t_r = shell(f"grep -w '^{u}' {DB_TRAFFIC}")
        u_m = int(int(t_r.split('|')[2]) / 1048576) if t_r else 0
        n_m = b_m + max(0, b_m - u_m)
        td = datetime.now()
        try: rd = max(0, (datetime.strptime(c_e, "%Y-%m-%d") - td).days)
        except: rd = 0
        n_e = (td + timedelta(days=d_a + rd)).strftime("%Y-%m-%d")
        os.system(f"chage -E '{n_e}' {u}; passwd -u {u}; pkill -u {u}; sed -i '/^{u}|/d' {DB_TRAFFIC}")
        with open(DB_TRAFFIC, "a") as f: f.write(f"{u}|{n_m * 1048576}|0|1\n")
        new_l = f"{u}|{p[1]}|{n_e}|{p[3]}|{n_m}"
        os.system(f"sed -i 's|^{re.escape(old)}|{new_l}|' {DB_SSH}")
        bot.send_message(m.chat.id, f"? **SSH RECARGADO**\nUser: `{u}`\nExp: `{n_e}`\nLimite: `{n_m} MB`", parse_mode="Markdown")
    except Exception as e: bot.send_message(m.chat.id, f"Error: {e}")

@bot.message_handler(commands=['renewtoken'])
def r_tok_start(m):
    if not is_admin(m): return
    msg = bot.reply_to(m, "?? Ingrese el **ID** del Token a recargar:")
    bot.register_next_step_handler(msg, p_tok_r)

def p_tok_r(m):
    try:
        u = m.text.strip(); d_a = 30
        old = shell(f"grep -w '^{u}' {DB_TOKENS}")
        if not old: return bot.send_message(m.chat.id, "? No encontrado.")
        p = old.split('|'); c_e = p[2]; b_m = int(p[3])
        t_r = shell(f"grep -w '^{u}' {DB_TRAFFIC}")
        u_m = int(int(t_r.split('|')[2]) / 1048576) if t_r else 0
        n_m = b_m + max(0, b_m - u_m)
        td = datetime.now()
        try: rd = max(0, (datetime.strptime(c_e, "%Y-%m-%d") - td).days)
        except: rd = 0
        n_e = (td + timedelta(days=d_a + rd)).strftime("%Y-%m-%d")
        os.system(f"chage -E '{n_e}' {u}; passwd -u {u}; pkill -u {u}; sed -i '/^{u}|/d' {DB_TRAFFIC}")
        with open(DB_TRAFFIC, "a") as f: f.write(f"{u}|{n_m * 1048576}|0|1\n")
        new_l = f"{u}|{p[1]}|{n_e}|{n_m}"
        os.system(f"sed -i 's|^{re.escape(old)}|{new_l}|' {DB_TOKENS}")
        bot.send_message(m.chat.id, f"? **TOKEN RECARGADO**\nID: `{u}`\nExp: `{n_e}`\nLimite: `{n_m} MB`", parse_mode="Markdown")
    except Exception as e: bot.send_message(m.chat.id, f"Error: {e}")

# --- COMANDOS SSH ---
@bot.message_handler(commands=['addssh'])
def a_ssh(m):
    if not is_admin(m): return
    try:
        p = m.text.split(); u, pw, d, l, mb = p[1], p[2], p[3], p[4], p[5]
        fd = shell(f"date -d '+{d} days' +%Y-%m-%d")
        os.system(f"useradd -M -s /bin/false {u}; echo '{u}:{pw}' | chpasswd; chage -E '{fd}' {u}")
        add_traffic_user(u, mb)
        with open(DB_SSH, "a") as f: f.write(f"{u}|{pw}|{fd}|{l}|{mb}\n")
        bot.reply_to(m, f"? SSH Creado: {u}")
    except: bot.reply_to(m, "Uso: /addssh user pass dias limit mb")

@bot.message_handler(commands=['editssh'])
def e_ssh(m):
    if not is_admin(m): return
    try:
        p = m.text.split(); u, d, l, mb = p[1], p[2], p[3], p[4]
        old = shell(f"grep -w '^{u}' {DB_SSH}")
        if old:
            fd = shell(f"date -d '+{d} days' +%Y-%m-%d")
            os.system(f"chage -E '{fd}' {u}"); add_traffic_user(u, mb)
            pts = old.split('|'); n_l = f"{u}|{pts[1]}|{fd}|{l}|{mb}"
            os.system(f"sed -i 's|^{re.escape(old)}|{n_l}|' {DB_SSH}")
            bot.reply_to(m, f"? SSH {u} Editado.")
    except: bot.reply_to(m, "Error.")

@bot.message_handler(commands=['listssh1'])
def l_ssh1(m):
    if not is_admin(m): return
    msg = "?? **DETALLES SSH**\n"
    if os.path.exists(DB_SSH):
        with open(DB_SSH) as f:
            for l in f:
                p = l.strip().split('|')
                msg += f"?? `{p[0]}` | Pass: `{p[1]}` | Vence: `{p[2]}`\n"
    bot.reply_to(m, msg, parse_mode="Markdown")

@bot.message_handler(commands=['listssh2'])
def l_ssh2(m):
    if not is_admin(m): return
    msg = "?? **ESTADO SSH**\n"
    if os.path.exists(DB_SSH):
        with open(DB_SSH) as f:
            for l in f:
                u = l.strip().split('|')[0]
                con = shell(f"ps -u {u} | grep -E 'sshd|dropbear' | wc -l")
                ico = "??" if int(con) > 0 else "?"
                msg += f"{ico} `{u}`: {con} conex.\n"
    bot.reply_to(m, msg, parse_mode="Markdown")

# --- COMANDOS TOKENS ---
@bot.message_handler(commands=['addtoken'])
def a_tok(m):
    if not is_admin(m): return
    try:
        p = m.text.split(); u, d, nom, mb = p[1], p[2], p[3], p[4]
        pw = get_base_pass(); fd = shell(f"date -d '+{d} days' +%Y-%m-%d")
        os.system(f"useradd -M -s /bin/false -c '{nom}' {u}; echo '{u}:{pw}' | chpasswd; chage -E '{fd}' {u}")
        add_traffic_user(u, mb)
        with open(DB_TOKENS, "a") as f: f.write(f"{u}|{nom}|{fd}|{mb}\n")
        bot.reply_to(m, f"? Token Creado: {u}")
    except: bot.reply_to(m, "Error.")

@bot.message_handler(commands=['listtoken1'])
def l_tok1(m):
    if not is_admin(m): return
    msg = "?? **DETALLES TOKENS**\n"
    if os.path.exists(DB_TOKENS):
        with open(DB_TOKENS) as f:
            for l in f:
                p = l.strip().split('|')
                msg += f"?? `{p[0]}` | Cliente: `{p[1]}` | Exp: `{p[2]}`\n"
    bot.reply_to(m, msg, parse_mode="Markdown")

@bot.message_handler(commands=['listtoken2'])
def l_tok2(m):
    if not is_admin(m): return
    msg = "?? **ESTADO TOKENS**\n"
    if os.path.exists(DB_TOKENS):
        with open(DB_TOKENS) as f:
            for l in f:
                u = l.strip().split('|')[0]
                con = shell(f"ps -u {u} | grep -E 'sshd|dropbear' | wc -l")
                ico = "??" if int(con) > 0 else "?"
                msg += f"{ico} `{u}`: {con} conex.\n"
    bot.reply_to(m, msg, parse_mode="Markdown")

# --- COMANDOS V2RAY (RESTAURADOS COMPLETOS) ---
@bot.message_handler(commands=['addv2'])
def a_v2(m):
    if not is_admin(m): return
    try:
        p = m.text.split(); u, d = p[1], p[2]; uv = str(uuid.uuid4())
        with open(V2_CONF, 'r') as f: c = json.load(f)
        for i in c['inbounds']: i['settings']['clients'].append({"id":uv, "email":u})
        with open(V2_CONF, 'w') as f: json.dump(c, f, indent=2)
        os.system("systemctl restart xray")
        fd = shell(f"date -d '+{d} days' +%Y-%m-%d")
        if not os.path.exists(DB_V2_USERS): os.makedirs(DB_V2_USERS)
        with open(f"{DB_V2_USERS}/{u}", "w") as f: f.write(f"EXP={fd}\nUUID={uv}\n")
        bot.reply_to(m, f"? V2RAY Creado: {u}\nLinks:\n{gen_v2ray_link(u, uv)}")
    except: bot.reply_to(m, "Uso: /addv2 user dias")

@bot.message_handler(commands=['listv2'])
def l_v2(m):
    if not is_admin(m): return
    if not os.path.exists(V2_CONF): return bot.reply_to(m, "Xray no instalado.")
    try:
        with open(V2_CONF) as f: c = json.load(f)
        clients = c['inbounds'][0]['settings']['clients']
        for x in clients:
            u = x.get('email'); uid = x.get('id', x.get('password')); exp = "---"
            mf = f"{DB_V2_USERS}/{u}"
            if os.path.exists(mf):
                with open(mf) as f_m:
                    for line in f_m:
                        if "EXP=" in line: exp = line.split("=")[1].strip()
            bot.send_message(m.chat.id, f"?? **Usuario:** `{u}`\n?? **Exp:** `{exp}`\n\n?? **Links:**\n{gen_v2ray_link(u, uid)}", parse_mode="Markdown")
    except: bot.reply_to(m, "Error en lista.")

@bot.message_handler(commands=['delv2'])
def d_v2(m):
    if not is_admin(m): return
    try:
        u = m.text.split()[1]
        os.system(f"jq --arg e '{u}' 'del(.inbounds[].settings.clients[] | select(.email == $e))' {V2_CONF} > {V2_CONF}.tmp && mv {V2_CONF}.tmp {V2_CONF}")
        os.system(f"systemctl restart xray; rm -f {DB_V2_USERS}/{u}")
        bot.reply_to(m, f"??? V2Ray {u} borrado.")
    except: bot.reply_to(m, "Error.")

bot.polling(none_stop=True)
EOF
                # INYECCION DE TOKEN E ID SEGURO
                sed -i "s/TOKEN_PLACEHOLDER/$TOKEN/" "$BOT_SCRIPT"
                sed -i "s/ADMIN_PLACEHOLDER/$ADMIN_ID/" "$BOT_SCRIPT"

                cat <<EOF > "$BOT_SERVICE"
[Unit]
Description=Reagens Bot Telegram PRO
After=network.target
[Service]
ExecStart=/usr/bin/python3 $BOT_SCRIPT
Restart=always
RestartSec=5
[Install]
WantedBy=multi-user.target
EOF
                systemctl daemon-reload
                systemctl enable reagens-bot >/dev/null 2>&1
                systemctl restart reagens-bot
                echo -e " ${C_VERDE}BOT PRO ACTIVADO CON TODAS LAS FUNCIONES.${C_RESET}"
                sleep 3
                ;;
            2) systemctl stop reagens-bot; echo -e "${C_ROJO} Bot Detenido.${C_RESET}"; sleep 2 ;;
            3) systemctl stop reagens-bot; systemctl disable reagens-bot; rm -f "$BOT_SCRIPT" "$BOT_SERVICE"; echo -e "${C_ROJO} Bot Eliminado.${C_RESET}"; sleep 2 ;;
            0) break ;;
        esac
    done
}

# 5. MENU PRINCIPAL DE CONEXIONES (EL QUE NOABRIA)
menu_conexiones() {
    while true; do
        clear
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        msg_center "${C_TITULO} ADMINISTRADOR DE CONEXIONES ${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}[1]  > GESTION CUENTAS SSH / DROPBEAR${C_RESET}"
        echo -e " ${C_TEXTO}[2]  > GESTION CUENTAS XRAY / V2RAY${C_RESET}"
        echo -e " ${C_DATO}[3]  > GESTION HYSTERIA V2 (UDP ACCEL)${C_RESET}"
        echo -e " ${C_DATO}[4]  > GESTION TOKENS (APP ID)${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -e " ${C_TEXTO}0) VOLVER AL MENU PRINCIPAL${C_RESET}"
        echo -e "${C_BARRA}=====================================================${C_RESET}"
        echo -n " Opcion: "
        read op_c
        case $op_c in
            1) menu_ssh ;;
            2) menu_v2ray ;;
            3) menu_hysteria ;;
            4) menu_tokens ;;
            0) break ;;
        esac
    done
}

# --- MENU PRINCIPAL FINAL (OPTIMIZADO V4 - ASINCRONO + REFRESCO VISUAL) ---
clear
while true; do
    obtener_datos # Carga instantanea (datos viejos) + Lanza proceso de actualizacion
    if command -v tput &>/dev/null; then tput cup 0 0; else clear; fi

    echo -e "${C_BARRA}======================================================${C_RESET}"
    msg_center "${C_TITULO} REAGENS VPN PRO MANAGER FOR VPS ${C_RESET}"
    echo -e "${C_BARRA}======================================================${C_RESET}"
    
    printf "${C_BARRA}| ${C_TEXTO}%-19s${C_BARRA}| ${C_TEXTO}%-14s${C_BARRA}| ${C_TEXTO}%-14s${C_BARRA}|${C_RESET}\n" "SISTEMA" "MEMORIA" "PROCESADOR"
    echo -e "${C_BARRA}|--------------------|---------------|---------------|${C_RESET}"

    printf "${C_BARRA}|${C_TEXTO} S.O: %-14s${C_BARRA}|${C_TEXTO} RAM: %-9s${C_BARRA}|${C_TEXTO} CPU: %-9s${C_BARRA}|${C_RESET}\n" "${OS_NAME:0:14}" "$RAM_TOTAL" "$CPU_CORES"
    printf "${C_BARRA}|${C_TEXTO} IP:  %-14s${C_BARRA}|${C_TEXTO} USE: %-9s${C_BARRA}|${C_TEXTO} USE: %-9s${C_BARRA}|${C_RESET}\n" "${IP_DISP:0:14}" "$RAM_USED" "$CPU_USAGE"
    printf "${C_BARRA}|${C_TEXTO} FEC: %-14s${C_BARRA}|${C_TEXTO} LIB: %-9s${C_BARRA}|${C_TEXTO} %-14s${C_BARRA}|${C_RESET}\n" "$FECHA_ACT" "$RAM_FREE" "${CPU_INFO:0:14}"
    printf "${C_BARRA}|${C_TEXTO} HOR: %-14s${C_BARRA}|${C_TEXTO} TOT: %-9s${C_BARRA}|${C_TEXTO} %-14s${C_BARRA}|${C_RESET}\n" "$HORA_ACT" "$RAM_PERC" ""

    echo -e "${C_BARRA}======================================================${C_RESET}"
    printf "${C_BARRA}|${C_TEXTO} ONLI: ${C_VERDE}%-4s${C_TEXTO} EXP: ${C_ROJO}%-4s${C_TEXTO} LOK: ${C_DATO}%-4s${C_TEXTO} TOTAL: %-13s${C_BARRA}|${C_RESET}\n" "$ONLI_USR" "$EXP_USR" "$LOK_USR" "$TOTAL_USR"
    echo -e "${C_BARRA}======================================================${C_RESET}"
    
    echo -e " ${C_TEXTO}[1] > ADMINISTRADOR DE CONEXIONES (SSH/Xray/Hysteria)${C_RESET}"
    echo -e " ${C_TEXTO}[2] > AJUSTES DEL SISTEMA (Puertos/Hora/Tools)${C_RESET}"
    echo -e "${C_BARRA}------------------------------------------------------${C_RESET}"
    echo -e " ${C_TEXTO}[3] > CREAR BOT TELEGRAM${C_RESET}"
    echo -e "${C_BARRA}------------------------------------------------------${C_RESET}"
    echo -e " ${C_ROJO}[4] > [!] DESINSTALAR SISTEMA REAGENS VPN PRO${C_RESET}"
    echo -e "${C_BARRA}======================================================${C_RESET}"
    echo -e " ${C_TEXTO}0) SALIR DEL VPS  8) SALIR DEL SCRIPT  9) REBOOT VPS${C_RESET}"
    echo -e "${C_BARRA}======================================================${C_RESET}"
    echo ""
    echo -n " Seleccione una Opcion: "
    
    # Mantenemos el refresco de 1s para que la hora se mueva y no se vea plano
    # Pero como obtener_datos es ASINCRONO, ya no se trabara.
    read -t 1 -n 1 opcion
    
    if [[ -z "$opcion" ]]; then continue; fi
    
    case $opcion in
        1) menu_conexiones; clear;;
        2) menu_ajustes; clear;;
        3) menu_bot_telegram ;;
        4) fun_deep_clean ;;
        8) fun_salir_script;;
        9) clear; reboot;;
        0) clear; exit 0;;
        *) ;;
    esac
done